<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="Commata.xsl"?>
<document>
<title>Specification of Commata, which is just another C++14 CSV parser</title>
<signature>2019-04-29 (UTC)</signature>

<section id="introduction">
  <name>Introduction</name>

  <section id="introduction.general">
    <name>General</name>

    <p>This document describes the specifications of Commata, which is a header-only library in C++14 to handle formatted texts, such as CSV texts.</p>
    <p>In this document, many terms and names introduced in ISO C++14 standard are referred without notice.
       &#x201c;Unspecified behavior,&#x201d; &#x201c;<c>DefaultConstructible</c> requirements,&#x201d; &#x201c;formatted output function,&#x201d; &#x201c;<c>&lt;string></c>&#x201d; (as a header name) and &#x201c;<c>std::string</c>&#x201d; are the examples.</p>

    <p>The normativity of the specifications on this document is the same as the normativity of the description of the ISO C++14 standard for its conforming standard library implementations except that:</p>
    <ul>
      <li>class templates and function templates shall not have any additional template parameters no matter whether they have their default template-arguments, and</li>
      <li>member templates shall not have any additional template parameters no matter whether they have their default template arguments, except that constructor templates can have ones with their default template arguments.</li>
      <li>member function templates shall not have any additional parameters no matter whether they have their default arguments.</li>
    </ul>
  </section>

  <section id="introduction.using">
    <name>Using Commata</name>

    <p>A translation unit may include headers described in this document in any order.
       Each may be included more than once, with no effect different from being included exactly once.</p>
    <p>A translation unit shall include a header described in this document only outside of any external declaration or definition, and shall include the header lexically before the first reference in that translation unit to any of the entities declared in that header.</p>
    <p>A translation unit shall not define a macro whose name meets one of the following before a point of an <c>#include</c> preprocessor directive which includes a header described in this document:</p>
    <ul>
      <li>it consists only of one uppercase alphabetic letter,</li>
      <li>it begins with a lowercase alphabetic letter,</li>
      <li>it consists only of alphabetic letters and decimal digit characters, the number of the latter of which may possibly be zero, contains both of an uppercase alphabetic letter and a lowercase one, and begins with an uppercase one, or</li>
      <li>it begins with <c>COMMATA_</c>.</li>
    </ul>
    <p>Headers described in this document may define macros whose name begin with <c>COMMATA_</c> and may not define any macros with other names.</p>
  </section>

  <section id="concepts">
    <name>Basic concepts</name>

    <p>Commata consists of two loosely-coupled parts following:</p>
    <ul>
      <li>the <n>parser</n>, which reads a sequence of char-like objects in a certain format such as a CSV text (<xref id="definitions.csv_text"/>) from a stream or a stream buffer and emits events to a handler, which is called a <n>text handler</n>, and</li>
      <li>default text handlers, objects of which receive events from the parser and do some default operation on them.</li>
    </ul>
    <p>Due to this loosely-coupled nature, you can implement your own new text handler and make the parser emit events to an object of it. The requrements that the parser need text handlers to meet are bundled as the <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>).</p>
  </section>

  <section id="definitions">
    <name>Definitions</name>

    <section id="definitions.text_table">
      <name>Text tables</name>

      <p>Events that text handlers receive from the parser conform the <n>text table</n> model following:</p>
      <ul>
        <li>Each text table has its <n>char type</n> that is a char-like type.</li>
        <li>A text table is a sequence of <n>text records</n>.</li>
        <li>A text record is a sequence of <n>text fields</n>.</li>
        <li>Each text field has its <n>text value</n>, which is a sequence of the char type objects.</li>
      </ul>
    </section>

    <section id="definitions.csv_text">
      <name>CSV texts</name>

      <p>The CSV parser of Commata (<xref id="parse_csv"/>) conforms the <n>CSV text</n> model following:</p>
      <ul>
        <li>A CSV text is a representation of a text table (<xref id="definitions.text_table"/>) as a sequence of objects whose type is the char type of the text table.</li>
        <li>Each CSV text has its <n>char type</n> that is equal to the char type of the text table.</li>
        <li>Each text field of a text table represented as a CSV text is either of a <n>quoted field</n> or a <n>unquoted field</n>.</li>
        <li>A quoted field is represented as a sequence of the char type objects that starts with a double quote and ends with a double quote.
            Its representation cannot contain odd number of contiguous double quotes after the the starting double quote and before the ending double quote.</li>
        <li>An unquoted field is represented as a sequence of the char type objects that does not contain any double quotes, commas and <n>line breaks</n>.</li>
        <li>The text value of a quoted field is defined as follows:
            <ul>
              <li>first make a copy of the sequence of characters of the range [the next character of the starting double quote, the previous character of the ending double quote],</li>
              <li>then replace every occurrence of two contiguous double quotes in it into one double quote.</li>
            </ul>
        </li>
        <li>The text value of an unquoted field is the representation as a sequence of the char type objects itself.</li>
        <li>In a CSV text, each text record is represented as a comma-delimited sequence of representations of its text fields.
            The representation of the final text field in a text record is not followed by a comma.</li>
        <li>In a CSV text, the representations of its text records are delimited by a line break.
            The representation of the final record is or is not followed by a line break.</li>
        <li>Each line break is either of CR, LF, or CRLF where CR is a carrage return character, LF is a line feed (or new-line) character, and CRLF is a two-character sequence the first character of which is CR and the second is LF.</li>
      </ul>
    </section>

    <section id="definitions.others">
      <name>Other definitions</name>

      <ul>
        <li>A <n>record index</n> of a text record in a text table is a number i where the record is the i-th record in the text table.
            It depends on situation whether i is zero-based or one-based.</li>
        <li>A <n>field index</n> of a text field in a text record is a number j where the field is the j-th field in the text record.
            It depends on situation whether j is zero-based or one-based.</li>
        <li>A <n>line</n> or <n>physical line</n> in a sequence of char-like objects is a sequence of characters delimited by line breaks. It does not contain any line breaks in it.</li>
        <li>A <n>column</n> or <n>physical column</n> in a sequence of char-like objects is a bundle of the same distant characters from the first character of each line.</li>
        <li>A <n>position</n> or <n>physical position</n> of a character in a sequence of char-like objects is the pair of m and n where the character belongs to the m-th line and the n-th column.
            It depends on situation whether m and n are zero-based or one-based.</li>
      </ul>
    </section>
  </section>

  <section id="text_handler.requirements">
    <name><c>TextHandler</c> requirements</name>

    <p>A type <c>T</c> meets the <c>TextHandler</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
    <ul>
      <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
      <li>the expressions shown in <xref id="table.text_handler.requirements"/> are valid and have the indidated semantics.</li>
    </ul>

    <p>In <xref id="table.text_handler.requirements"/>, <c>T</c> is cv-unqualified. <c>t</c> is an lvalue of <c>T</c>.</p>

    <p>A requirement is optional if the last column of <xref id="table.text_handler.requirements"/> specifies a default.</p>
    <p>If (2) in <xref id="table.text_handler.requirements"/> is satisfied without falling back on the default, then also (3) shall be so. Likewise, if (3) is satisfied without falling back on the default, then also (2) shall be so.
       That is, <c>T</c> shall either have both of <c>get_buffer</c> and <c>release_buffer</c> member functions or have none of them.</p>

    <table id="table.text_handler.requirements">
      <caption>TextHandler requirements</caption>
      <col width="1"/><col width="4"/><col width="5"/><col width="10"/><col width="4"/>

      <tr>
        <th>#</th>
        <th>Expression</th>
        <th>Return Type</th>
        <th>Remark</th>
        <th>Default Behavior</th>
      </tr>

      <tr>
        <td>(1)</td>
        <td><c>T::char_type</c></td>
        <td></td>
        <td>Shall be an identical type to <c>Ch</c>.</td>
        <td></td>
      </tr>

      <tr>
        <td>(2)</td>
        <td><c>t.get_buffer()</c></td>
        <td><c>std::pair&lt;Ch*, std::size_t&gt;</c></td>
        <td><p>Called when the parser requires a new buffer.
               The parser calls this function only just after it was attached to this handler or just after it called (3).</p>
            <p>Shall return a pair of a pointer that points the first element of a secured buffer and its length.
               The parser utilizes the range [<c>gb.first</c>, <c>gb.first + gb.second</c>) as a buffer where <c>gb</c> is the return value of this function.</p></td>
        <td><p>At the first call, acquires a buffer of a certain length and returns it. </p>
            <p>Otherwise, returns a pooled buffer.</p></td>
      </tr>

      <tr>
        <td>(3)</td>
        <td><c>t.release_buffer(b)</c></td>
        <td>(Not used)</td>
        <td><p>Called when the parser unhold the buffer acquired by the latest call of (2).</p>
            <p><c>b</c> is identical to <c>gb.first</c> where <c>gb</c> is return value of the latest call of (2).</p>
            <p>The parser shall not call this without making a previous call of (2).</p>
            <p>The parser shall call this function just after the parsing process exits via an exception or an abortion when it holds the buffer acquired by a call of (2).</p>
            <p>This function shall not throw any exceptions.</p></td>
         <td>Stores <c>b</c> into a pool.</td>
      </tr>

      <tr>
        <td>(4)</td>
        <td><c>t.start_buffer(bb, be)</c></td>
        <td>(Not used)</td>
        <td><p>Called when the parser starts using its buffer.
               Calling of this shall occur after a call of (2) and before its corresponding call of (3).</p>
            <p><c>bb</c> is a pointer to const-qualified <c>*gb.first</c> and <c>be</c> is of const-qualified <c>gb.first + gb.second</c> where <c>gb</c> is the return value of the latest call of (2).</p></td>
        <td>Does nothing.</td>
      </tr>

      <tr>
        <td>(5)</td>
        <td><c>t.end_buffer(bm)</c></td>
        <td>(Not used) </td>
        <td><p>Called when the parser finishes using its buffer.
               Calling of this shall occur after a call of (2) and before its corresponding call of (3).</p>
            <p><c>bm</c> is the past-the-end pointer of the range in the buffer actually used and resides in [<c>bb</c>, <c>be</c>] where <c>bb</c> and <c>be</c> are the arguments of the latest call of (4).</p></td>
        <td>Does nothing.</td>
      </tr>

      <tr>
        <td>(6)</td>
        <td><c>t.empty_physical_line()</c></td>
        <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
        <td><p>Called when the parser finds an empty line outside any record.
               Calling of this shall occur after a call of (4) and before its corresponding call of (5).</p>
            <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
        <td>Does nothing.</td>
      </tr>

      <tr>
        <td>(7)</td>
        <td><c>t.start_record(rb)</c></td>
        <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
        <td><p>Called when the parser begin to process a record.
               Calling of this shall occur after a call of (4) and before its corresponding call of (5).</p>
            <p><c>rb</c> is a pointer to the const-qualified first character of the record. If the first field of the records is quoted, <c>*rb</c> shall be a double quote.</p>
            <p><c>rb</c> resides in [<c>bb</c>, <c>gb.first + gb.second</c>) where <c>bb</c> is the argument of the latest call of (4) and gb is the return value of the latest call of (2).</p>
            <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
        <td/>
      </tr>

      <tr>
        <td>(8)</td>
        <td><c>t.end_record(re)</c></td>
        <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
        <td><p>Called when the parser finishes processing a record.
               Calling of this shall occur after a call of (4) and before its corresponding call of (5).</p>
            <p><c>re</c> is the past-the-end pointer of the const-qualified characters that forms the record. If the last field of the record is quoted, <c>*(re - 1)</c> shall be a double quote.</p>
            <p><c>re</c> resides in [<c>vb</c>, <c>be</c>] where vb is an argument of the latest call of (4) (first argument), (7) (first argument), (9) (second argument) or (10) (second argument), and
               <c>be</c> is the second argument of the latest call of (4).</p>
            <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
        <td/>
      </tr>

      <tr>
        <td>(9)</td>
        <td><c>t.update(f, l)</c></td>
        <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
        <td><p>Called when the parser finds a non-final chunk of a field value.
               Calling of this shall occur after a call of (4) and before its corresponding call of (5), and after a call of (7) and before its corresponding call of (8).</p>
            <p><c>f</c> is a pointer whose pointee is const-qualified and resides in [<c>vb</c>, <c>be</c>], and <c>l</c> is a pointer whose pointee is const-qualified and resides [<c>f</c>, <c>be</c>], where <c>vb</c> is an argument of the latest call of
               (4) (first argument), (7) (first argument), this (second argument) or (10) (second argument), and <c>be</c> is the second argument of the latest call of (4).</p>
            <p>After the call, the parser shall not dereference the range [<c>f</c>, <c>l</c>]; that is, if the text handler can reach the range as non-const, it may modify the elements in the range.</p>
            <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
         <td/>
      </tr>

      <tr>
        <td>(10)</td>
        <td><c>t.finalize(f, l)</c></td>
        <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
        <td><p>Called when the parser found a final chunk of a field value.
               Calling of this shall occur after a call of (4) and before its corresponding call of (5), and after a call of (7) and before its corresponding call of (8).</p>
            <p><c>f</c> is a pointer whose pointee is const-qualified and resides in [<c>vb</c>, <c>be</c>], and <c>l</c> is a pointer whose pointee is const-qualified  and resides in [<c>f</c>, <c>be</c>], where <c>vb</c> is an argument of the latest call of
               (4) (first argument), (7) (first argument), (9) (second argument) or this (second argument), and <c>be</c> is the second argument of the latest call of (4).</p>
            <p>After the call, the parser shall not dereference the range [<c>f</c>, <c>l</c>]; that is, if the text handler can reach the range as non-const, it may modify the element in the range.</p>
            <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
        <td/>
      </tr>
    </table>
  </section>
</section>

<section id="utility">
  <name>General utilities</name>

  <section id="diagnostics">
    <name>Diagnostic facilities</name>

    <section id="diagnostics.general">
      <name>General</name>
      <p>This subclause describes an exception class <c>text_error</c> (<xref id="text_error"/>), which defines the base class for the types of objects thrown while the parsers are comsuming the texts, and some facilities to access information that <c>text_error</c> objects hold.</p>
    </section>

    <section id="header_text_error_hpp">
      <name>Header <c>"text_error.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;cstddef>
#include &lt;exception>
#include &lt;ostream>
#include &lt;string>

namespace commata {
  class text_error;   <c>// <n>forward declation</n></c>

  <c>// <n><xref id="text_error_info"/>, class text_error_info:</n></c>
  class text_error_info;

  <c>// <n><xref id="text_error"/>, class text_error:</n></c>
  class text_error;

  <c>// <n><xref id="text_error_info.char_repr"/>, chracter representations of text_error_info:</n></c>
  template &lt;class Tr>
    std::basic_ostream&lt;char, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;char, Tr>&amp; os,
                                             const text_error_info&amp; i);
  template &lt;class Tr>
    std::basic_ostream&lt;wchar_t, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;wchar_t, Tr>&amp; os,
                                                const text_error_info&amp; i);
  std::string to_string(const text_error_info&amp; i);
  std::wstring to_wstring(const text_error_info&amp; i);
}
      </codeblock>
    </section>

    <section id="text_error">
      <name>Class <c>text_error</c></name>

      <codeblock>
namespace commata {
  class text_error : public std::exception {
  public:
    static constexpr std::size_t npos = -1;

    <c>// <n><xref id="text_error.cons"/>, constructors and assignment operators:</n></c>
    template &lt;class T> explicit text_error(T&amp;&amp; what_arg);
    text_error(const text_error&amp; other) noexcept;
    text_error(text_error&amp;&amp; other) noexcept;
    text_error&amp; operator=(const text_error&amp; other) noexcept;
    text_error&amp; operator=(text_error&amp;&amp; other) noexcept;

    const char* what() const noexcept override;

    <c>// <n><xref id="text_error.physical_position"/>, physical postion information:</n></c>
    text_error&amp; set_physical_position(std::size_t row = npos, std::size_t col = npos);
    const std::pair&lt;std::size_t, std::size_t>* get_physical_position() const noexcept;

    text_error_info info(std::size_t base = 1) const noexcept {
      return text_error_info(*this, base);
    }
  };
}
      </codeblock>

      <p>The class <c>text_error</c> defines the base class for the types of the objects thrown by Commata library.</p>
      <p>An object of <c>text_error</c> can optionally have a physical position information (<xref id="definitions.others"/>), which consists of the line number and the column number of the point in the input text that has made the exception thrown.
         <c>npos</c> is a special value for the line number and the column number which indicates &#x201c;no information.&#x201d;</p>

      <section id="text_error.cons">
        <name><c>text_error</c> constructors and assignment operators</name>

        <code-item>
          <code>
template &lt;class T> explicit text_error(T&amp;&amp; what_arg);
          </code>
          <effects>Constructs an object of <c>text_error</c>.</effects>
          <postcondition><c>(std::strcmp(w.c_str(), what()) == 0) &amp;&amp; !get_physical_position()</c> shall not be <c>false</c> where <c>w</c> is an object that would be constructed by <c>std::string(std::forward&lt;T>(what_arg))</c>.</postcondition>
          <remark>This constructor shall not participate in overload resolution unless <c>std::is_constructible&lt;std::string, T&amp;&amp;>::value</c> is not <c>false</c>.</remark>
        </code-item>

        <code-item>
          <code>
text_error(const text_error&amp; other) noexcept;
          </code>
          <effects>Constructs an object of <c>text_error</c> from another object of <c>text_error</c>.</effects>
          <postcondition><c>(std::strcmp(other.what(), what() == 0) &amp;&amp; (other.get_physical_position() ? (*other.get_physical_position() == *get_physical_position()) : !get_physical_position())</c> is not <c>false</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
text_error(text_error&amp;&amp; other) noexcept;
          </code>
          <effects>Constructs an object of <c>text_error</c> from another object of <c>text_error</c> placing <c>other</c> in an unspecified state.</effects>
          <postcondition><c>(std::strcmp(c.what(), what()) == 0) &amp;&amp; (c.get_physical_position() ? (*c.get_physical_position() == *get_physical_position()) : !get_physical_position())</c> shall be not <c>false</c> where <c>c</c> is an object that would be copy-constructed from <c>other</c> before the call.</postcondition>
        </code-item>

        <code-item>
          <code>
text_error&amp; operator=(const text_error&amp; other) noexcept;
          </code>
          <effects>Assigns an object of <c>text_error</c> from another object of <c>text_error</c>.</effects>
          <postcondition><c>(std::strcmp(ow, what()) == 0) &amp;&amp; (other.get_physical_position() ? (*other.get_physical_position() == *get_physical_position()) : !get_physical_position())</c> is not <c>false</c>.</postcondition>
          <returns><c>*this</c>.</returns>
        </code-item>

        <code-item>
          <code>
text_error&amp; operator=(text_error&amp;&amp; other) noexcept;
          </code>
          <effects>Assigns an object of <c>text_error</c> from another object of <c>text_error</c> placing <c>other</c> in an unspecified state.</effects>
          <postcondition><c>(std::strcmp(ow, what()) == 0) &amp;&amp; (c.get_physical_position() ? (*c.get_physical_position() == *get_physical_position()) : !get_physical_position() == nullptr)</c> shall not <c>false</c> where <c>c</c> is an object that would be copy-constructed from <c>other</c> before the call.</postcondition>
          <returns><c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="text_error.physical_position">
        <name><c>text_error</c> physical position information</name>

        <code-item>
          <code>
text_error&amp; set_physical_position(std::size_t line = npos, std::size_t col = npos);
          </code>
          <effects>If both of <c>line</c> and <c>col</c> are equal to <c>npos</c>, removes the position information if it exists. Otherwise, sets the position information whose line number and column number are <c>line</c> and <c>col</c> respectively.</effects>
          <postcondition>If both of <c>line</c> and <c>col</c> are equal to <c>npos</c>, <c>get_physical_position() == nullptr</c> shall not be <c>false</c>. Otherwise, <c>*get_physical_position() == std::make_pair(line, col)</c> shall not be <c>false</c>.</postcondition>
          <returns><c>*this</c>.</returns>
          <remark>The row number and column number shall be zero-based.</remark>
        </code-item>

        <code-item>
          <code>
const std::pair&lt;std::size_t, std::size_t>* get_physical_position() const noexcept;
          </code>
          <returns>If <c>*this</c> holds a physical position information, a pointer to an pair of its line number and column number. Otherwise, <c>nullptr</c>.</returns>
          <remark>The row number and column number shall be zero-based.</remark>
        </code-item>
      </section>
    </section>

    <section id="text_error_info">
      <name>Class <c>text_error_info</c></name>

      <codeblock>
namespace commata {
  class text_error_info {
  public:
    text_error_info(const text_error&amp; ex, std::size_t base) noexcept;
    text_error_info(const text_error_info&amp; other) noexcept;
    text_error_info&amp; operator=(const text_error_info&amp; other) noexcept;

    const text_error&amp; error() const noexcept;
    std::size_t get_base() const noexcept;

  private:
    const text_error* e;  <c>// <n>exposition only</n></c>
    std::size_t b;        <c>// <n>exposition only</n></c>
  };
}
      </codeblock>

      <p>An object of the class <c>text_error_info</c> is a mere reference-wrapper of an object of the class <c>text_error</c>.
         This class offers a simple character representation of objects of the class <c>text_error</c>.</p>

      <code-item>
        <code>
text_error_info(const text_error&amp; ex, std::size_t base) noexcept;
        </code>
        <effects>Initializes <c>e</c> with <c>&amp;ex</c> and <c>b</c> with <c>base</c>.</effects>
      </code-item>

      <code-item>
        <code>
text_error_info(const text_error_info&amp; other) noexcept;
        </code>
        <effects>Initializes <c>e</c> with <c>other.e</c> and <c>b</c> with <c>other.b</c>.</effects>
      </code-item>

      <code-item>
        <code>
text_error_info&amp; operator=(const text_error_info&amp; other) noexcept;
        </code>
        <effects>Assigns <c>e</c> from <c>other.e</c> and <c>b</c> from <c>other.b</c>.</effects>
      </code-item>

      <code-item>
        <code>
const text_error&amp; error() const noexcept;
        </code>
        <returns><c>*e</c>.</returns>
      </code-item>

      <code-item>
        <code>
std::size_t get_base() const noexcept;
        </code>
        <returns><c>b</c>.</returns>
      </code-item>

      <section id="text_error_info.char_repr">
        <name><c>text_error_info</c> character representations</name>

        <code-item>
          <code>
template &lt;class Tr>
  std::basic_ostream&lt;char, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;char, Tr>&amp; os,
                                           const text_error_info&amp; i);
template &lt;class Tr>
  std::basic_ostream&lt;wchar_t, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;wchar_t, Tr>&amp; os,
                                              const text_error_info&amp; i);
          </code>
          <effects>Behaves as a formatted output function of <c>os</c>.
                   Forms a character sequence <c>seq</c> of an unspecified concise character representation of <c>i.error()</c> from <c>i.error().what()</c> and <c>i.error().get_physical_position()</c>, in which the line number and the column number are <c>b</c>-based.
                 Determines padding for <c>seq</c>. Then inserts <c>seq</c> as if by calling <c>os.rdbuf()->sputn(seq, n)</c> where <c>n</c> is the larger of <c>os.width()</c> and the size of <c>seq</c>. Then calls <c>os.width(0)</c>.</effects>
          <returns><c>os</c>.</returns>
          <remark>The second function template shall try to convert <c>i.error().what()</c> from a null-terminated multibyte string into a wide character string.</remark>
        </code-item>

        <code-item>
          <code>
std::string to_string(const text_error_info&amp; i);
std::wstring to_wstring(const text_error_info&amp; i);
          </code>
          <returns>A character representation of <c>i.error()</c> that is the same as the <c>operator&lt;&lt;</c> inserts into a stream.</returns>
        </code-item>
      </section>
    </section>

    <section id="header_parse_error_hpp">
      <name>Header <c>"parse_error.hpp"</c> synopsis</name>
      <codeblock>
#include "text_error.hpp"

namespace commata {
  class parse_error;
}
      </codeblock>
    </section>

    <section id="parse_error">
      <name>Class <c>parse_error</c></name>

      <codeblock>
namespace commata {
  class parse_error : public text_error {
  public:
    template &lt;class T>
      explicit parse_error(T&amp;&amp; what_arg);
  };
}
      </codeblock>

      <p>An exception of type <c>parse_error</c> is thrown by the parser, for example by <c>parse_csv</c> (<xref id="parse_csv"/>), when the text does not have an appropriate format.</p>

      <code-item>
        <code>
template &lt;class T>
  explicit parse_error(T&amp;&amp; what_arg);
        </code>
        <effects>Constructs an object of parse_error.</effects>
        <postcondition><c>(std::strcmp(w.c_str(), what()) == 0) &amp;&amp; (get_physical_position() == nullptr)</c> shall not be <c>false</c> where <c>w</c> is an object that would be constructed by <c>std::string(std::forward&lt;T>(what_arg>))</c>.</postcondition>
        <remark>This constructor shall not participate in overload resolution unless <c>std::is_constructible&lt;std::string, T&amp;&amp;>::value</c> is not <c>false</c>.</remark>
      </code-item>
    </section>
  </section>

  <section id="handler_wrappers">
    <name>Wrappers of text handlers</name>

    <section id="header_empty_physical_line_aware_handler">
      <name>Header <c>"empty_physical_line_aware_handler.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;functional>

namespace commata {
  <c>// <n><xref id="empty_physical_line_aware_handler"/>, creation of text handler wrappers aware of empty physical lines:</n></c>
  template &lt;class Handler>
    <nc>unspecified</nc>
      make_empty_physical_line_aware(Handler&amp;&amp; handler) noexcept(<nc>see below</nc>);
  template &lt;class Handler>
    <nc>unspecified</nc>
      make_empty_physical_line_aware(const std::reference_wrapper&lt;Handler>&amp; handler) noexcept;
}
      </codeblock>
    </section>

    <section id="empty_physical_line_aware_handler">
      <name>Creation of text handler wrappers aware of empty physical lines</name>

      <code-item>
        <code>
template &lt;class Handler>
  <nc>unspecified</nc>
    make_empty_physical_line_aware(Handler&amp;&amp; handler) noexcept(<nc>see below</nc>);
template &lt;class Handler>
  <nc>unspecified</nc>
    make_empty_physical_line_aware(const std::reference_wrapper&lt;Handler>&amp; handler) noexcept;
        </code>
        <requires><c>Handler</c> shall meet the <c>TextHandler</c> requirements, except that in the second overload it need not meet either the <c>MoveConstructible</c> requirements or the <c>Destructible</c> requirements.</requires>
        <returns>An object of an unspecified type whose type meets the <c>TextHandler</c> requirements and that holds an object <c>h</c> where <c>h</c> is a copy of <c>handler</c> (first overload) or a reference to <c>handler.get()</c> (second overload).
                 It forwards calls of its member functions to <c>h</c>; except that when its <c>empty_physical_line</c> member function is called with an argument <c>where</c>,
                 it first calls <c>h.start_record(where)</c>, and if its contexually converted return value to <c>bool</c> is not <c>false</c>, next calls <c>h.end_record(where)</c>.
                 Its return type and the return value are as follows:
                 <ul>
                   <li>if both of the return types of <c>h.start_record(where)</c> and <c>h.end_record(where)</c> are <c>void</c>, the return type shall be <c>void</c>,</li>
                   <li>otherwise, the return type shall be <c>bool</c> and the return type shall be <c>false</c> unless both of the the return values contextually converted to <c>bool</c> of <c>h.start_record(where)</c> and <c>h.end_record(where)</c> are not <c>false</c>.</li>
                 </ul></returns>
        <remark>The first overload shall not participate in overload resolution unless <c>std::decay_t&lt;Handler></c> is not the same type as <c>std::reference_wrapper&lt;T></c> for any <c>T</c>.
                The expression inside <c>noexcept</c> of the first overload is equivalent to <c>std::is_nothrow_move_constructible&lt;std::decay_t&lt;Handler>>::value</c>.</remark>
      </code-item>
    </section>
  </section>
</section>

<section id="parser">
  <name>The parser</name>

  <section id="parser.general">
    <name>General</name>
    <p>This clause describes components several functions to utilize the parser (<xref id="concepts"/>) of the CSV text format (<xref id="definitions.csv_text"/>) and some classes and functions to report parse errors and to make some wrappers of the text handlers (<xref id="concepts"/>).</p>
  </section>

  <section id="header_parse_csv_hpp">
    <name>Header <c>"parse_csv.hpp"</c> synopsis</name>
    <codeblock>
#include &lt;cstddef>
#include &lt;functional>
#include &lt;istream>
#include &lt;memory>
#include &lt;streambuf>

#include "parse_error.hpp"

namespace commata {
  <c>// <n><xref id="parse_csv"/>, functions that utilize the CSV parser:</n></c>
  template &lt;class Tr, class Handler>
    bool parse_csv(std::basic_streambuf&lt;typename Handler::char_type, Tr>* in, Handler handler);
  template &lt;class Tr, class Handler>
    bool parse_csv(std::basic_istream&lt;typename Handler::char_type, Tr>&amp; in, Handler handler);
  template &lt;class Tr, class Handler,
            class Allocator = std::allocator&lt;typename Handler::char_type>>
    bool parse_csv(std::basic_streambuf&lt;typename Handler::char_type, Tr>* in, Handler handler,
                   std::size_t buffer_size = 0, const Allocator&amp; alloc = Allocator());
  template &lt;class Tr, class Handler,
            class Allocator = std::allocator&lt;typename Handler::char_type>>
    bool parse_csv(std::basic_istream&lt;typename Handler::char_type, Tr>&amp; in, Handler handler,
                   std::size_t buffer_size = 0, const Allocator&amp; alloc = Allocator());
  template &lt;class Input, class Handler, class... Args>
    bool parse_csv(Input&amp;&amp; in, const std::reference_wrapper&lt;Handler>&amp; handler, Args&amp;&amp;... args);
}
    </codeblock>
  </section>

  <section id="parse_csv">
    <name>Utilizing the CSV parser</name>

    <code-item>
      <code>
template &lt;class Tr, class Handler>
  bool parse_csv(std::basic_streambuf&lt;typename Handler::char_type, Tr>* in, Handler handler);
template &lt;class Tr, class Handler>
  bool parse_csv(std::basic_istream&lt;typename Handler::char_type, Tr>&amp; in, Handler handler);
      </code>
      <requires><c>Handler</c> shall meet the <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>).
                In the first overload <c>in</c> shall be a valid pointer.</requires>
      <effects>Creates a parser for the CSV text format (<xref id="definitions.csv_text"/>) and make it parse the whole character streams of <c>in</c>.
               The parsing events are sent to a copy of <c>handler</c>.
               If any call on <c>handler</c> throws an object of the type <c>text_error</c>, the parser set the position information into it with the <c>set_physical_position</c> member function and rethrow it.
               The parser shall be destroyed when this function exits.</effects>
      <returns><c>true</c> if the parser finished the parsing process without abortion, <c>false</c> otherwise.</returns>
      <throws><c>parse_error</c> (<xref id="parse_error"/>), <c>std::bad_alloc</c> or any exception thrown by <c>handler</c> and its copy.</throws>
      <remark>These function templates shall not participate in overload resolution unless <c>Handler</c> has both of <c>get_buffer</c> and <c>release_buffer</c> member functions that have signatures and return types compatible with <c>TextHandler</c> requirements.</remark>
    </code-item>

    <code-item>
      <code>
template &lt;class Tr, class Handler,
          class Allocator = std::allocator&lt;typename Handler::char_type>>
  bool parse_csv(std::basic_streambuf&lt;typename Handler::char_type, Tr>* in, Handler handler,
                 std::size_t buffer_size = 0, const Allocator&amp; alloc = Allocator());
template &lt;class Tr, class Handler,
          class Allocator = std::allocator&lt;typename Handler::char_type>>
  bool parse_csv(std::basic_istream&lt;typename Handler::char_type, Tr>&amp; in, Handler handler,
                 std::size_t buffer_size = 0, const Allocator&amp; alloc = Allocator());
      </code>
      <requires><c>Handler</c> shall meet the <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>).
                In the first overload <c>in</c> shall be a valid pointer.</requires>
      <effects>Creates a parser for the CSV text format (<xref id="definitions.csv_text"/>) and make it parse the whole character streams of <c>in</c>.
               The parsing events are sent to a copy of <c>handler</c>.
               If any call on <c>handler</c> throws an object of the type <c>text_error</c>, the parser set the position information into it with the <c>set_physical_position</c> member function and rethrow it.
               The parser shall allocate and deallocate character buffers with (possibly a copy of) <c>alloc</c>.
               The length of the buffer is unspecified, but <c>buffer_size</c> serves as a hint. <c>buffer_size</c> can be equal to zero, which means &#x201c;no hint.&#x201d;
               The parser shall be destroyed when this function exits.</effects>
      <returns><c>true</c> if the parser finished the parsing process without abortion, <c>false</c> otherwise.</returns>
      <throws><c>parse_error</c> (<xref id="parse_error"/>) or any exception thrown by <c>handler</c>, <c>alloc</c> and their copies.</throws>
      <remark>These function templates shall not participate in overload resolution if <c>Handler</c> has either of <c>get_buffer</c> or <c>release_buffer</c> member function that has a signature and a return type compatible with <c>TextHandler</c> requirements.</remark>
    </code-item>

    <code-item>
      <code>
template &lt;class Input, class Handler, class... Args>
  bool parse_csv(Input&amp;&amp; in, const std::reference_wrapper&lt;Handler>&amp; handler, Args&amp;&amp;... args);
      </code>
      <requires><c>Handler</c> shall meet the <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>), except that it need not meet either the <c>MoveConstructible</c> requirement or the <c>Destructible</c> requirements.</requires>
      <effects>Creates an object <c>h</c> that wraps <c>handler.get()</c> and forwards calls to <c>handler.get()</c>.
               The type of <c>h</c> is an unspecified type that meets the <c>TextHandler</c> requirements.
               Then forwards the call to the other <c>parse_csv</c> function templates with the second argument being <c>h</c>.</effects>
      <returns>The return value of the forwarded call above.</returns>
      <throws>Any exception thrown by the forwarded call above.</throws>
    </code-item>
  </section>
</section>

<section id="built-in_handlers">
  <name>Default text handlers</name>

  <section id="extractor">
    <name>Extraction of records into another stream</name>

    <section id="extractor.general">
      <name>General</name>

      <p>Commata offers two class templates <c>record_extractor</c> (<xref id="record_extractor"/>) and <c>record_extractor_with_indexed_key</c> (<xref id="record_extractor_with_indexed_key"/>), whose instances meet <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>), as simple facilities to reduce text records.</p>
      <p>An object of an instance of <c>record_extractor</c> or <c>record_extractor_with_indexed_key</c> receives parsing events from a parser and forwards some qualified records into another stream.
         Whether a record is qualified to be forwarded or not is decided by the value of its field at the <n>target field index</n>.
         The target field index can be given explicitly by the program (with <c>record_extractor_with_indexed_key</c>), or can be decided in reference to the first one record (with <c>record_extractor</c>).</p>
      <p>A record that can not be decided whether it is qualified to be forwarded or not due to non-existence of the field at the target field index shall cause an exception.</p>
      <p>An object of an instance of <c>record_extractor</c> or <c>record_extractor_with_indexed_key</c> can not be reused; that is, it can receive the parsing events that the parser emits only once.</p>
      <p>In this subclause, the first one record of a CSV text is called its <n>header</n> record.</p>
    </section>

    <section id="record_extractor_hpp">
      <name>Header <c>"record_extractor.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;memory>
#include &lt;ostream>
#include &lt;streambuf>
#include &lt;string>

#include "text_error.hpp"

namespace commata {
  <c>// <n><xref id="record_extraction_error"/>, record_extraction_error:</n></c>
  class record_extraction_error;

  <c>// <n><xref id="record_extractor"/>, record_extractor:</n></c>
  template &lt;class FieldNamePred, class FieldValuePred, class Ch, class Tr, class Allocator>
    class record_extractor;

  <c>// <n><xref id="record_extractor_with_indexed_key"/>, record_extractor_with_indexed_key:</n></c>
  template &lt;class FieldValuePred, class Ch, class Tr, class Allocator>
    class record_extractor_with_indexed_key;

  <c>// <n><xref id="record_extractor.creation"/>, creation functions:</n></c>
  template &lt;class FieldNamePred, class FieldValuePred,
            class Ch, class Tr, class Allocator, class... Appendices>
    <nc>unspecified</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                      std::basic_streambuf&lt;Ch, Tr>* out,
                                      FieldNamePred&amp;&amp; field_name_pred,
                                      FieldValuePred&amp;&amp; field_value_pred,
                                      Appendices&amp;&amp;... appendices);
  template &lt;class Ch, class Tr, class Allocator, class... Appendices>
    <nc>unspecified</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                      std::basic_ostream&lt;Ch, Tr>&amp; out, Appendices&amp;&amp;... appendices);
  template &lt;class Ch, class Tr, class... Appendices>
    <nc>unspecified</nc> make_record_extractor(std::basic_streambuf&lt;Ch, Tr>* out,
                                      Appendices&amp;&amp;... appendices);
  template &lt;class Ch, class Tr, class... Appendices>
    <nc>unspecified</nc> make_record_extractor(std::basic_ostream&lt;Ch, Tr>&amp; out,
                                      Appendices&amp;... appendices);
}
      </codeblock>
    </section>

    <section id="record_extraction_error">
      <name>Class <c>record_extraction_error</c></name>

      <codeblock>
namespace commata {
  class record_extraction_error : public text_error {
  public:
    template &lt;class T>
      explicit record_extraction_error(T&amp;&amp; what_arg);
  };
}
      </codeblock>

      <p>The class <c>record_extraction_error</c> defines a type of the objects thrown by <c>record_extractor</c> objects and <c>record_extractor_with_indexed_key</c> objects during the parsing.</p>

      <code-item>
        <code>
template &lt;class T>
  explicit record_extraction_error(T&amp;&amp; what_arg);
        </code>
        <effects>Constructs an object of <c>record_extraction_error</c>.</effects>
        <postcondition><c>(std::strcmp(w.c_str(), what()) == 0) &amp;&amp; (get_physical_position() == nullptr)</c> shall not be <c>false</c> where <c>w</c> is an object that would be constructed by <c>std::string(std::forward&lt;T>(what_arg>))</c>.</postcondition>
        <remark>This constructor shall not participate in overload resolution unless <c>std::is_constructible&lt;std::string, T&amp;&amp;>::value</c> is not <c>false</c>.</remark>
      </code-item>
    </section>

    <section id="record_extractor">
      <name>Class template <c>record_extractor</c></name>

      <codeblock>
namespace commata {
  template &lt;class FieldNamePred, class FieldValuePred, class Ch,
            class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class record_extractor {
  public:
    static constexpr std::size_t npos = -1;

    using char_type = Ch;
    using traits_type = Tr;
    using allocator_type = Allocator;

    <c>// <n><xref id="record_extractor.cons"/>, construct/copy/destroy:</n></c>
    record_extractor(std::basic_streambuf&lt;Ch, Tr>* out,
                     FieldNamePred field_name_pred, FieldValuePred field_value_pred,
                     bool includes_header = true, std::size_t max_record_num = npos);
    record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                     std::basic_streambuf&lt;Ch, Tr>* out,
                     FieldNamePred field_name_pred, FieldValuePred field_value_pred,
                     bool includes_header = true, std::size_t max_record_num = npos);
    record_extractor(record_extractor&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~record_extractor();

    <c>// <n><xref id="record_extractor.accessors"/>, accessors:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n>six member functions below are declared and defined to meet the TextHandler</n>
    // <n>requirements (<xref id="text_handler.requirements"/>):</n></c>
    void start_buffer(const Ch* buffer_begin, const Ch* buffer_end);
    void end_buffer(const Ch* buffer_end);
    void start_record(const Ch* record_begin);
    bool end_record(const Ch* record_end);
    void update(const Ch* first, const Ch* last);
    void finalize(const Ch* first, const Ch* last);
  };
}
      </codeblock>

      <p>An instance of <c>record_extractor</c> is a type that meets <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>) for the template parameter <c>Ch</c>.</p>
      <p>An object of it first scans the header record to decide the target field index,
         and then scan the all non-header records to decide whether the record is forwarded to the stream in terms of their values of the field at the target field index.</p>
      <p>When the target field index is left undecided after the scanning of the header record finished, an exception shall be thrown.</p>
      <p><c>FieldNamePred</c> and <c>FieldValuePred</c> shall be binary predicate types for two <c>const char*</c> parameters.</p>

      <section id="record_extractor.cons">
        <name><c>record_extractor</c> constructors and assignment operators</name>

        <code-item>
          <code>
record_extractor(std::basic_streambuf&lt;Ch, Tr>* out,
                 FieldNamePred field_name_pred, FieldValuePred field_value_pred,
                 bool includes_header = true, std::size_t max_record_num = npos);
record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                 std::basic_streambuf&lt;Ch, Tr>* out,
                 FieldNamePred field_name_pred, FieldValuePred field_value_pred,
                 bool includes_header = true, std::size_t max_record_num = npos);
          </code>
          <requires><c>out</c> shall be a valid pointer.</requires>
          <effects>Constructs an object that holds the copies of the parameters and behaves as <xref id="table.record_extractor.cons"/> shows.
                   An object constructed by the first overload uses a default-constructed <c>Allocator</c> object to allocate memory.
                   One constructed by the second overload uses an <c>Allocator</c> object copy-constructed from <c>alloc</c>.</effects>

          <table id="table.record_extractor.cons">
            <caption>Principal parameters of the constructors of <c>record_extractor</c> and the behavior of the constructed object</caption>
            <col width="2"/><col width="12"/>
            <tr>
              <th>Parameter</th>
              <th>Remark</th>
            </tr>
            <tr>
              <td><c>out</c></td>
              <td>Points a stream buffer object that receives the extracted records.</td>
            </tr>
            <tr>
              <td><c>field_name_pred</c></td>
              <td>Copied into the constructed object, which is called for every field in the header record.
                  The call parameters are <c>f</c> and <c>l</c> where the field value is the range [<c>f</c>, <c>l</c>).
                  If returns a non-<c>false</c> value, then the field index becomes the target field index.</td>
            </tr>
            <tr>
              <td><c>field_value_pred</c></td>
              <td>Copied into the constructed object, which is called for every field at the target field index of non-header records.
                  The call parameters are <c>f</c> and <c>l</c> where the field value is the range [<c>f</c>, <c>l</c>).
                  If returns a non-<c>false</c> value, then the record is qualified to be forwarded to <c>out</c>.</td>
            </tr>
            <tr>
              <td><c>includes_header</c></td>
              <td>If and only if <c>true</c>, the header record is forwarded to <c>out</c>.</td>
            </tr>
            <tr>
              <td><c>max_record_num</c></td>
              <td>At most <c>max_record_num</c> non-header records are forwarded to <c>out</c>.
                  After <c>max_record_num</c> are forwarded, the parsing will be aborted.</td>
            </tr>
          </table>
        </code-item>

        <code-item>
          <code>
record_extractor(record_extractor&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Move-constructs from an rvalue <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;FieldNamePred>::value &amp;&amp; std::is_nothrow_move_constructible&lt;FieldValuePred>::value</c>.
                  When this constructor exits via an exception, <c>other</c> will be placed in an unspecified state.</remark>
        </code-item>
      </section>

      <section id="record_extractor.accessors">
        <name><c>record_extractor</c> accessors</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object used to allocate memory by <c>*this</c>.</returns>
        </code-item>
      </section>
    </section>

    <section id="record_extractor_with_indexed_key">
      <name>Class template <c>record_extractor_with_indexed_key</c></name>

      <codeblock>
namespace commata {
  template &lt;class FieldValuePred, class Ch,
            class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class record_extractor_with_indexed_key {
  public:
    static constexpr std::size_t npos = -1;

    using char_type = Ch;
    using traits_type = Tr;
    using allocator_type = Allocator;

    <c>// <n><xref id="record_extractor_with_indexed_key.cons"/>, construct/copy/destroy:</n></c>
    record_extractor_with_indexed_key(std::basic_streambuf&lt;Ch, Tr>* out,
                                      std::size_t target_field_index,
                                      FieldValuePred field_value_pred,
                                      bool includes_header = true,
                                      std::size_t max_record_num = npos);
    record_extractor_with_indexed_key(std::allocator_arg_t, const Allocator&amp; alloc,
                                      std::basic_streambuf&lt;Ch, Tr>* out,
                                      std::size_t target_field_index,
                                      FieldValuePred field_value_pred,
                                      bool includes_header = true,
                                      std::size_t max_record_num = npos);
    record_extractor_with_indexed_key(record_extractor_with_indexed_key&amp;&amp; other)
                                      noexcept(<nc>see below</nc>);
   ~record_extractor_with_indexed_key();

    <c>// <n><xref id="record_extractor_with_indexed_key.accessors"/>, accessors:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n>six member functions below are declared and defined to meet the TextHandler</n>
    // <n>requirements (<xref id="text_handler.requirements"/>):</n></c>
    void start_buffer(const Ch* buffer_begin, const Ch* buffer_end);
    void end_buffer(const Ch* buffer_end);
    void start_record(const Ch* record_begin);
    bool end_record(const Ch* record_end);
    void update(const Ch* first, const Ch* last);
    void finalize(const Ch* first, const Ch* last);
  };
}
      </codeblock>

      <p>An instance of <c>record_extractor_with_indexed_key</c> is a type that meets <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>) for the template parameter <c>Ch</c>.</p>
      <p>It scans the all non-header records to decide whether the record is forwarded to the stream in terms of their values of the field at the target field index instructed with a parameter of its constructor explicitly.</p>
      <p><c>FieldValuePred</c> shall be a binary predicate type for two <c>const char*</c> parameters.</p>

      <section id="record_extractor_with_indexed_key.cons">
        <name><c>record_extractor_with_indexed_key</c> constructors and assignment operators</name>

        <code-item>
          <code>
record_extractor_with_indexed_key(std::basic_streambuf&lt;Ch, Tr>* out,
                                  std::size_t target_field_index,
                                  FieldValuePred field_value_pred,
                                  bool includes_header = true,
                                  std::size_t max_record_num = npos);
record_extractor_with_indexed_key(std::allocator_arg_t, const Allocator&amp; alloc,
                                  std::basic_streambuf&lt;Ch, Tr>* out,
                                  std::size_t target_field_index,
                                  FieldValuePred field_value_pred,
                                  bool includes_header = true,
                                  std::size_t max_record_num = npos);
          </code>
          <requires><c>out</c> shall be a valid pointer.</requires>
          <effects>Constructs an object that holds the copies of the parameters and behaves as <xref id="table.record_extractor_with_indexed_key.cons"/> shows.
                   An object constructed by the first overload uses a default-constructed <c>Allocator</c> object to allocate memory.
                   One constructed by the second overload uses an <c>Allocator</c> object copy-constructed from <c>alloc</c>.</effects>

          <table id="table.record_extractor_with_indexed_key.ctor">
            <caption>Principal parameters of the constructors of <c>record_extractor_with_indexed_key</c> and the behavior of the constructed object</caption>
            <col width="2"/><col width="12"/>
            <tr>
              <th>Parameter</th>
              <th>Remark</th>
            </tr>
            <tr>
              <td><c>out</c></td>
              <td>Points a stream buffer object that receives the extracted records.</td>
            </tr>
            <tr>
              <td><c>target_field_index</c></td>
              <td>Tells the zero-based target field index, which <c>field_value_pred</c> is applied.</td>
            </tr>
            <tr>
              <td><c>field_value_pred</c></td>
              <td>Called for every field at the target field index of non-header records.
                  The parameters are <c>f</c> and <c>l</c> where the field value is the range [<c>f</c>, <c>l</c>).
                  If returns a non-<c>false</c> value, then the record is qualified to be forwarded to <c>out</c>.</td>
            </tr>
            <tr>
              <td><c>includes_header</c></td>
              <td>If and only if <c>true</c>, the header record is forwarded to <c>out</c>.</td>
            </tr>
            <tr>
              <td><c>max_record_num</c></td>
              <td>At most <c>max_record_num</c> non-header records are forwarded to <c>out</c>.
                  After <c>max_record_num</c> records are forwarded, the parsing will be aborted.</td>
            </tr>
          </table>
        </code-item>
        <code-item>
          <code>
record_extractor_with_indexed_key(record_extractor_with_indexed_key&amp;&amp; other)
                                  noexcept(<nc>see below</nc>);
          </code>
          <effects>Move-constructs from an rvalue <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;FieldValuePred>::value</c>.</remark>
        </code-item>
      </section>

      <section id="record_extractor_with_indexed_key.accessors">
        <name><c>record_extractor_with_indexed_key</c> accessors</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object used to allocate memory by <c>*this</c>.</returns>
        </code-item>
      </section>
    </section>

    <section id="record_extractor.creation">
      <name><c>record_extractor</c> and <c>record_extractor_with_indexed_key</c> creation functions</name>

      <p>In this subclause, a function template <c>template &lt;class Ch, class Tr, class P, class Allocator> <nc>unspecified</nc> STRING_PRED(P&amp;&amp; p, const Allocator&amp; alloc)</c> is introduced for ease of explanation.
         Its return value is as following:</p>
      <ul>
        <li>if <c>P</c> is <c>std::basic_string&lt;Ch, Tr, A></c> for a certain <c>A</c>,
            a binary predicate object that holds an <c>std::basic_string&lt;Ch, Tr, A></c> object <c>s</c> initialized with <c>std::move(p)</c> and tells if a range [<c>f</c>, <c>l</c>) is equal to <c>s</c> in terms of <c>Tr::eq</c> where <c>f</c> and <c>l</c> are two <c>const Ch*</c> parameters of the predicate,</li>
        <li>otherwise, if <c>std::is_constructible&lt;std::basic_string&lt;Ch, Tr, Allocator>, P, Allocator>>::value</c> is not <c>false</c>,
            a binary predicate object that holds an <c>std::basic_string&lt;Ch, Tr, Allocator></c> object <c>s</c> initialized with <c>std::forward&lt;P>(p)</c> and <c>alloc</c> and tells if a range [<c>f</c>, <c>l</c>) is equal to <c>s</c> in terms of <c>Tr::eq</c> where <c>f</c> and <c>l</c> are two <c>const Ch*</c> parameters of the predicate,</li>
        <li>otherwise, if <c>P</c> is an lvalue reference type, an lvalue reference to <c>p</c>,</li>
        <li>otherwise, an rvalue reference to <c>p</c>.</li>
      </ul>

      <code-item>
        <code>
template &lt;class FieldNamePred, class FieldValuePred,
          class Ch, class Tr, class Allocator, class... Appendices>
  <nc>unspecified</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                    std::basic_streambuf&lt;Ch, Tr>* out,
                                    FieldNamePred&amp;&amp; field_name_pred,
                                    FieldValuePred&amp;&amp; field_value_pred,
                                    Appendices&amp;&amp;... appendices);
        </code>
        <effects>First makes a non-reference and cv-unqualified type variable <c>fvp</c> initialized with <c>STRING_PRED&lt;Ch, Tr>(std::forward&lt;FieldNamePred>(field_name_pred), alloc)</c>.
                 Then if the reference-removed type of <c>FieldNamePred</c> is an integral type, returns <c>record_extractor_with_indexed_key&lt;decltype(fvp), Ch, Tr, Allocator>(std::allocator_arg, alloc, out, field_name_pred, std::move(fvp), std::forward&lt;Appendices>(appendices)...)</c>.
                 Otherwise, makes one more non-reference and cv-unqualified type variable <c>fnp</c> initialized with <c>STRING_PRED&lt;Ch, Tr>(std::forward&lt;FieldNamePred>(field_name_pred), alloc)</c>,
                 then returns <c>record_extractor&lt;decltype(fnp), decltype(fvp), Ch, Tr, Allocator>(std::allocator_arg, alloc, out, std::move(fnp), std::move(fvp), std::forward&lt;Appendices>(appendices)...)</c>.</effects>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr, class Allocator, class... Appendices>
  <nc>unspecified</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                    std::basic_ostream&lt;Ch, Tr>&amp; out, Appendices&amp;&amp;... appendices);
        </code>
        <returns><c>make_record_extractor(std::allocator_arg, alloc, out.rdbuf(), std::forward&lt;Appendices>(appendices)...)</c>.</returns>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr, class... Appendices>
  <nc>unspecified</nc> make_record_extractor(std::basic_streambuf&lt;Ch, Tr>* out,
                                    Appendices&amp;&amp;... appendices);
template &lt;class Ch, class Tr, class... Appendices>
  <nc>unspecified</nc> make_record_extractor(std::basic_ostream&lt;Ch, Tr>&amp; out,
                                    Appendices&amp;... appendices);
        </code>
        <returns><c>make_record_extractor(std::allocator_arg, std::allocator&lt;Ch>(), out, std::forward&lt;Appendices>(appendices)...)</c>.</returns>
      </code-item>
    </section>
  </section>

  <section id="table">
    <name>Creation of a whole table image in memory</name>

    <section id="table.general">
      <name>General</name>

      <p>Commata offers class template <c>basic_stored_table</c> (<xref id="basic_stored_table"/>), which is an implementation of a in-memory text table (<xref id="definitions.text_table"/>).
         The text values of text fields contained by an object of an instance of it are represented by class template <c>basic_stored_value</c> (<xref id="basic_stored_value"/>), an object of an instance of which is actually a contiguous and null-terminated range of char type objects of the text table.</p>
      <p>A text table is built by an object of an instance of <c>stored_table_builder</c> (<xref id="stored_table_builder"/>), whose instances meet <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>).</p>
    </section>

    <section id="stored_table_hpp">
      <name>Header <c>"stored_table.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;deque>
#include &lt;functional>
#include &lt;iterator>
#include &lt;memory>
#include &lt;ostream>
#include &lt;string>
#include &lt;type_traits>
#include &lt;vector>

namespace commata {
  <c>// <n><xref id="basic_stored_value"/>, basic_stored_value:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;std::remove_const_t&lt;Ch>>>
    class basic_stored_value;

  <c>// <n><xref id="basic_stored_value.nonmember"/>, basic_stored_value non-member functions:</n></c>
  template &lt;class ChL, class ChR, class Tr>
    bool operator==(const basic_stored_value&lt;ChL, Tr>&amp;           left,
                    const basic_stored_value&lt;ChR, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator==(const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const std::basic_string&lt;Ch, Tr, Allocator>&amp;  right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator==(const std::basic_string&lt;Ch, Tr, Allocator>&amp;  left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator==(const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const Ch*                                    right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator==(const Ch*                                    left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;

  template &lt;class ChL, class ChR, class Tr>
    bool operator!=(const basic_stored_value&lt;ChL, Tr>&amp;           left,
                    const basic_stored_value&lt;ChR, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const std::basic_string&lt;Ch, Tr, Allocator>&amp;  right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator!=(const std::basic_string&lt;Ch, Tr, Allocator>&amp;  left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const Ch*                                   right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator!=(const Ch*                                    left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;

  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt; (const basic_stored_value&lt;ChL, Tr>&amp;           left,
                    const basic_stored_value&lt;ChR, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const std::basic_string&lt;Ch, Tr, Allocator>&amp;  right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator&lt; (const std::basic_string&lt;Ch, Tr, Allocator>&amp;  left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const Ch*                                    right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator&lt; (const Ch*                                    left,
                    const basic_stored_value&lt;Ch, Tr>&amp;            right) noexcept;

  template &lt;class ChL, class ChR, class Tr>
    bool operator> (const basic_stored_value&lt;ChL, Tr>&amp;           left,
                    const basic_stored_value&lt;ChR, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator> (const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const std::basic_string&lt;Ch, Tr, Allocator>&amp;  right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator> (const std::basic_string&lt;Ch, Tr, Allocator>&amp;  left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator> (const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const Ch*                                    right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator> (const Ch*                                    left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;

  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt;=(const basic_stored_value&lt;ChL, Tr>&amp;           left,
                    const basic_stored_value&lt;ChR, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const std::basic_string&lt;Ch, Tr, Allocator>&amp;  right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator&lt;=(const std::basic_string&lt;Ch, Tr, Allocator>&amp;  left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const Ch*                                    right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator&lt;=(const Ch*                                    left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;

  template &lt;class ChL, class ChR, class Tr>
    bool operator>=(const basic_stored_value&lt;ChL, Tr>&amp;           left,
                    const basic_stored_value&lt;ChR, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const std::basic_string&lt;Ch, Tr, Allocator>&amp;  right) noexcept;
  template &lt;class Ch, class ChC, class Tr, class Allocator>
    bool operator>=(const std::basic_string&lt;Ch, Tr, Allocator>&amp;  left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp;           left,
                    const Ch*                                    right) noexcept;
  template &lt;class Ch, class ChC, class Tr>
    bool operator>=(const Ch*                                    left,
                    const basic_stored_value&lt;ChC, Tr>&amp;           right) noexcept;

  template &lt;class Ch, class ChC, class Tr>
    std::basic_ostream&lt;Ch, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;Ch, Tr>&amp; os,
                                           const basic_stored_value&lt;ChC, Tr>&amp; o);

  template &lt;class Ch, class Tr, class Allocator = std::allocator&lt;std::remove_const&lt;Ch>>>
    std::basic_string&lt;std::remove_const&lt;Ch>, Tr, Allocator> to_string(
      basic_stored_value&lt;Ch, Tr>&amp; o, const Allocator&amp; alloc);

  <c>// <n><xref id="basic_stored_value.swap"/>, basic_stored_value specialized algorithms:</n></c>
  template &lt;class Ch, class Tr> void swap(basic_stored_value&lt;Ch, Tr>&amp; left,
                                          basic_stored_value&lt;Ch, Tr>&amp; right) noexcept;

  using stored_value   = basic_stored_value&lt;char>;
  using wstored_value  = basic_stored_value&lt;wchar_t>;
  using cstored_value  = basic_stored_value&lt;const char>;
  using cwstored_value = basic_stored_value&lt;const wchar_t>;

  <c>// <n><xref id="basic_stored_table"/>, basic_stored_table:</n></c>
  template &lt;class Content, class Allocator = std::allocator&lt;Content>> class basic_stored_table;

  <c>// <n><xref id="basic_stored_table.nonmember"/>, basic_stored_table non-member functions:</n></c>
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);

  <c>// <n><xref id="basic_stored_table.swap"/>, basic_stored_table specialized algorithms:</n></c>
  template &lt;class Content, class Allocator>
    void swap(basic_stored_table&lt;Content, Allocator>&amp; left,
              basic_stored_table&lt;Content, Allocator>&amp; right) noexcept;

  using stored_table   = basic_stored_table&lt;std::deque&lt;std::vector&lt;stored_value>>>;
  using wstored_table  = basic_stored_table&lt;std::deque&lt;std::vector&lt;wstored_value>>>;
  using cstored_table  = basic_stored_table&lt;std::deque&lt;std::vector&lt;cstored_value>>>;
  using cwstored_table = basic_stored_table&lt;std::deque&lt;std::vector&lt;cwstored_value>>>;

  enum stored_table_builder_option : <nc>unspecified</nc> {
    stored_table_builder_option_transpose = 1
  };

  <c>// <n><xref id="stored_table_builder"/>, stored_table_builder:</n></c>
  template &lt;class Content, class Allocator,
            std::underlying_type_t&lt;stored_table_builder_option> Options = 0>
    class stored_table_builder;

  <c>// <n><xref id="stored_table_builder.creation"/>, stored_table_builder creation functions:</n></c>
  template &lt;class Content, class Allocator>
    <nc>see below</nc> make_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table);
  template &lt;class Content, class Allocator>
    <nc>see below</nc> make_transposed_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table);
}

namespace std {
  <c>// <n><xref id="basic_stored_value.hash"/>, basic_stored_value hash support:</n></c>
  template &lt;class Ch, class Tr> struct hash&lt;commata::basic_stored_value&lt;Ch, Tr>>;
}
      </codeblock>
    </section>

    <section id="basic_stored_value">
      <name>Class template <c>basic_stored_value</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;std::remove_const_t&lt;Ch>>>
    class basic_stored_value {
  public:
    using value_type      = Ch;
    using reference       = Ch&amp;;
    using const_reference = const Ch&amp;;
    using pointer         = Ch*;
    using const_pointer   = const Ch*;
    using iterator        = Ch*;
    using const_iterator  = const Ch*;
    using difference_type = std::ptrdiff_t;
    using size_type       = std::size_t;
    using traits_type     = Tr;

    using reverse_iterator       = std::reverse_iterator&lt;iterator>;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator>;

    static constexpr size_type npos = -1;

    <c>// <n><xref id="basic_stored_value.cons"/>, construct/copy/destroy:</n></c>
    basic_stored_value() noexcept;
    basic_stored_value(Ch* begin, Ch* end);
    basic_stored_value(const basic_stored_value&amp; other) noexcept = default;
    basic_stored_value&amp; operator=(const basic_stored_value&amp; other) noexcept = default;

    template &lt;class OtherCh>
      basic_stored_value(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;
    template &lt;class OtherCh>
      basic_stored_value&amp; operator=(const basic_stored_value&amp; other) noexcept;

    <c>// <n><xref id="basic_stored_value.iterators"/>, iterators:</n></c>
    iterator       begin()        noexcept;
    const_iterator begin()  const noexcept;
    const_iterator cbegin() const noexcept;

    iterator       end()        noexcept;
    const_iterator end()  const noexcept;
    const_iterator cend() const noexcept;

    reverse_iterator       rbegin()        noexcept;
    const_reverse_iterator rbegin()  const noexcept;
    const_reverse_iterator crbegin() const noexcept;

    reverse_iterator       rend()        noexcept;
    const_reverse_iterator rend()  const noexcept;
    const_reverse_iterator crend() const noexcept;

    <c>// <n><xref id="basic_stored_value.capacity"/>, capacity:</n></c>
    size_type size()   const noexcept;
    size_type length() const noexcept;
    constpxpr size_type max_size() const noexcept;
    void clear() noexcept;
    bool empty() const noexcept;

    <c>// <n><xref id="basic_stored_value.access"/>, element accesss:</n></c>
    reference       operator[](size_type pos);
    const_reference operator[](size_type pos) const;
    reference       at(size_type pos);
    const_reference at(size_type pos) const;

    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back()  const;

    pointer       c_str()       noexcept;
    const_pointer c_str() const noexcept;
    pointer       data()        noexcept;
    const_pointer data()  const noexcept;

    template &lt;class Allocator> explicit operator
      std::basic_string&lt;std::remove_const_t&lt;Ch>, Tr, Allocator>() const;

    <c>// <n><xref id="basic_stored_value.modifiers"/>, modifiers:</n></c>
    iterator erase(const_iterator first, const_iterator last);
    iterator erase(const_iterator position);
    basic_stored_value&amp; erase(size_type pos = 0, size_type n = npos);

    void pop_front();
    void pop_back();

    void swap(basic_stored_value&amp; other) noexcept;

  private:
    Ch* b;    <c>// <nc>exposition only</nc></c>
    Ch* e;    <c>// <nc>exposition only</nc></c>
  };
}
      </codeblock>

      <p>The class template <c>basic_stored_value</c> describes an object that can refer to a contiguous null-terminated sequence of char-like objects in a store (<xref id="basic_stored_table.parts"/>) of a <c>basic_stored_table</c> object.</p>
      <p>Programs shall not modify the value of the terminating null object of the sequence directly.
         Instead, they should use modifiers of this class template (<xref id="basic_stored_value.modifiers"/>) or the store-accessing facilities (<xref id="basic_stored_table.rewrite"/>) of the <c>basic_stored_table</c> object that has the store concerned.</p>

      <section id="basic_stored_value.cons">
        <name><c>basic_stored_value</c> constructors and assignment operators</name>

        <code-item>
          <code>
basic_stored_value() noexcept;
          </code>
          <effects>Constructs an empty object of <c>basic_stored_value</c>.</effects>
          <postcondition><c>b == e</c> and <c>*e</c> is equal to <c>0</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_value(Ch* begin, Ch* end);
          </code>
          <requires>[<c>begin</c>, <c>end</c>] shall be a valid range. <c>*end</c> shall be equal to <c>0</c>.</requires>
          <throws>Nothing.</throws>
          <effects>Initializes <c>b</c> with <c>begin</c> and <c>e</c> with <c>end</c>.</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherCh>
  basic_stored_value(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;
          </code>
          <effects>Initializes <c>b</c> with <c>other.begin()</c> and <c>e</c> with <c>other.end()</c>.</effects>
          <remark>This overload shall not participate in overload resolution unless <c>Ch</c> is const-qualified and <c>Ch</c> and <c>const OtherCh</c> are the same type.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherCh>
  basic_stored_value&amp; operator=(const basic_stored_value&amp; other) noexcept;
          </code>
          <effects>Assigns <c>b</c> from <c>other.begin()</c> and <c>e</c> from <c>other.end()</c>.</effects>
          <remark>This overload shall not participate in overload resolution unless <c>Ch</c> is const-qualified and <c>Ch</c> and <c>const OtherCh</c> are the same type.</remark>
        </code-item>
      </section>

      <section id="basic_stored_value.iterators">
        <name><c>basic_stored_value</c> iterator support</name>

        <code-item>
          <code>
iterator       begin()        noexcept;
const_iterator begin()  const noexcept;
const_iterator cbegin() const noexcept;
          </code>
          <returns><c>b</c>.</returns>
        </code-item>

        <code-item>
          <code>
iterator       end()        noexcept;
const_iterator end()  const noexcept;
const_iterator cend() const noexcept;
          </code>
          <returns><c>e</c>.</returns>
        </code-item>

        <code-item>
          <code>
reverse_iterator       rbegin()        noexcept;
const_reverse_iterator rbegin()  const noexcept;
const_reverse_iterator crbegin() const noexcept;
          </code>
          <returns><c>reverse_iterator(end())</c>.</returns>
        </code-item>

        <code-item>
          <code>
reverse_iterator       rend()        noexcept;
const_reverse_iterator rend()  const noexcept;
const_reverse_iterator crend() const noexcept;
          </code>
          <returns><c>reverse_iterator(begin())</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.capacity">
        <name><c>basic_stored_value</c> capacity</name>

        <code-item>
          <code>
size_type size()   const noexcept;
size_type length() const noexcept;
          </code>
          <returns><c>end() - begin()</c>.</returns>
        </code-item>

        <code-item>
          <code>
constexpr size_type max_size() const noexcept;
          </code>
          <returns>The largest possible number that the member function <c>size</c> returns.</returns>
        </code-item>

        <code-item>
          <code>
void clear() noexcept;
          </code>
          <effects><c>erase(begin(), end())</c>.</effects>
        </code-item>

        <code-item>
          <code>
bool empty() const noexcept;
          </code>
          <returns><c>size() == 0</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.access">
        <name><c>basic_stored_value</c> element access</name>

        <code-item>
          <code>
reference       operator[](size_type pos);
const_reference operator[](size_type pos) const;
          </code>
          <requires><c>pos &lt;= size()</c>.</requires>
          <throws>Nothing.</throws>
          <returns><c>begin()[pos]</c>.</returns>
          <remark>if <c>pos == size()</c>, the returned reference is read-only.</remark>
        </code-item>

        <code-item>
          <code>
reference       at(size_type pos);
const_reference at(size_type pos) const;
          </code>
          <throws><c>std::out_of_range</c> if <c>pos >= size()</c>.</throws>
          <returns><c>(*this)[pos]</c>.</returns>
        </code-item>

        <code-item>
          <code>
reference       front();
const_reference front() const;
          </code>
          <requires><c>!empty()</c>.</requires>
          <throws>Nothing.</throws>
          <returns><c>(*this)[0]</c>.</returns>
        </code-item>

        <code-item>
          <code>
reference       back();
const_reference back() const;
          </code>
          <requires><c>!empty()</c>.</requires>
          <throws>Nothing.</throws>
          <returns><c>(*this)[size() - 1]</c>.</returns>
        </code-item>

        <code-item>
          <code>
pointer       c_str()       noexcept;
const_pointer c_str() const noexcept;
pointer       data()        noexcept;
const_pointer data()  const noexcept;
          </code>
          <returns><c>b</c>.</returns>
          <remark>The range [<c>r</c>, <c>r + size()</c>] is readable and the range [<c>r</c>, <c>r + size() - 1</c>) is writable where <c>r</c> is the returned value.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Allocator> explicit operator
  std::basic_string&lt;std::remove_const_t&lt;Ch>, Tr, Allocator>() const;
          </code>
          <returns><c>std::basic_string&lt;std::remove_const_t&lt;Ch>, Tr, Allocator>(cbegin(), cend())</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.modifiers">
        <name><c>basic_stored_value</c> modifiers</name>

        <code-item>
          <code>
iterator erase(const_iterator first, const_iterator last);
          </code>
          <requires>[<c>first</c>, <c>last</c>) shall be comprised in [<c>cbegin()</c>, <c>cend()</c>).</requires>
          <throws>Nothing.</throws>
          <postcondition>Suppose that <c>prefix</c> is the string of [<c>cbegin()</c>, <c>first</c>) and <c>postfix</c> is of [<c>last</c>, <c>cend()</c>) before the call.
                         Then the string of [<c>b</c>, <c>e</c>) shall be equal to <c>prefix</c> and <c>postfix</c> concatenated.
                         <c>*e</c> shall be <c>0</c>.</postcondition>
          <returns><c>begin() + off</c> where <c>off</c> is the value of <c>first - bb</c> and <c>bb</c> is the value of <c>cbegin()</c> before the call.</returns>
        </code-item>

        <code-item>
          <code>
iterator erase(const_iterator position);
          </code>
          <requires><c>position</c> shall point an object in [<c>cbegin()</c>, <c>cend()</c>).</requires>
          <throws>Nothing.</throws>
          <effects><c>erase(position, position + 1)</c>.</effects>
          <returns><c>begin() + off</c> where <c>off</c> is the value of <c>position - bb</c> and <c>bb</c> is the value of <c>cbegin()</c> before the call.</returns>
        </code-item>

        <code-item>
          <code>
basic_stored_value&amp; erase(size_type pos = 0, size_type n = npos);
          </code>
          <throws><c>std::out_of_range</c> if <c>pos > size()</c>.</throws>
          <effects>Calls <c>erase(cbegin() + pos, cbegin() + pos + xlen)</c> where <c>xlen</c> is the smaller of <c>n</c> and <c>size() - pos</c>.</effects>
          <returns><c>*this</c>.</returns>
        </code-item>

        <code-item>
          <code>
void pop_front();
          </code>
          <requires><c>empty()</c> shall not be <c>false</c>.</requires>
          <throws>Nothing.</throws>
          <effects><c>erase(cbegin())</c>.</effects>
        </code-item>

        <code-item>
          <code>
void pop_back();
          </code>
          <requires><c>empty()</c> shall not be <c>false</c>.</requires>
          <throws>Nothing.</throws>
          <effects><c>erase(cend() - 1)</c>.</effects>
        </code-item>

        <code-item>
          <code>
void swap(basic_stored_value&amp; other) noexcept;
          </code>
          <effects>Exchanges the values of <c>b</c> and <c>other.b</c>, and does the same with <c>e</c> and <c>other.e</c>.</effects>
        </code-item>
      </section>

      <section id="basic_stored_value.nonmember">
        <name><c>basic_stored_value</c> non-member functions</name>

        <section id="basic_stored_value.opeq">
          <name><c>operator==</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator==(const basic_stored_value&lt;ChL, Tr>&amp;          left,
                  const basic_stored_value&lt;ChR, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator==(const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const std::basic_string&lt;Ch, Tr, Allocator>&amp; right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator==(const std::basic_string&lt;Ch, Tr, Allocator>&amp; left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
            </code>
            <returns><c>left.size() == right.size() &amp;&amp; Tr::compare(left.data(), right.data(), left.size()) == 0</c>.</returns>
            <remark>These overloads shall not participate in overload resolution unless <c>std::remove_const_t&lt;ChL></c> and <c>std::remove_const_t&lt;ChR></c> are the same type (first overload) or <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type (the other overloads).</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Ch, class ChC, class Tr>
  bool operator==(const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const Ch*                                   right) noexcept;
            </code>
            <returns><c>left == basic_stored_value&lt;ChC, Tr>(right, right + Tr::length(right))</c>.</returns>
            <remark>This overload shall not participate in overload resolution unless <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Ch, class ChC, class Tr>
  bool operator==(const Ch*                                   left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
            </code>
            <returns><c>right == left</c>.</returns>
            <remark>This overload shall not participate in overload resolution unless <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.opne">
          <name><c>operator!=</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator!=(const basic_stored_value&lt;ChL, Tr>&amp;          left,
                  const basic_stored_value&lt;ChR, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const std::basic_string&lt;Ch, Tr, Allocator>&amp; right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator!=(const std::basic_string&lt;Ch, Tr, Allocator>&amp; left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr>
  bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const Ch*                                   right) noexcept;
template &lt;class Ch, class ChC, class Tr>
  bool operator!=(const Ch*                                   left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
            </code>
            <returns><c>!(left == right)</c>.</returns>
            <remark>These overloads shall not participate in overload resolution unless <c>std::remove_const_t&lt;ChL></c> and <c>std::remove_const_t&lt;ChR></c> are the same type (first overload) or <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type (the other overloads).</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.oplt">
          <name><c>operator&lt;</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator&lt; (const basic_stored_value&lt;ChL, Tr>&amp;          left,
                  const basic_stored_value&lt;ChR, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const std::basic_string&lt;Ch, Tr, Allocator>&amp; right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator&lt; (const std::basic_string&lt;Ch, Tr, Allocator>&amp; left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
            </code>
            <returns><c>c &lt; 0 || (c == 0 &amp;&amp; left.size() &lt; right.size())</c> where <c>c</c> is the return value of <c>Tr::compare(left.data(), right.data(), rlen)</c> and <c>rlen</c> is the smaller of <c>left.size()</c> and <c>right.size()</c>.</returns>
            <remark>These overloads shall not participate in overload resolution unless <c>std::remove_const_t&lt;ChL></c> and <c>std::remove_const_t&lt;ChR></c> are the same type (first overload) or <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type (the other overloads).</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Ch, class ChC, class Tr>
  bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const Ch*                                   right) noexcept;
            </code>
            <returns><c>left &lt; basic_stored_value&lt;Ch, Tr>(right, right + Tr::length(right))</c>.</returns>
            <remark>This overload shall not participate in overload resolution unless <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Ch, class ChC, class Tr>
  bool operator&lt; (const Ch*                                   left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
            </code>
            <returns><c>basic_stored_value&lt;Ch, Tr>(left, left + Tr::length(left)) &lt; right</c>.</returns>
            <remark>This overload shall not participate in overload resolution unless <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.opgt">
          <name><c>operator></c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator> (const basic_stored_value&lt;ChL, Tr>&amp;          left,
                  const basic_stored_value&lt;ChR, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator> (const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const std::basic_string&lt;Ch, Tr, Allocator>&amp; right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator> (const std::basic_string&lt;Ch, Tr, Allocator>&amp; left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr>
  bool operator> (const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const Ch*                                   right) noexcept;
template &lt;class Ch, class ChC, class Tr>
  bool operator> (const Ch*                                   left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
            </code>
            <returns><c>right &lt; left</c>.</returns>
            <remark>These overloads shall not participate in overload resolution unless <c>std::remove_const_t&lt;ChL></c> and <c>std::remove_const_t&lt;ChR></c> are the same type (first overload) or <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type (the other overloads).</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.ople">
          <name><c>operator&lt;=</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator&lt;=(const basic_stored_value&lt;ChL, Tr>&amp;          left,
                  const basic_stored_value&lt;ChR, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const std::basic_string&lt;Ch, Tr, Allocator>&amp; right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator&lt;=(const std::basic_string&lt;Ch, Tr, Allocator>&amp; left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr>
  bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const Ch*                                   right) noexcept;
template &lt;class Ch, class ChC, class Tr>
  bool operator&lt;=(const Ch*                                   left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
            </code>
            <returns><c>!(right &lt; left)</c>.</returns>
            <remark>These overloads shall not participate in overload resolution unless <c>std::remove_const_t&lt;ChL></c> and <c>std::remove_const_t&lt;ChR></c> are the same type (first overload) or <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type (the other overloads).</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.opge">
          <name><c>operator>=</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator>=(const basic_stored_value&lt;ChL, Tr>&amp;          left,
                  const basic_stored_value&lt;ChR, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const std::basic_string&lt;Ch, Tr, Allocator>&amp; right) noexcept;
template &lt;class Ch, class ChC, class Tr, class Allocator>
  bool operator>=(const std::basic_string&lt;Ch, Tr, Allocator>&amp; left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
template &lt;class Ch, class ChC, class Tr>
  bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp;          left,
                  const Ch*                                   right) noexcept;
template &lt;class Ch, class ChC, class Tr>
  bool operator>=(const Ch*                                   left,
                  const basic_stored_value&lt;ChC, Tr>&amp;          right) noexcept;
            </code>
            <returns><c>!(left &lt; right)</c>.</returns>
            <remark>These overloads shall not participate in overload resolution unless <c>std::remove_const_t&lt;ChL></c> and <c>std::remove_const_t&lt;ChR></c> are the same type (first overload) or <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type (the other overloads).</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.inserter">
          <name><c>operator&lt;&lt;</c></name>
          <code-item>
            <code>
template &lt;class Ch, class ChC, class Tr>
  std::basic_ostream&lt;Ch, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;Ch, Tr>&amp; os,
                                         const basic_stored_value&lt;ChC, Tr>&amp; o);
            </code>
            <effects>Behaves as a formatted output function of <c>os</c>.
                     Forms a character sequence <c>seq</c>, initially consisting of the elements defined by the range [<c>o.cbegin()</c>, <c>o.cend()</c>).
                     Determines padding for <c>seq</c>. Then inserts <c>seq</c> as if by calling <c>os.rdbuf()->sputn(seq, n)</c>, where <c>n</c> is the larger of <c>os.width()</c> and the size of <c>seq</c>; then calls <c>os.width(0)</c>.</effects>
            <returns><c>os</c>.</returns>
            <remark>This overload shall not participate in overload resolution unless <c>Ch</c> and <c>std::remove_const_t&lt;ChC></c> are the same type.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.conversion">
          <name><c>basic_stored_value</c> conversion</name>
          <code-item>
            <code>
template &lt;class Ch, class Tr, class Allocator = std::allocator&lt;Ch>>
  std::basic_string&lt;std::remove_const&lt;Ch>, Tr, Allocator> to_string(
    basic_stored_value&lt;Ch, Tr>&amp; o, const Allocator&amp; alloc = Allocator());
            </code>
            <returns><c>std::basic_string&lt;std::remote_const&lt;Ch>, Tr, Allocator>(o.cbegin(), o.cend(), alloc)</c>.</returns>
          </code-item>
        </section>
      </section>

      <section id="basic_stored_value.swap">
        <name><c>basic_stored_value</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Ch, class Tr> void swap(basic_stored_value&lt;Ch, Tr>&amp; left,
                                        basic_stored_value&lt;Ch, Tr>&amp; right) noexcept;
          </code>
          <effects><c>left.swap(right)</c>.</effects>
        </code-item>
      </section>

      <section id="basic_stored_value.hash">
        <name><c>basic_stored_value</c> hash support</name>

        <codeblock>
namespace std {
  template &lt;class Ch, class Tr> struct hash&lt;commata::basic_stored_value&lt;Ch, Tr>>;
}
        </codeblock>
        <p>This template specialization shall meet the requirements of class template <c>std::hash</c>.</p>
      </section>
    </section>

    <section id="basic_stored_table">
      <name>Class template <c>basic_stored_table</c></name>

      <section id="basic_stored_table.overview">
        <name>Class template <c>basic_stored_table</c> overview</name>

        <codeblock>
namespace commata {
  template &lt;class Content, class Allocator = std::allocator&lt;Content>>
    class basic_stored_table {
  public:
    using allocator_type  = Allocator;
    using content_type    = Content;
    using record_type     = typename content_type::value_type;
    using value_type      = typename record_type::value_type;
    using char_type       = std::remove_const_t&lt;typename value_type::value_type>;
    using traits_type     = typename value_type::traits_type;
    using size_type       = typename content_type::size_type;

    <c>// <n><xref id="basic_stored_table.cons"/>, construct/copy/destroy:</n></c>
    explicit basic_stored_table(std::size_t buffer_size = 0);
    basic_stored_table(const basic_stored_table&amp;  other);
    basic_stored_table(      basic_stored_table&amp;&amp; other) noexcept;
    template &lt;class OtherContent, class OtherAllocator>
      basic_stored_table(
        const basic_stored_table&lt;OtherContent, OtherAllocator>&amp;  other);
    template &lt;class OtherContent, class OtherAllocator>
      basic_stored_table(
              basic_stored_table&lt;OtherContent, OtherAllocator>&amp;&amp; other);
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                       std::size_t buffer_size = 0);
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                       const basic_stored_table&amp;  other);
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                             basic_stored_table&amp;&amp; other);
    template &lt;class OtherContent, class OtherAllocator>
      basic_stored_table(
        std::allocator_arg_t, const Allocator&amp; alloc,
        const basic_stored_table&lt;OtherContent, OtherAllocator>&amp;  other);
    template &lt;class OtherContent, class OtherAllocator>
      basic_stored_table(
        std::allocator_arg_t, const Allocator&amp; alloc,
              basic_stored_table&lt;OtherContent, OtherAllocator>&amp;&amp; other);
   ~basic_stored_table();
    basic_stored_table&amp; operator=(const basic_stored_table&amp;  other);
    basic_stored_table&amp; operator=(      basic_stored_table&amp;&amp; other);

    <c>// <n><xref id="basic_stored_table.constituents"/>, access to the constituents:</n></c>
    allocator_type get_allocator() const noexcept;
    std::size_t get_buffer_size() const noexcept;
    bool is_singular() const noexcept;
    content_type&amp;       content();
    const content_type&amp; content() const;
    record_type&amp;       operator[](size_type record_index);
    const record_type&amp; operator[](size_type record_index) const;
    size_type size() const noexcept(<nc>see below</nc>);
    bool empty() const noexcept(<nc>see below</nc>);
    void clear() noexcept(<nc>see below</nc>);

    <c>// <n><xref id="basic_stored_table.capacity"/>, capacity:</n></c>
    void shrink_to_fit();

    <c>// <n><xref id="basic_stored_table.rewrite"/>, store operations:</n></c>
    template &lt;class ForwardIterator>
      value_type&amp;
        rewrite_value(value_type&amp; value,
                      ForwardIterator new_value_begin, ForwardIterator new_value_end);
    template &lt;class ForwardIterator>
      value_type&amp; rewrite_value(value_type&amp; value, ForwardIterator new_value);
    template &lt;class OtherValue>
      value_type&amp; rewrite_value(value_type&amp; value, const OtherValue&amp; new_value);
    template &lt;class... Args> value_type import_value(Args&amp;&amp;... args);
    template &lt;class F> void guard_rewrite(F f);

    <c>// <n><xref id="basic_stored_table.primitives"/>, primitive store operations:</n></c>
    void add_buffer(char_type* buffer, std::size_t size);
    void secure_current_upto(char_type* secured_last);

    <c>// <n><xref id="basic_stored_table.modifiers"/>, modifiers:</n></c>
    template &lt;class OtherContent, class OtherAllocator>
      basic_stored_table&amp; operator+=(
        const basic_stored_table&lt;OtherContent, OtherAllocator>&amp; other);
    template &lt;class OtherContent>
      basic_stored_table&amp; operator+=(
              basic_stored_table&lt;OtherContent, Allocator>&amp;&amp;     other);
    void swap(basic_stored_table&amp; other) noexcept;
  };
}
        </codeblock>

        <p>The class template <c>basic_stored_table</c> is a facility to make an in-memory image of text values arranged two-dimensionally.</p>

        <p>The template parameter <c>Content</c> shall be a sequence container type of a sequence container type of <c>basic_stored_value&lt;Ch, Tr></c> (<xref id="basic_stored_value"/>) for some <c>Ch</c> and <c>Tr</c>.
           Note that <c>std::array</c> and <c>std::forward_list</c> do not qualify because they lack some essential functionalities of sequence containers.</p>
        <p>The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements for <c>Content</c>.</p>

        <section id="basic_stored_table.parts">
          <name><c>basic_stored_table</c> constituents</name>

          <p>An object of <c>basic_stored_table&lt;Content, Allocator></c> consists of the four following constituents:</p>
          <ul>
            <li>a <n>content</n>, whose type is <c>Content</c> and that is a sequence container object of sequence container objects of text values that are objects of <c>basic_stored_value&lt;Ch, Tr></c> (<xref id="basic_stored_value"/>) for some <c>Ch</c> and <c>Tr</c>,</li>
            <li>a <n>store</n>, which is a bundle of <n>buffers</n> each one of which is an array of <c>Ch</c> and contains memory referenced by the text values in the content,</li>
            <li>an allocator, whose type is <c>Allocator</c> and that is used to allocate and construct the content and to allocate memories required by the store and any other operations, and</li>
            <li>a <n>buffer size</n>, whose type is <c>std::size_t</c> and that is used as the least amount of <c>Ch</c> in one memory allocation.</li>
          </ul>
          <p>An object of an instance of <c>basic_stored_table</c> is able not to have its content.</p>
          <p>The store of an object of <c>basic_stored_table</c> marks one buffer in it as its <n>current buffer</n> when it is not empty; that is, when it has at least one buffer.</p>
        </section>

        <section id="basic_stored_table.defs">
          <name>Definitions</name>

          <p>An object of an instance of <c>basic_stored_table</c> without its content is called <n>singular</n>.</p>

          <p>The <n>value type</n> of an object of an instance of <c>basic_stored_table&lt;Content, Allocator></c> denotes <c>typename Content::value_type::value_type</c>, whose type is an instance of <c>basic_stored_value</c>.</p>

          <p><n>Contained values</n> of an object <c>t</c> of an instance <c>T</c> of <c>basic_stored_table</c> denotes the objects of the value type in the content of <c>t</c>.</p>

          <p>An object <c>v</c> of a value type is called <n>backed by</n> an object <c>t</c> of an instance of <c>basic_stored_table</c> if:</p>
          <ul>
            <li><c>v.empty()</c> is not <c>false</c>, or</li>
            <li>the range [<c>v.cbegin()</c>, <c>v.cend()</c>] resides in a buffer in the store of <c>t</c>, and <c>*v.cend()</c> is equal to <c>Ch()</c>.</li>
          </ul>
          <p>An object of an instance of <c>basic_stored_table</c> is called <n>complete</n> if none of its contained values is not backed by it.
             Note that a singular object of an instance of <c>basic_stored_table</c> is also complete because it has no contained values.</p>
        </section>

        <section id="basic_stored_table.conds">
          <name>General requirements and postconditions</name>

          <p>The consequence of accessing to the content of a singular <c>basic_stored_table</c> object is undefined.
             A singular object can be assigned, destroyed, copied from or moved from.
             A singular object has a store, an allocator, and a buffer size similarly to non-singular objects.</p>

          <p>All member functions of <c>basic_stored_table</c> and all non-member functions declared in this header (<xref id="stored_table_hpp"/>) that take at least one parameter whose cv-unqualified type is (possibly a reference to) an instance of <c>basic_stored_table</c> require that the following conditions meet:</p>
          <ul>
             <li>all participating <c>basic_stored_table</c> objects are complete, and</li>
             <li>no two of the contained values of the participating <c>basic_stored_table</c> objects overlap.</li>
          </ul>
          <p>And they meet the following postconditions:</p>
          <ul>
             <li>all participating <c>basic_stored_table</c> objects shall be complete,</li>
             <li>no two of the contained values of the participating <c>basic_stored_table</c> objects shall overlap, and</li>
             <li>the states of the participating <c>basic_stored_table</c> objects shall not be changed if the call exits via an exception.</li>
          </ul>

          <p>All non-const member functions of <c>basic_stored_table</c> and all non-member functions declared in this header (<xref id="stored_table_hpp"/>) that take at least one parameter whose type is a reference to a non-const <c>basic_stored_table&lt;Ch, Tr></c> for some <c>Ch</c> and <c>Tr</c> may change the current buffer marks of the participating non-const <c>basic_stored_table</c> objects.</p>
        </section>
      </section>

      <section id="basic_stored_table.cons">
        <name><c>basic_stored_table</c> construct/copy/destroy</name>

        <p>In this subclause, <c>AT</c> denotes <c>std::allocator_traits&lt;Allocator></c>.</p>
        <p>All constructors and assignment operators that take a parameter whose cv-unqualified type is an instance of <c>basic_stored_table</c> propagates singularity;
           that is, <c>*this</c> shall be singular after the call if and only if the argument is singular.</p>
        <p>With respect to allocators, all constructors shall perform uses-allocator construction of the store.
           All constructors and assignment operators shall behave as if <c>basic_stored_table&lt;Content, Allocator></c> is a container of <c>Content</c> (even though its size is at most one), and
           shall make an appropriate decision about propagation of the allocator in accordance with <c>AT::select_on_container_copy_construnction</c>, <c>AT::propagete_on_container_copy_assignment</c> and <c>AT::propagete_on_container_move_assignment</c>.</p>

        <code-item>
          <code>
explicit basic_stored_table(std::size_t buffer_size = 0);
          </code>
          <requires><c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <effects>If <c>buffer_size</c> is greater than <c>0</c>, initializes the buffer size to a value that is the smaller of <c>AT::max_size(Allocator())</c> and <c>b2</c> where <c>b2</c> is the greater of <c>buffer_size</c> and <c>2</c>.
                   Otherwise, initializes it to a unspecified value.
                   Initializes the allocator with its default constructor.
                   Initializes the content to be an empty one.</effects>
        </code-item>

        <code-item>
          <code>
basic_stored_table(const basic_stored_table&amp; other);
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(get_allocator())</c> and <c>other.get_buffer_size()</c>.
                         If not singular, also <c>content() == other.content()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table(basic_stored_table&amp;&amp; other) noexcept;
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(get_allocator())</c> and the value of <c>other.get_buffer_size()</c> before this construction.
                         If not singular, <c>content()</c> shall be equal to the value that <c>other.content()</c> had before this construction.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherContent, class OtherAllocator>
  basic_stored_table(
    const basic_stored_table&lt;OtherContent, OtherAllocator>&amp; other);
          </code>
          <requires><c>OtherContent::char_type</c> and <c>OtherContent::traits_type</c> shall be identical types to <c>char_type</c> and <c>traits_type</c> respectively.
                    <c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(get_allocator())</c> and <c>other.get_buffer_size()</c>.
                         The value of <c>get_allocator()</c> shall be equal to a default-constructed <c>Allocator</c> object.
                         The values of <c>size()</c> and <c>other.size()</c> shall be identical.
                         For each <c>ti</c> and <c>oi</c> that denote the possible corresponding elements in the contents of <c>*this</c> and <c>other</c> respectively, the values of <c>*ti</c> and <c>record_type(oi->cbegin(), oi->cend())</c> shall be equal.
                         <c>*this</c> may be singular only if <c>other</c> is singular.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherContent, class OtherAllocator>
  basic_stored_table(
    basic_stored_table&lt;OtherContent, OtherAllocator>&amp;&amp; other);
          </code>
          <requires><c>OtherContent::char_type</c> and <c>OtherContent::traits_type</c> shall be identical types to <c>char_type</c> and <c>traits_type</c> respectively.
                    <c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(get_allocator())</c> and <c>other.get_buffer_size()</c>.
                         The value of <c>get_allocator()</c> shall be equal to a default-constructed <c>Allocator</c> object.
                         The values of <c>size()</c> and the value that <c>other.size()</c> had before this construction shall be identical.
                         For each <c>ti</c> and <c>oi</c> that denote the possible corresponding elements in the contents of <c>*this</c> and <c>other</c> respectively, the value of <c>*ti</c> shall be equal to the value that <c>record_type(oi->cbegin(), oi->cend())</c> had before this construction.
                         <c>*this</c> may be singular only if <c>other</c> was singular before the construction.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                   std::size_t buffer_size = 0);
          </code>
          <requires><c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <effects>If <c>buffer_size</c> is greater than <c>0</c>, initializes the buffer size to a value that is the smaller of <c>AT::max_size(alloc)</c> and <c>b2</c> where <c>b2</c> is the greater of <c>buffer_size</c> and <c>2</c>.
                   Otherwise, initializes it to a unspecified value.
                   Initializes the allocator with <c>alloc</c>.
                   Initializes the content to be an empty one.</effects>
        </code-item>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                   const basic_stored_table&amp;  other);
          </code>
          <postcondition><c>get_allocator() == alloc</c> shall be <c>true</c> and <c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(alloc)</c> and <c>other.get_buffer_size()</c>.
                         If not singular, <c>content() == other.content()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                   basic_stored_table&amp;&amp; other);
          </code>
          <postcondition><c>get_allocator() == alloc</c> shall be <c>true</c> and <c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(alloc)</c> and <c>other.get_buffer_size()</c>.
                         If not singular, <c>content()</c> shall be equal to the value that <c>other.content()</c> had before this construction.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherContent, class OtherAllocator>
  basic_stored_table(
    std::allocator_arg_t, const Allocator&amp; alloc,
    const basic_stored_table&lt;OtherContent, OtherAllocator>&amp; other);
          </code>
          <requires><c>OtherContent::char_type</c> and <c>OtherContent::traits_type</c> shall be identical types to <c>char_type</c> and <c>traits_type</c> respectively.
                    <c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(get_allocator())</c> and <c>other.get_buffer_size()</c>.
                         The value of <c>get_allocator()</c> shall be equal to <c>alloc</c>.
                         The values of <c>size()</c> and <c>other.size()</c> shall be identical.
                         For each <c>ti</c> and <c>oi</c> that denote the possible corresponding elements in the contents of <c>*this</c> and <c>other</c> respectively, the values of <c>*ti</c> and <c>record_type(oi->cbegin(), oi->cend())</c> shall be equal.
                         <c>*this</c> may be singular only if <c>other</c> is singular.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherContent, class OtherAllocator>
  basic_stored_table(
    std::allocator_arg_t, const Allocator&amp; alloc,
    basic_stored_table&lt;OtherContent, OtherAllocator>&amp;&amp; other);
          </code>
          <requires><c>OtherContent::char_type</c> and <c>OtherContent::traits_type</c> shall be identical types to <c>char_type</c> and <c>traits_type</c> respectively.
                    <c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(get_allocator())</c> and <c>other.get_buffer_size()</c>.
                         The value of <c>get_allocator()</c> shall be equal to <c>alloc</c>.
                         The values of <c>size()</c> and the value that <c>other.size()</c> had before this construction shall be identical.
                         For each <c>ti</c> and <c>oi</c> that denote the possible corresponding elements in the contents of <c>*this</c> and <c>other</c> respectively, the value of <c>*ti</c> shall be equal to the value that <c>record_type(oi->cbegin(), oi->cend())</c> had before this construction.
                         <c>*this</c> may be singular only if <c>other</c> was singular before the construction.</postcondition>
        </code-item>


        <code-item>
          <code>
~basic_stored_table();
          </code>
          <effects>Destroys the content if not singular, deallocates all buffers in the store, and destroys the allocator.</effects>
        </code-item>

        <code-item>
          <code>
basic_stored_table&amp; operator=(const basic_stored_table&amp; other);
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(get_allocator())</c> and <c>other.get_buffer_size()</c>.
                         If not singular, <c>content() == other.content()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table&amp; operator=(basic_stored_table&amp;&amp; other);
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>AT::max_size(get_allocator())</c> and the value of <c>other.get_buffer_size()</c> before this assignment.
                         If not singular, <c>content()</c> shall be equal to the value that <c>other.content()</c> had before this assignment.
                         <c>other</c> may be singular.</postcondition>
        </code-item>
      </section>

      <section id="basic_stored_table.constituents">
        <name><c>basic_stored_table</c> constituent access</name>

        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>The allocator.</returns>
        </code-item>

        <code-item>
          <code>
std::size_t get_buffer_size() const noexcept;
          </code>
          <returns>The buffer size.</returns>
        </code-item>

        <code-item>
          <code>
bool is_singular() const noexcept;
          </code>
          <returns><c>true</c> if <c>*this</c> is singular; <c>false</c> otherwise.</returns>
        </code-item>

        <code-item>
          <code>
content_type&amp;       content();
const content_type&amp; content() const;
          </code>
          <requires><c>*this</c> shall not be singular.</requires>
          <returns>The content.</returns>
        </code-item>

        <code-item>
          <code>
record_type&amp;       operator[](size_type record_index);
const record_type&amp; operator[](size_type record_index) const;
          </code>
          <requires><c>*this</c> shall not be singular.</requires>
          <returns><c>content()[record_index]</c>.</returns>
        </code-item>

        <code-item>
          <code>
size_type size() const noexcept(<nc>see below</nc>);
          </code>
          <returns><c>0</c> if singular; <c>content().size()</c> otherwise.</returns>
          <remark>The expression inside <c>noexcept</c> is <c>false</c> if and only if <c>Content::size</c> with no parameters is not marked as <c>noexcept</c>.</remark>
        </code-item>

        <code-item>
          <code>
bool empty() const noexcept(<nc>see below</nc>);
          </code>
          <returns><c>true</c> if singular; <c>content().empty()</c> otherwise.</returns>
          <remark>The expression inside <c>noexcept</c> is <c>false</c> if and only if <c>Content::empty</c> with no parameters is not marked as <c>noexcept</c>.</remark>
        </code-item>

        <code-item>
          <code>
void clear() noexcept(<nc>see below</nc>);
          </code>
          <effects>Calls <c>content().clear()</c> if and only if not singular. Then deallocates all buffers in the store.</effects>
          <remark>The expression inside <c>noexcept</c> is <c>false</c> if and only if <c>Content::clear</c> with no parameters is not marked as <c>noexcept</c>.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.capacity">
        <name><c>basic_stored_table</c> capacity</name>
        <code-item>
          <code>
void shrink_to_fit();
          </code>
          <postcondition>The values of <c>is_singular()</c>, <c>content()</c> (if not singular), <c>get_allocator()</c> and <c>get_buffer_size()</c> shall be equal to the values that those had before this call.</postcondition>
          <remark>This is a non-binding request to reduce memory use.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.rewrite">
        <name><c>basic_stored_table</c> store operations</name>

        <code-item>
          <code>
template &lt;class ForwardIterator>
  value_type&amp;
    rewrite_value(value_type&amp; value,
                  ForwardIterator new_value_begin, ForwardIterator new_value_end);
          </code>
          <requires><c>value</c> shall be backed by <c>*this</c>.
                    The template parameter <c>ForwardIterator</c> shall meet the <c>ForwardIterator</c> requirements for <c>char_type</c>.
                    [<c>new_value_begin</c>, <c>new_value_end</c>) shall be a valid range.</requires>
          <effects>Modifies the store and <c>value</c> so that <c>value</c> will be unchangedly backed by <c>*this</c> and <c>std::equal(value.cbegin(), value.cend(), new_value_begin, new_value_end, p)</c> will be <c>true</c> where <c>p</c> is an equivalent predicate to <c>traits_type::eq</c>.</effects>
          <returns><c>value</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class ForwardIterator>
  value_type&amp; rewrite_value(value_type&amp; value, ForwardIterator new_value);
          </code>
          <requires><c>value</c> shall be backed by <c>*this</c>.
                    The template parameter <c>ForwardIterator</c> shall meet the <c>ForwardIterator</c> requirements for <c>char_type</c>.</requires>
          <effects>Determines the length <c>n</c>, whose value is the smallest nonnegative integer that satisfies <c>traits_type::eq(*std::next(new_value, n), char_type())</c>.
                   Then calls <c>rewrite_value(new_value, std::next(new_value, n))</c>.</effects>
          <returns><c>value</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherValue>
  value_type&amp; rewrite_value(value_type&amp; value, const OtherValue&amp; new_value);
          </code>
          <requires><c>value</c> shall be backed by <c>*this</c>.</requires>
          <effects>Calls <c>rewrite_value(new_value.cbegin(), new_value.cend())</c>.</effects>
          <returns><c>value</c>.</returns>
          <remark>This overload shall not participate in overload resolution unless <c>OtherValue::const_iterator</c> is a type.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class... Args> value_type import_value(Args&amp;&amp;... args);
          </code>
          <effects>Constructs an object of <c>value_type</c> with no arguments, which is named <c>value</c>.
                   Then calls <c>rewrite_value(value, std::forward&lt;Args>(args)...)</c>.</effects>
          <returns><c>value</c> above.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class F> void guard_rewrite(F f);
          </code>
          <requires><c>f</c> shall possibly call functions that do not change the state of <c>*this</c> except <c>rewrite_value</c>, <c>import_value</c>, <c>add_buffer</c> and <c>secure_current_upto</c>.</requires>
          <effects>Calls <c>f()</c>.</effects>
          <remark>If an exception is thrown, all buffers that have been put into the store of <c>*this</c> during the call of <c>f()</c> are deallocated,
                  all objects returned by the calls of <c>rewrite_value</c> and therefore <c>import_value</c> during the call of <c>f()</c> are invalidated,
                  and the current buffer mark and its reservation marks (<xref id="basic_stored_table.primitives"/>) are restored.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.primitives">
        <name><c>basic_stored_table</c> primitive store operations</name>

        <code-item>
          <code>
void add_buffer(char_type* buffer, std::size_t size);
          </code>
          <requires><c>p</c> shall point the first element of a buffer allocated by a rebound copy of a return value of <c>get_allocator()</c> for <c>char_type</c>.
                    <c>size</c> shall match the value passed to the allocator to obtain this memory.
                    The range [<c>buffer</c>, <c>buffer + size</c>) shall not overlap with any buffers in the store of <c>*this</c>.</requires>
          <effects>Adds the range [<c>buffer</c>, <c>buffer + size</c>) to the store as a buffer and marks it as the current buffer.</effects>
          <remark>If an exception is thrown, the buffer is deallocated.</remark>
        </code-item>

        <code-item>
          <code>
void secure_current_upto(char_type* secured_last);
          </code>
          <requires><c>secured_last</c> shall point an element in the current buffer or be the past-the-end pointer of the current buffer.</requires>
          <effects>Marks the range [<c>cb</c>, <c>secured_last</c>) as reserved against <c>rewrite_value</c> and therefore <c>import_value</c> (<xref id="basic_stored_table.rewrite"/>), where <c>cb</c> is a pointer to the first element of the current buffer.</effects>
          <remark>This function does not change the current buffer mark. The reservation marks can not be revoked except by <c>guard_rewrite</c>.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.modifiers">
        <name><c>basic_stored_table</c> modifiers</name>

        <p>To achieve clarity, in this subclause <c>operator[]</c> are used on a non-singular object <c>t</c> of an instance of <c>basic_stored_table</c> that does not necessarily have them well-defined. In these cases, the semaintics of <c>t[n]</c> is the same as that of <c>*std::next(t.content().cbegin(), n)</c>.</p>

        <code-item>
          <code>
template &lt;class OtherContent, class OtherAllocator>
  basic_stored_table&amp; operator+=(
    const basic_stored_table&lt;OtherContent, OtherAllocator>&amp; other);
          </code>
          <requires><c>OtherContent::char_type</c> and <c>OtherContent::traits_type</c> shall be identical types to <c>char_type</c> and <c>traits_type</c> respectively.
                    If an exception is thrown by a call of <c>emplace</c> of <c>content()</c> at the end, there shall be no effects on the before-end elements.
                    Any calls of <c>erase</c> of <c>content()</c> at the end shall not exit via an exception.</requires>
          <postcondition>Let <c>lsize</c> be the value that <c>size()</c> returned before the call.
                         <c>size() == lsize + other.size()</c> shall be <c>true</c>.
                         For each <c>i</c> in the range [<c>0</c>, <c>lsize</c>), the value of <c>(*this)[i]</c> shall be equal to the value that it had before call.
                         For each <c>i</c> in the range [<c>0</c>, <c>other.size()</c>), <c>(*this)[lsize + i] == record_type(other[i].cbegin(), other[i].cend())</c> shall hold <c>true</c>.
                         <c>*this</c> shall be singular only if both of <c>*this</c> and <c>other</c> were singular before the call.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherContent>
  basic_stored_table&amp; operator+=(
    basic_stored_table&lt;OtherContent, Allocator>&amp;&amp; other);
          </code>
          <requires><c>OtherContent::char_type</c> and <c>OtherContent::traits_type</c> shall be identical types to <c>char_type</c> and <c>traits_type</c> respectively.
                    If an exception is thrown by a call of <c>emplace</c> of <c>content()</c> at the end, there shall be no effects on the before-end elements.
                    Neither of calls of <c>erase</c> of <c>content()</c> at the end and <c>erase</c> of <c>other.content()</c> at the end shall exit via an exception.</requires>
          <postcondition>Let <c>lsize</c> be the value that <c>size()</c> returned before the call.
                         <c>size() == lsize + other.size()</c> shall be <c>true</c>.
                         For each <c>i</c> in the range [<c>0</c>, <c>lsize</c>), the value of <c>(*this)[i]</c> shall be equal to the value that it had before call.
                         For each <c>i</c> in the range [<c>0</c>, <c>other.size()</c>), the value of <c>(*this)[lsize + i]</c> shall be equal to the value that <c>record_type(other[i].cbegin(), other[i].cend())</c> had before the call.
                         <c>*this</c> shall be singular only if both of <c>*this</c> and <c>other</c> were singular before the call.</postcondition>
        </code-item>

        <code-item>
          <code>
void swap(basic_stored_table&amp; other) noexcept;
          </code>
          <requires>If <c>std::allocator_traits&lt;allocator_type>::propagate_on_container_swap::value</c> is <c>false</c>, <c>get_allocator() == other.get_allocator()</c> shall be <c>true</c>.</requires>
          <effects>Exchanges the contents of <c>*this</c> and <c>other</c>.</effects>
          <remark>The allocators are exchanged if and only if <c>std::allocator_traits&lt;allocator_type>::propagate_on_container_swap::value</c> is not <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.nonmember">
        <name><c>basic_stored_table</c> non-member functions</name>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp; left,
              const basic_stored_table&lt;ContentR, AllocatorR>&amp; right);
          </code>
          <returns><c>basic_stored_table&lt;ContentL, AllocatorL>(left) += right</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                    basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
          </code>
          <returns><c>basic_stored_table&lt;ContentL, AllocatorL>(left) += std::move(right)</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
              const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
          </code>
          <returns><c>basic_stored_table&lt;ContentL, AllocatorL>(std::move(left)) += right</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                    basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
          </code>
          <returns><c>basic_stored_table&lt;ContentL, AllocatorL>(std::move(left)) += std::move(right)</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_table.swap">
        <name><c>basic_stored_table</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Content, class Allocator>
  void swap(basic_stored_table&lt;Content, Allocator>&amp; left,
            basic_stored_table&lt;Content, Allocator>&amp; right) noexcept;
          </code>
          <effects><c>left.swap(right)</c>.</effects>
        </code-item>
      </section>
    </section>

    <section id="stored_table_builder">
      <name>Class template <c>stored_table_builder</c></name>

      <codeblock>
namespace commata {
  template &lt;class Content, class Allocator,
            std::underlying_type_t&lt;stored_table_builder_option> Options = 0>
    class stored_table_builder {
  public:
    using table_type = basic_stored_table&lt;Content, Allocator>;
    using char_type = typename table_type::char_type;

    <c>// <n><xref id="stored_table_builder.cons"/>, construct/copy/destroy:</n></c>
    explicit stored_table_builder(table_type&amp; table);
    stored_table_builder(stored_table_builder&amp;&amp; other) noexcept;
   ~stored_table_builder();

    <c>// <n>six member functions below are declared and defined to meet the TextHandler</n>
    // <n>requirements (<xref id="text_handler.requirements"/>):</n></c>
    std::pair&lt;char_type*, std::size_t> get_buffer();
    void release_buffer(const char_type* buffer) noexcept;
    void start_record(const char_type* record_begin);
    void end_record(const char_type* record_end);
    void update(const char_type* first, const char_type* last);
    void finalize(const char_type* first, const char_type* last);
  };
}
      </codeblock>

      <p>The class template <c>stored_table_builder</c> is a tool to create an image of a table of a text into a <c>basic_stored_table</c> (<xref id="basic_stored_table"/>) object, which is called the <n>targeted object</n>.
         An instantiation of it satisfies the <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>) for <c>char_type</c>.
         An object of an instantiation of it can not be reused; that is, it can receive the parsing events that the parser emits only once.</p>

      <p>The template parameters <c>Content</c> and <c>Allocator</c> shall be types that make <c>basic_stored_table&lt;Content, Allocator></c> a valid type.</p>

      <p>The template parameter <c>Options</c> is a bitmask to control the behavior of the builder.
         Its effects are described in <xref id="table.stored_table_builder.options"/>.
         In it, <c>c</c> denotes an lvalue reference to <c>content()</c> of the targeted object and <c>s</c> does the value that <c>c.size()</c> had before the parsing.
         Indices <c>i</c> and <c>j</c> are zero-based.
         In addition, <c>operator[]</c> and <c>operator+</c> are used on types that do not necessarily have them well-defined.
         In these cases, the semaintics of <c>d[n]</c> and <c>p + n</c> is the same as that of <c>*std::next(d.begin(), n)</c> and <c>std::next(p, n)</c> respectively.</p>

      <table id="table.stored_table_builder.options">
        <caption><c>stored_table_builder</c> options</caption>
        <col width="3"/><col width="5"/>

        <tr>
          <th>Condition</th>
          <th>Effects</th>
        </tr>

        <tr>
          <td><c>(Options &amp; stored_table_builder_option_transpose) == 0</c></td>
          <td>The value of the <c>j</c>-th field of the <c>i</c>-th record of the text shall be arranged into <c>c[s + i][j]</c>.</td>
        </tr>

        <tr>
          <td><c>(Options &amp; stored_table_builder_option_transpose) != 0</c></td>
          <td>The value of the <c>j</c>-th field of the <c>i</c>-th record of the text shall be arranged into <c>c[j][s + i]</c>.
              On each arrangement, the range [<c>c[j].begin() + e</c>, <c>c[j].begin() + (s + i)</c>) shall be filled by empty values where <c>e</c> is the value that <c>c[j].size()</c> had before the arrangement.</td>
        </tr>
      </table>

      <p>After parsing, even when it has exited via an exception, the targeted object shall be complete and not singular (<xref id="basic_stored_table.defs"/>).</p>

      <section id="stored_table_builder.cons">
        <name><c>stored_table_builder</c> construct/copy/destroy</name>
        <code-item>
          <code>
explicit stored_table_builder(table_type&amp; table);
          </code>
          <requires><c>table</c> shall not be singular.</requires>
          <effects>Initializes an object of <c>stored_table_builder&lt;Content, Allocator, Options></c> that holds a reference to the targeted object <c>table</c>.</effects>
          <remark><c>table.empty()</c> may be <c>false</c>. This constructor does nothing on the targeted object.</remark>
        </code-item>

        <code-item>
          <code>
stored_table_builder(stored_table_builder&amp;&amp; other) noexcept;
          </code>
          <effects>Initializes an object of <c>stored_table_builder&lt;Content, Allocator, Options></c> that holds the same reference to the targeted object as <c>other</c>.</effects>
          <remark>This constructor does nothing on the targeted object.</remark>
        </code-item>

        <code-item>
          <code>
~stored_table_builder();
          </code>
          <remark>This destructor does nothing on the targeted object.</remark>
        </code-item>
      </section>

      <section id="stored_table_builder.creation">
        <name><c>stored_table_builder</c> creation functions</name>

        <code-item>
          <code>
template &lt;class Content, class Allocator>
  <nc>see below</nc> make_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table);
          </code>
          <returns><c>stored_table_builder&lt;Content, Allocator>(table)</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class Content, class Allocator>
  <nc>see below</nc> make_transposed_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table);
          </code>
          <returns><c>stored_table_builder&lt;Content, Allocator, stored_table_builder_option_transpose>(table)</c>.</returns>
        </code-item>
      </section>
    </section>
  </section>

  <section id="scanner">
    <name>One-pass scanning operation</name>

    <section id="scanner.table">
      <name>The table scanner</name>

      <section id="scanner.table.general">
        <name>General</name>

        <p>Commata offers a <n>table scanner</n> class template, whose name is <c>basic_table_scanner</c> (<xref id="basic_table_scanner"/>), whose instances meet the <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>) as a simple facility for one-pass scanning of texts.</p>
        <p>A table scanner object can hold a <n>body field scanner</n> object for each field to which it forwards the field values, and it can hold a <n>record-end scanner</n> object to which it noitifies the end-of-record events.</p>
        <p>In addition, a table scanner object can be configured to recognize some first records as &#x201c;header&#x201d; records. It can simply ignore the header records or can forward the field values in the header to a <n>header field scanner</n> object it holds optionally.</p>
        <p>Properties that the type of the body field scanners shall meet, type of the record-end scanners shall meet, and the type of the header field scanners shall meet are bundled as
           the <c>BodyFieldScanner</c>, the <c>RecordEndScanner</c> and the <c>HeaderFieldScanner</c> requirements respectively.</p>
      </section>

      <section id="field_scanner.requirements">
        <name><c>BodyFieldScanner</c> requirements</name>

        <p>A type <c>S</c> meets the <c>BodyFieldScanner</c> requirements for <c>Ch</c> that is a char-like type, <c>Tr</c> that is a character traits type of <c>Ch</c>, and <c>Allocator</c> that is an allocator type of <c>Ch</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expressions shown in <xref id="table.field_scanner.requirements"/> are valid and have the indidated semantics.</li>
        </ul>

        <p>In <xref id="table.field_scanner.requirements"/>, <c>s</c> is an lvalue of cv-unqualified <c>S</c>.
           <c>b</c> and <c>e</c> are rvalues of <c>Ch*</c>.
           <c>rv</c> is an rvalue of <c>std::basic_string&lt;Ch, Tr, Allocator></c>.</p>

        <p>Requirements shown as (1) and (2) in <xref id="table.field_scanner.requirements"/> are optional, but at least one of (1) or (2) shall be satisfied without falling back to the default behaviors, because they are defined in a cross-referencing manner.</p>

        <table id="table.field_scanner.requirements">
          <caption><c>BodyFieldScanner</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="10"/><col width="6"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return Type</th>
            <th>Remark</th>
            <th>Default Behavior</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>s.field_value(b, e)</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has finalized a text value of the field of a body record.
                The value of the field is [<c>b</c>, <c>e</c>), and <c>e</c> is dereferenceable and points the terminating zero. It is unspecified which of (1) and (2) the table scanner calls.</td>
            <td>Creates an <c>std::basic_string&lt;Ch, Tr, Allocator></c> object with the range [<c>b</c>, <c>e</c>) and the table scanner’s allocator, and then calls (2) with it.</td>
          </tr>

          <tr>
            <td>(2)</td>
            <td><c>s.field_value(rv)</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has finalized a text value of the field of a body record. The value of the field is <c>rv</c>.</td>
            <td>Calls (1) with <c>&amp;*rv.begin()</c> and <c>&amp;*rv.begin() + rv.size()</c>.</td>
          </tr>

          <tr>
            <td>(3)</td>
            <td><c>s.field_skipped()</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has found that the field does not appear in the body record, that is, the record has too few fields to reach the field.</td>
            <td></td>
          </tr>
        </table>
      </section>

      <section id="record_end_scanner.requirements">
        <name><c>RecordEndScanner</c> requirements</name>

        <p>A type <c>S</c> meets the <c>RecordEndScanner</c> requirements if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expression shown in <xref id="table.record_end_scanner.requirements"/> is valid and have the indidated semantics.</li>
        </ul>

        <p>In <xref id="table.record_end_scanner.requirements"/>, <c>s</c> is an lvalue of cv-unqualified <c>S</c>.</p>

        <table id="table.record_end_scanner.requirements">
          <caption><c>RecordEndScanner</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="16"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return Type</th>
            <th>Remark</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>s()</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has met an end of a body record.</td>
          </tr>
        </table>
      </section>

      <section id="header_field_scanner.requirements">
        <name><c>HeaderFieldScanner</c> requirements</name>

        <p>A type <c>S</c> meets the <c>HeaderFieldScanner</c> requirements for a char-like type <c>Ch</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expression shown in <xref id="table.header_field_scanner.requirements"/> is valid and have the indidated semantics.</li>
        </ul>

        <p>In <xref id="table.header_field_scanner.requirements"/>, <c>s</c> is an lvalue of cv-unqualified <c>S</c>.
           The type of <c>j</c> is <c>std::size_t</c>.
           The type of <c>v</c> is <c>const std::pair&lt;Ch*, Ch*>*</c>.
           <c>t</c> is an lvalue of the corresponding cv-unqualified <c>basic_table_scanner</c> (<xref id="basic_table_scanner"/>) object, the first template argument of the type of which is <c>Ch</c>.</p>

        <table id="table.header_field_scanner.requirements">
          <caption><c>HeaderFieldScanner</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="16"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return Type</th>
            <th>Remark</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>s(j, v, t)</c></td>
            <td>Contextually convertible to <c>bool</c></td>
            <td>Called by the table scanner in two situations following.
                <ul>
                  <li>When the table scanner has finalized a value of the header field. <c>j</c> is the zero-based field index.
                      The value of the header field is [<c>v->first</c>, <c>v->second</c>), and <c>v->second</c> is dereferenceable and points a null character.</li>
                  <li>When a record in the header has ended. <c>j</c> is the number of the fields in the records. <c>v</c> is a null pointer.</li>
                </ul>
                In any of cases, when <c>!r</c> is not <c>false</c> where <c>r</c> is the return value of this, the table scanner shall uninstall this header field scanner and recognizes that the current record is the final header record, that is, the next record will the first body record.</td>
          </tr>
        </table>
      </section>
    </section>

    <section id="scanner.builtin_field_scanners">
      <name>Default field scanners</name>
    
      <section id="scanner.builtin_field_scanners.general">
        <name>General</name>

        <p>The Commata library offers three default body field scanner types that meet the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>):
           <c>arithmetic_field_translator</c> (<xref id="arithmetic_field_translator"/>), <c>locale_based_arithmetic_field_translator</c> (<xref id="locale_based_arithmetic_field_translator"/>) and <c>string_field_translator</c> (<xref id="string_field_translator"/>).</p>
        <p>An object of these types <n>translates</n> a field value into a value of its <n>target type</n> and forwards it into its installed <n>sink</n>.</p>
        <p>Behaviors of these default body scanner objects can be customized through the three concepts: <c>FieldTranslatorSink</c> (<xref id="field_translator_sink.requirements"/>), <c>SkippingHandler</c> (<xref id="skipping_handler.requirements"/>) and <c>ConversionErrorHandler</c> (<xref id="conversion_error_handler.requirements"/>).</p>
      </section>

      <section id="field_translator_sink.requirements">
        <name><c>FieldTranslatorSink</c> requirements</name>

        <p>A type <c>S</c> is a <c>FieldTranslatorSink</c> type for the target type <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>it is an output iterator type for the type <c>T</c> or a callable type for an argument of an rvalue of cv-unqualified <c>T</c>.</li>
        </ul>

        <p>To <n>put</n> an object expressed by an rvalue <c>rt</c> of the cv-unqualified type <c>T</c> to an object expressed by an lvalue <c>s</c> of the cv-unqualified type <c>S</c> that is a <c>FieldTranslatorSink</c> type is:</p>
        <ul>
          <li>if <c>S</c> is an output iterator type, to evaluate <c>*s = rt</c>,</li>
          <li>otherwise, to evaluate <c>s(rt)</c>.</li>
        </ul>
      </section>

      <section id="skipping_handler.requirements">
        <name><c>SkippingHandler</c> requirements</name>

        <p>A type <c>H</c> meets the <c>SkippingHandler</c> requirements for the target type <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expression shown in <xref id="table.skipping_handler.requirements"/> is valid and have the indidated semantics.</li>
        </ul>

        <p><xref id="table.skipping_handler.requirements"/> shows two expressions per row.
           It is required that at least one of these two expression qualifies, that is, it is not needed that both of two do.</p>

        <p>In <xref id="table.skipping_handler.requirements"/>, <c>h</c> is an lvalue of cv-unqualified <c>H</c>.
           <c>n</c> is a null pointer whose type is <c>T*</c>.</p>

        <table id="table.skipping_handler.requirements">
          <caption><c>SkippingHandler</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="15"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return Type</th>
            <th>Remark</th>
          </tr>

          <tr>
            <td rowspan="2">(1)</td>
            <td><c>h()</c></td>
            <td rowspan="2"><c>replacement&lt;T></c></td>
            <td rowspan="2">Called when the corresponding field has been skipped, that is, the record has had too few fields to reach the field.
                If <c>r.get()</c> is not <c>nullptr</c> where <c>r</c> is the return value, the translated value of the field shall be constructed from <c>std::move(*r)</c>;
                otherwise, no values shall be put to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td><c>h(n)</c></td>
          </tr>
        </table>
      </section>

      <section id="conversion_error_handler.requirements">
        <name><c>ConversionErrorHandler</c> requirements</name>

        <p>A type <c>H</c> meets the <c>ConversionErrorHandler</c> requirements for a char-like type <c>Ch</c> and the target type <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expressions shown in <xref id="table.conversion_error_handler.requirements"/> are valid and have the indidated semantics.</li>
        </ul>

        <p><xref id="table.conversion_error_handler.requirements"/> shows two expressions per row.
           It is required that at least one of these two expression qualifies, that is, it is not needed that both of two do.</p>

        <p>In <xref id="table.conversion_error_handler.requirements"/>, <c>h</c> is an lvalue of cv-unqualified <c>H</c>.
           <c>b</c> and <c>e</c> are pointers to cv-unqualified <c>Ch</c>.
           The range [<c>b</c>, <c>e</c>) is the value of the field.
           <c>e</c> can be dereferenced and points the terminating zero.
           The type of <c>s</c> is <c>int</c>.
           <c>n</c> is a null pointer whose type is <c>T*</c>.</p>

        <table id="table.conversion_error_handler.requirements">
          <caption><c>ConversionErrorHandler</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="15"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return Type</th>
            <th>Remark</th>
          </tr>

          <tr>
            <td rowspan="2">(1)</td>
            <td><c>h.invalid_format(b, e)</c></td>
            <td rowspan="2"><c>replacement&lt;T></c></td>
            <td rowspan="2">Called when the corresponding field has a value that can not be converted a value of <c>T</c> due to a format error.
                If <c>r.get()</c> is not <c>nullptr</c> where <c>r</c> is the return value, the translated value of the field shall be constructed from <c>std::move(*r)</c>;
                otherwise, no values shall be put to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td><c>h.invalid_format(b, e, n)</c></td>
          </tr>

          <tr>
            <td rowspan="2">(2)</td>
            <td><c>h.out_of_range(b, e, s)</c></td>
            <td rowspan="2"><c>replacement&lt;T></c></td>
            <td rowspan="2">Called when the corresponding field has a value that can not be converted a value of <c>T</c> due to a range error.
                <c>s</c> shall has a positive value if the field value should be translated into a value above the domain of <c>T</c>, a negative value if the field value should be translated into a value below the domain of <c>T</c>, or <c>0</c> otherwise.
                If <c>r.get()</c> is not <c>nullptr</c> where <c>r</c> is the return value, the translated value of the field shall be constructed from <c>std::move(*r)</c>;
                otherwise, no values shall be put to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td><c>h.out_of_range(b, e, s, n)</c></td>
          </tr>

          <tr>
            <td rowspan="2">(3)</td>
            <td><c>h.empty()</c></td>
            <td rowspan="2"><c>replacement&lt;T></c></td>
            <td rowspan="2">Called when the corresponding field has a value that is empty.
                If <c>r.get()</c> is not <c>nullptr</c> where <c>r</c> is the return value, the translated value of the field shall be constructed from <c>std::move(*r)</c>;
                otherwise, no values shall be put to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td><c>h.empty(n)</c></td>
          </tr>
        </table>
      </section>
    </section>

    <section id="table_scanner_hpp">
      <name>Header <c>"table_scanner.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;locale>
#include &lt;memory>
#include &lt;string>
#include &lt;typeinfo>
#include &lt;utility>

#include "text_error.hpp"

namespace commata {
  <c>// <n><xref id="basic_table_scanner"/>, basic_table_scanner:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class basic_table_scanner;

  using table_scanner = basic_table_scanner&lt;char>;
  using wtable_scanner = basic_table_scanner&lt;wchar_t>;

  <c>// <n><xref id="scanner.builtin.exceptions"/>, exception classes:</n></c>
  class field_translation_error : public text_error;
    class field_not_found : public field_translation_error;
    class field_invalid_format : public field_translation_error;
      class field_empty : public field_invalid_format;
    class field_out_of_range : public field_translation_error;

  struct replacement_ignore_t {};
  constexpr replacement_ignore_t replacement_ignore = replacement_ignore_t{};

  <c>// <n><xref id="replacement"/>, replacement:</n></c>
  template &lt;class T> class replacement;

  struct replacement_fail_t {};
  constexpr replacement_fail_t replacement_fail = replacement_fail_t{};

  <c>// <n><xref id="scanner.builtin.skipping_handlers"/>, default skipping handler classes:</n></c>
  struct fail_if_skipped;
  template &lt;class T> class replace_if_skipped;

  <c>// <n><xref id="scanner.builtin.conversion_error_handlers"/>, default conversion error handler classes:</n></c>
  struct fail_if_conversion_failed;
  template &lt;class T> class replace_if_conversion_failed;

  <c>// <n><xref id="arithmetic_field_translator"/>, arithmetic_field_translator:</n></c>
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class arithmetic_field_translator;

  <c>// <n><xref id="locale_based_arithmetic_field_translator"/>, locale_based_arithmetic_field_translator:</n></c>
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class locale_based_arithmetic_field_translator;

  <c>// <n><xref id="string_field_translator"/>, string_field_translator:</n></c>
  template &lt;class Sink, class Ch, class Tr = std::char_traits&lt;Ch>,
            class Allocator = std::allocator&lt;Ch>,
            class SkippingHandler = fail_if_skipped&lt;std::basic_string&lt;Ch, Tr, Allocator>>>
    class string_field_translator;

  <c>// <n><xref id="make_field_translator"/>, creation of default field scanners:</n></c>
  template &lt;class T, class Sink, class... Appendices>
    <nc>see below</nc> make_field_translator(Sink sink, Appendices&amp;&amp;... appendices);
  template &lt;class T, class Allocator, class Sink, class... Appendices>
    <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                    Sink sink, Appendices&amp;&amp;... appendices);
  template &lt;class Container, class... Appendices>
    <nc>see below</nc> make_field_translator(Container&amp; values, Appendices&amp;&amp;... appendices);
  template &lt;class Allocator, class Container, class... Appendices>
    <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                    Container&amp; values, Appendices&amp;&amp;... appendices);
}
      </codeblock>
    </section>

    <section id="basic_table_scanner">
      <name>Class template <c>basic_table_scanner</c></name>

      <section id="basic_table_scanner.overview">
        <name>Class template <c>basic_table_scanner</c> overview</name>

        <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class basic_table_scanner {
  public:
    using char_type = Ch;
    using allocator_type = Allocator;
    using size_type = typename std::allocator_traits&lt;Allocator>::size_type;

    <c>// <n><xref id="basic_table_scanner.cons"/>, construction:</n></c>
    explicit basic_table_scanner(std::size_t header_record_count = 0, size_type buffer_size = 0);
    basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                        std::size_t header_record_count = 0, size_type buffer_size = 0);
    template &lt;class HeaderFieldScanner>
      explicit basic_table_scanner(HeaderFieldScanner s, size_type buffer_size = 0);
    template &lt;class HeaderFieldScanner>
      basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                          HeaderFieldScanner s, size_type buffer_size = 0);
    basic_table_scanner(basic_table_scanner&amp;&amp; other) noexcept;

   ~basic_table_scanner();

    <c>// <n><xref id="basic_table_scanner.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="basic_table_scanner.field_scanner_access"/>, body field scanner access:</n></c>
    template &lt;class T = std::nullptr_t> void set_field_scanner(std::size_t j, T s = T());
    bool has_field_scanner(std::size_t j) const noexcept;
    const std::type_info&amp; get_field_scanner_type(std::size_t j) const noexcept;
    template &lt;class T> const T* get_field_scanner(std::size_t j) const noexcept;
    template &lt;class T>       T* get_field_scanner(std::size_t j)       noexcept;

    <c>// <n><xref id="basic_table_scanner.record_end_scanner_access"/>, record-end scanner access:</n></c>
    template &lt;class T = std::nullptr_t> void set_record_end_scanner(T s = T());
    bool has_record_end_scanner() const noexcept;
    const std::type_info&amp; get_record_end_scanner_type() const noexcept;
    template &lt;class T> const T* get_record_end_scanner() const noexcept;
    template &lt;class T>       T* get_record_end_scanner()       noexcept;

    <c>// <n>six member functions below are declared and defined to meet the TextHandler</n>
    // <n>requirements (<xref id="text_handler.requirements"/>):</n></c>
    std::pair&lt;Ch*, std::size_t> get_buffer();
    void release_buffer(const Ch* buffer);
    void start_record(const Ch* record_begin);
    void end_record(const Ch* record_end);
    void update(const Ch* first, const Ch* last);
    void finalize(const Ch* first, const Ch* last);
  };
}
        </codeblock>

        <p>The class template <c>basic_table_scanner</c> describes the table scanner objects (<xref id="scanner.table.general"/>).
           An instantiation of it satisfies the <c>TextHandler</c> requirements (<xref id="text_handler.requirements"/>) for the template parameter <c>Ch</c>.
           An object of an instantiation of it can not be reused; that is, it can receive the parsing events that the parser emits only once.</p>
        <p>The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements and <c>Allocator::value_type</c> shall be a type identical to <c>Ch</c>.</p>
      </section>

      <section id="basic_table_scanner.cons">
        <name><c>basic_table_scanner</c> construction</name>

        <code-item>
          <code>
explicit basic_table_scanner(std::size_t header_record_count = 0, size_type buffer_size = 0);
basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                    std::size_t header_record_count = 0, size_type buffer_size = 0);
          </code>
          <effects>Constructs an object of <c>basic_table_scanner</c>.
                   The scanner shall ignore the first <c>header_record_count</c> records as header records.
                   The length of the buffer allocated by <c>get_buffer</c> is unspecified, but <c>buffer_size</c> serves as a hint. <c>buffer_size</c> can be equal to zero, which means &#x201c;no hint.&#x201d;
                   The scanner shall allocate and deallocate memory with a default-constructed <c>Allocator</c> object (first overload) or a copy of <c>alloc</c> (second overload).</effects>
          <postcondition><c>*this</c> has neither a header field scanner nor any body field scanners installed.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class HeaderFieldScanner>
  explicit basic_table_scanner(HeaderFieldScanner s, size_type buffer_size = 0);
template &lt;class HeaderFieldScanner>
  basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                      HeaderFieldScanner s, size_type buffer_size = 0);
          </code>
          <requires><c>HeaderFieldScanner</c> shall meet the <c>HeaderFieldScanner</c> requirements (<xref id="header_field_scanner.requirements"/>) for <c>Ch</c>.</requires>
          <effects>Constructs an object of <c>basic_table_scanner</c> with an header field scanner object installed.
                   The length of the buffer allocated by <c>get_buffer</c> is unspecified, but <c>buffer_size</c> serves as a hint. <c>buffer_size</c> can be equal to zero, which means &#x201c;no hint.&#x201d;
                   The scanner shall allocate and deallocate memory with a default-constructed <c>Allocator</c> object (first overload) or a copy of <c>alloc</c> (second overload).</effects>
          <postcondition><c>*this</c> has a header field scanner constructed as a copy of <c>s</c> installed and no body field scanners installed.</postcondition>
          <remark>These constructors shall not participate in overload resolution unless <c>std::is_integral&lt;HeaderFieldScanner>::value</c> is <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="basic_table_scanner.allocator">
        <name><c>basic_table_scanner</c> allocator access</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object held by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="basic_table_scanner.field_scanner_access">
        <name><c>basic_table_scanner</c> body field scanner access</name>

        <code-item>
          <code>
template &lt;class T = std::nullptr_t> void set_field_scanner(std::size_t j, T s = T());
          </code>
          <requires><c>T</c> shall either of be (possibly cv-qualified) <c>std::nullptr_t</c>,
                    meet the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>) for <c>Ch</c>, <c>Tr</c> and <c>Allocator</c>, or
                    (possibly cv-qualified) <c>std::reference_wrapper&lt;U></c> where <c>U</c> shall be a type that meets the <c>BodyFieldScanner</c> requirements for <c>Ch</c> and <c>Tr</c> except that it need not be either <c>MoveConstructible</c> or <c>Destructible</c>.</requires>
          <effects>First if <c>*this</c> has a body field scanner installed at zero-based field index <c>j</c>, uninstalls it.
                   Then if <c>T</c> is (possibly cv-qualified) <c>std::nullptr_t</c>, returns immediately.
                   Otherwise, installs a copy of <c>s</c> as a body field scanner at zero-based field index <c>j</c>.</effects>
          <remark>If an exception is thrown by this function, this function has no effects.</remark>
        </code-item>

        <code-item>
          <code>
bool has_field_scanner(std::size_t j) const noexcept;
          </code>
          <returns>If <c>*this</c> has a body field scanner installed at zero-based field index <c>j</c>, <c>true</c>; otherwise, <c>false</c>.</returns>
        </code-item>

        <code-item>
          <code>
const std::type_info&amp; get_field_scanner_type(std::size_t j) const noexcept;
          </code>
          <returns>If <c>*this</c> has a body field scanner of type <c>T</c> installed at zero-based field index <c>j</c>, <c>typeid(T)</c>; otherwise, <c>typeid(void)</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class T> const T* get_field_scanner(std::size_t j) const noexcept;
template &lt;class T>       T* get_field_scanner(std::size_t j)       noexcept;
          </code>
          <returns>If <c>get_field_scanner_type(j) == typeid(T)</c>, a pointer to the body field scanner object installed at zero-based field index <c>j</c>; otherwise, a null pointer.</returns>
        </code-item>
      </section>

      <section id="basic_table_scanner.record_end_scanner_access">
        <name><c>basic_table_scanner</c> record-end scanner access</name>

        <code-item>
          <code>
template &lt;class T = std::nullptr_t> void set_record_end_scanner(T s = T());
          </code>
          <requires><c>T</c> shall be (possibly cv-qualified) <c>std::nullptr_t</c> or meet the <c>RecordEndScanner</c> requirements (<xref id="record_end_scanner.requirements"/>).</requires>
          <effects>First if <c>*this</c> has a record-end scanner installed, uninstalls it.
                   Then if <c>T</c> is (possibly cv-qualified) <c>std::nullptr_t</c>, returns immediately.
                   Otherwise, then installs a copy of <c>s</c> as a record-end scanner.</effects>
          <remark>If an exception is thrown by this function, this function has no effects.</remark>
        </code-item>

        <code-item>
          <code>
bool has_record_end_scanner() const noexcept;
          </code>
          <returns>If <c>*this</c> has a record-end scanner installed, <c>true</c>; otherwise, <c>false</c>.</returns>
        </code-item>

        <code-item>
          <code>
const std::type_info&amp; get_record_end_scanner_type() const noexcept;
          </code>
          <returns>If <c>*this</c> has a record-end scanner of type <c>T</c> installed, <c>typeid(T)</c>; otherwise, <c>typeid(void)</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class T> const T* get_record_end_scanner() const noexcept;
template &lt;class T>       T* get_record_end_scanner()       noexcept;
          </code>
          <returns>If <c>get_record_end_scanner_type() == typeid(T)</c>, a pointer to the record-end scanner object installed; otherwise, a null pointer.</returns>
        </code-item>
      </section>
    </section>

    <section id="scanner.builtin.exceptions">
      <name>Exception classes</name>

      <section id="field_translation_error">
        <name>Class <c>field_translation_error</c></name>

        <codeblock>
namespace commata {
  class field_translation_error : public text_error {
  public:
    template &lt;class T>
      explicit field_translation_error(T&amp;&amp; what_arg);
  };
}
        </codeblock>

        <p>The class <c>field_translation_error</c> defines the type of the objects thrown by default field scanners of Commata library.</p>

        <code-item>
          <code>
template &lt;class T>
  explicit field_translation_error(T&amp;&amp; what_arg);
          </code>
          <effects>Constructs an object of <c>field_translation_error</c>.</effects>
          <postcondition><c>(std::strcmp(w.c_str(), what()) == 0) &amp;&amp; (get_physical_position() == nullptr)</c> shall not be <c>false</c> where <c>w</c> is an object that would be constructed by <c>std::string(std::forward&lt;T>(what_arg>))</c>.</postcondition>
          <remark>This constructor shall not participate in overload resolution unless <c>std::is_constructible&lt;std::string, T&amp;&amp;>::value</c> is not <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="field_not_found">
        <name>Class <c>field_not_found</c></name>

        <codeblock>
namespace commata {
  class field_not_found : public field_translation_error {
  public:
    template &lt;class T>
      explicit field_not_found(T&amp;&amp; what_arg);
  };
}
        </codeblock>

        <p>The class <c>field_not_found</c> defines the type of the objects thrown by default field scanners of Commata library to report that a record that has too few fields to reach the field scanner concerned was found.</p>

        <code-item>
          <code>
template &lt;class T>
  explicit field_not_found(T&amp;&amp; what_arg);
          </code>
          <effects>Constructs an object of <c>field_not_found</c>.</effects>
          <postcondition><c>(std::strcmp(w.c_str(), what()) == 0) &amp;&amp; (get_physical_position() == nullptr)</c> shall not be <c>false</c> where <c>w</c> is an object that would be constructed by <c>std::string(std::forward&lt;T>(what_arg>))</c>.</postcondition>
            <remark>This constructor shall not participate in overload resolution unless <c>std::is_constructible&lt;std::string, T&amp;&amp;>::value</c> is not <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="field_invalid_format">
        <name>Class <c>field_invalid_format</c></name>

        <codeblock>
namespace commata {
  class field_invalid_format : public field_translation_error {
  public:
    template &lt;class T>
      explicit field_invalid_format(T&amp;&amp; what_arg);
  };
}
        </codeblock>

        <p>The class <c>field_invalid_format</c> defines the type of the objects thrown by default field scanners of Commata library to report field format errors.</p>

        <code-item>
          <code>
template &lt;class T>
  explicit field_invalid_format(T&amp;&amp; what_arg);
          </code>
          <effects>Constructs an object of <c>field_invalid_format</c>.</effects>
          <postcondition><c>(std::strcmp(w.c_str(), what()) == 0) &amp;&amp; (get_physical_position() == nullptr)</c> shall not be <c>false</c> where <c>w</c> is an object that would be constructed by <c>std::string(std::forward&lt;T>(what_arg>))</c>.</postcondition>
          <remark>This constructor shall not participate in overload resolution unless <c>std::is_constructible&lt;std::string, T&amp;&amp;>::value</c> is not <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="field_empty">
        <name>Class <c>field_empty</c></name>

        <codeblock>
namespace commata {
  class field_empty : public field_invalid_format {
  public:
    template &lt;class T>
      explicit field_empty(T&amp;&amp; what_arg);
  };
}
        </codeblock>

        <p>The class <c>field_empty</c> defines the type of the objects thrown by default field scanners of Commata library to report an empty field.</p>

        <code-item>
          <code>
template &lt;class T>
  explicit field_empty(T&amp;&amp; what_arg);
          </code>
          <effects>Constructs an object of <c>field_empty</c>.</effects>
          <postcondition><c>(std::strcmp(w.c_str(), what()) == 0) &amp;&amp; (get_physical_position() == nullptr)</c> shall not be <c>false</c> where <c>w</c> is an object that would be constructed by <c>std::string(std::forward&lt;T>(what_arg>))</c>.</postcondition>
          <remark>This constructor shall not participate in overload resolution unless <c>std::is_constructible&lt;std::string, T&amp;&amp;>::value</c> is not <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="field_out_of_range">
        <name>Class <c>field_out_of_range</c></name>

        <codeblock>
namespace commata {
  class field_out_of_range : public field_translation_error {
  public:
    template &lt;class T>
      explicit field_out_of_range(T&amp;&amp; what_arg);
  };
}
        </codeblock>

        <p>The class <c>field_out_of_range</c> defines the type of the objects thrown by default field scanners of Commata library to report they found a translated field value out of its domain.</p>

        <code-item>
          <code>
template &lt;class T>
  explicit field_out_of_range(T&amp;&amp; what_arg);
          </code>
          <effects>Constructs an object of <c>field_out_of_range</c>.</effects>
          <postcondition><c>(std::strcmp(w.c_str(), what()) == 0) &amp;&amp; (get_physical_position() == nullptr)</c> shall not be <c>false</c> where <c>w</c> is an object that would be constructed by <c>std::string(std::forward&lt;T>(what_arg>))</c>.</postcondition>
          <remark>This constructor shall not participate in overload resolution unless <c>std::is_constructible&lt;std::string, T&amp;&amp;>::value</c> is not <c>false</c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="replacement">
      <name>Class template <c>replacement</c></name>

      <codeblock>
namespace commata {
  template &lt;class T> class replacement {
  public:
    using value_type = T;

    replacement() noexcept;
    replacement(replacement_ignore_t) noexcept;
    explicit replacement(const T&amp; t);
    explicit replacement(T&amp;&amp; t) noexcept(<nc>see below</nc>);
    replacement(replacement&amp;&amp; other) noexcept(<nc>see below</nc>);
    template &lt;class U> replacement(replacement&lt;U>&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~replacement();

    const T* get() const noexcept;
          T* get() noexcept;
    const T&amp; operator*() const;
          T&amp; operator*();
    const T* operator->() const;
          T* operator->();
  };
}
      </codeblock>

      <p>The class template <c>replacement</c> offers types an object of which is able either to contain a value or not to contain a value.
         This class template is used to define <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>).</p>
      <p><c>T</c> shall not be a reference type and shall satisfy the <c>Destructible</c> requirements.</p>

      <code-item>
        <code>
replacement() noexcept;
replacement(replacement_ignore_t) noexcept;
        </code>
        <postcondition><c>*this</c> shall not contain a value.</postcondition>
      </code-item>

      <code-item>
        <code>
explicit replacement(const T&amp; t);
        </code>
        <requires><c>T</c> shall be <c>CopyConstructible</c>.</requires>
        <postcondition><c>*this</c> shall contain a value constructed from <c>t</c>.</postcondition>
      </code-item>

      <code-item>
        <code>
explicit replacement(T&amp;&amp; t) noexcept(<nc>see below</nc>);
        </code>
        <requires><c>T</c> shall be <c>MoveConstructible</c>.</requires>
        <postcondition><c>*this</c> shall contain a value constructed from <c>std::move(t)</c>.</postcondition>
        <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value</c>.</remark>
      </code-item>

      <code-item>
        <code>
replacement(replacement&amp;&amp; other) noexcept(<nc>see below</nc>);
        </code>
        <requires><c>T</c> shall be <c>MoveConstructible</c>.</requires>
        <effects>If <c>other</c> contains a value, constructs the contained value of <c>*this</c> from <c>std::move(*other)</c>.</effects>
        <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value</c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class U> replacement(replacement&lt;U>&amp;&amp; other) noexcept(<nc>see below</nc>);
        </code>
        <requires><c>std::is_constructible&lt;T, U&amp;&amp;>::value</c> shall be not <c>false</c>.</requires>
        <effects>If <c>other</c> contains a value, constructs the contained value of <c>*this</c> from <c>std::move(*other)</c>.</effects>
        <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;T, U&amp;&amp;>::value</c>.</remark>
      </code-item>

      <code-item>
        <code>
const T* get() const noexcept;
      T* get() noexcept;
        </code>
        <returns>A pointer that points the contained value of <c>*this</c>. If none is contained, <c>nullptr</c>.</returns>
      </code-item>

      <code-item>
        <code>
const T&amp; operator*() const;
      T&amp; operator*();
        </code>
        <requires><c>get() == nullptr</c> shall be <c>false</c>.</requires>
        <returns><c>*get()</c>.</returns>
      </code-item>

      <code-item>
        <code>
const T* operator->() const;
      T* operator->();
        </code>
        <requires><c>get() == nullptr</c> shall be <c>false</c>.</requires>
        <returns><c>get()</c>.</returns>
      </code-item>
    </section>

    <section id="scanner.builtin.skipping_handlers">
      <name>Default skipping handler classes</name>

      <section id="fail_if_skipped">
        <name>Struct <c>fail_if_skipped</c></name>

        <codeblock>
namespace commata {
  struct fail_if_skipped {
    template &lt;class T> [[noreturn]] replacement&lt;T> operator()(T*) const;
  };
}
        </codeblock>

        <p>The struct <c>fail_if_skipped</c> is a type that meets the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>).
           An object of them makes the parsing process fail when the corresponding field is not found in a record.</p>

        <code-item>
          <code>
template &lt;class T> [[noreturn]] replacement&lt;T> operator()(T*) const;
          </code>
          <effects>Throws an object of <c>field_not_found</c> (<xref id="field_not_found"/>).</effects>
        </code-item>
      </section>

      <section id="replace_if_skipped">
        <name>Class template <c>replace_if_skipped</c></name>

        <codeblock>
namespace commata {
  template &lt;class T> class replace_if_skipped {
  public:
    explicit replace_if_skipped(replacement_fail_t) noexcept;
    explicit replace_if_skipped(replacement_ignore_t) noexcept;
    template &lt;class U = T> explicit replace_if_skipped(U&amp;&amp; default_value = U());
    replace_if_skipped(const replace_if_skipped&amp; other);
    replace_if_skipped(replace_if_skipped&amp;&amp; other) noexcept;
   ~replace_if_skipped();

    replacement&lt;T> operator()() const;
  };
}
        </codeblock>

        <p>The class template <c>replace_if_skipped</c> offers types that meet the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>).
           An object of them supplements the corresponding field that is not found in a record with a fixed value.</p>
        <p><c>T</c> shall be <c>CopyConstructible</c>.</p>
        <p>An object of <c>replace_if_skipped</c> has a <n>replacement action</n>.
           A replacement action can be configured to be either of the three types illustrated in <xref id="table.replace_if_skipped.replacement_actions"/>.</p>

        <table id="table.replace_if_skipped.replacement_actions">
          <caption>Types of replacement actions</caption>
          <col width="1"/><col width="2"/><col width="27"/>

          <tr>
            <th>#</th>
            <th>Type</th>
            <th>Effects</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>copy</c></td>
            <td>Copy-constructs an object of <c>T</c> from an object installed into this replacement action and put it to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td>(2)</td>
            <td><c>ignore</c></td>
            <td>Silently ignores the conversion error without doing anything on the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td>(3)</td>
            <td><c>fail</c></td>
            <td>Throws an exception without doing anything on the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>
        </table>

        <code-item>
          <code>
explicit replace_if_skipped(replacement_fail_t) noexcept;
          </code>
          <effects>Configures the replacement action to be <c>fail</c>.</effects>
        </code-item>

        <code-item>
          <code>
explicit replace_if_skipped(replacement_ignore_t) noexcept;
          </code>
          <effects>Configures the replacement action to be <c>ignore</c>.</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class U = T> explicit replace_if_skipped(U&amp;&amp; default_value = U());
          </code>
          <effects>Configures the replacement action to be <c>copy</c> with an object of <c>T</c> constructed from <c>std::forward&lt;U>(default_value)</c>.</effects>
          <remark>This overload shall not participate in overload resolution unless all of <c>std::is_base_of&lt;replace_if_conversion_failed&lt;T>, std::decay_t&lt;U>>::value</c>,
                  <c>std::is_base_of&lt;replacement_fail_t>, std::decay_t&lt;U>>::value</c> and
                  <c>std::is_base_of&lt;replacement_ignore_t>, std::decay_t&lt;U>>::value</c> are <c>false</c>.</remark>
        </code-item>

        <code-item>
          <code>
replace_if_skipped(const replace_if_skipped&amp; other);
          </code>
          <postcondition>Member function <c>operator()</c> behaves the same as <c>other</c>'s.</postcondition>
        </code-item>

        <code-item>
          <code>
replace_if_skipped(replace_if_skipped&amp;&amp; other) noexcept;
          </code>
          <postcondition>Member function <c>operator()</c> behaves like <c>other</c> would do before the call.</postcondition>
        </code-item>

        <code-item>
          <code>
replacement&lt;T> operator()() const;
          </code>
          <effects>Does as illustrated in <xref id="table.replace_if_skipped.invalid_format"/> in reference to the replacement action of <c>*this</c>.</effects>

          <table id="table.replace_if_skipped.invalid_format">
            <caption>Effects of calling of <c>operator()</c></caption>
            <col width="13"/><col width="5"/><col width="18"/>

            <tr>
              <th>#</th>
              <th>Type of the action</th>
              <th>Effects</th>
            </tr>

            <tr>
              <td>(1)</td>
              <td><c>copy</c></td>
              <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into the action.</td>
            </tr>

            <tr>
              <td>(2)</td>
              <td><c>ignore</c></td>
              <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
            </tr>

            <tr>
              <td>(3)</td>
              <td><c>fail</c></td>
              <td>Throws an object of <c>field_not_found</c> (<xref id="field_not_found"/>).</td>
            </tr>
          </table>
        </code-item>
      </section>
    </section>

    <section id="scanner.builtin.conversion_error_handlers">
      <name>Default conversion error handler classes</name>

      <section id="fail_if_conversion_failed">
        <name>Struct <c>fail_if_conversion_failed</c></name>

        <codeblock>
namespace commata {
  struct fail_if_conversion_failed {
    template &lt;class T, class Ch>
      [[noreturn]] replacement&lt;T> invalid_format(const Ch*, const Ch*, T* = nullptr) const;
    template &lt;class T, class Ch>
      [[noreturn]] replacement&lt;T> out_of_range(const Ch*, const Ch*, int, T* = nullptr) const;
    template &lt;class T> [[noreturn]] replacement&lt;T> empty(T* = nullptr) const;
  };
}
        </codeblock>

        <p>The struct <c>fail_if_conversion_failed</c> is a type that meets the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>). An object of them makes the parsing process fail on any conversion errors.</p>

        <code-item>
          <code>
template &lt;class T, class Ch>
  [[noreturn]] replacement&lt;T> invalid_format(const Ch*, const Ch*, T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>field_invalid_format</c> (<xref id="field_invalid_format"/>).</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class T, class Ch>
  [[noreturn]] replacement&lt;T> out_of_range(const Ch*, const Ch*, int, T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>field_out_of_range</c> (<xref id="field_out_of_range"/>).</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class T> [[noreturn]] replacement&lt;T> empty(T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>field_empty</c> (<xref id="field_empty"/>).</effects>
        </code-item>
      </section>

      <section id="replace_if_conversion_failed">
        <name>Class template <c>replace_if_conversion_failed</c></name>

        <codeblock>
namespace commata {
  template &lt;class T> class replace_if_conversion_failed {
    template &lt;class Empty = T, class InvalidFormat = T,
              class AboveUpperLimit = T, class BelowLowerLimit = T, class Underflow = T>
      explicit
        replace_if_conversion_failed(Empty&amp;&amp;           on_empty             = Empty(),
                                     InvalidFormat&amp;&amp;   on_invalid_format    = InvalidFormat(),
                                     AboveUpperLimit&amp;&amp; on_above_upper_limit = AboveUpperLimit(),
                                     BelowLowerLimit&amp;&amp; on_below_lower_limit = BelowLowerLimit(),
                                     Underflow&amp;&amp;       on_underflow         = Underflow());
    replace_if_conversion_failed(const replace_if_conversion_failed&amp; other);
    replace_if_conversion_failed(replace_if_conversion_failed&amp;&amp; other) noexcept;
   ~replace_if_conversion_failed();

    template &lt;class Ch> replacement&lt;T> invalid_format(const Ch*, const Ch*) const;
    template &lt;class Ch> replacement&lt;T> out_of_range(const Ch*, const Ch*, int sign) const;
                        replacement&lt;T> empty() const;
  };
}
        </codeblock>

        <p>The class template <c>replace_if_conversion_failed</c> offers types that meet the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>).
           On a conversion error, an object of them can make the parsing process fail or offer a substitution of the field value, depending on the category of the error.</p>
        <p><c>T</c> shall be <c>CopyConstructible</c>.</p>
        <p>An object of <c>replace_if_conversion_failed</c> has five replacement actions each of which is equivalent to one which an <c>replace_if_skipped</c> object has (<xref id="replace_if_skipped"/>): <c>action_on_empty</c>, <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c>, and <c>action_on_underflow</c>.
           Each of these replacement actions can be configured to be either of the three types illustrated in <xref id="table.replace_if_skipped.replacement_actions"/> independently on one object of <c>replace_if_conversion_failed</c>.</p>

        <code-item>
          <code>
template &lt;class Empty = T, class InvalidFormat = T,
          class AboveUpperLimit = T, class BelowLowerLimit = T, class Underflow = T>
  explicit
    replace_if_conversion_failed(Empty&amp;&amp;           on_empty             = Empty(),
                                 InvalidFormat&amp;&amp;   on_invalid_format    = InvalidFormat(),
                                 AboveUpperLimit&amp;&amp; on_above_upper_limit = AboveUpperLimit(),
                                 BelowLowerLimit&amp;&amp; on_below_lower_limit = BelowLowerLimit(),
                                 Underflow&amp;&amp;       on_underflow         = Underflow());
          </code>
          <effects>If <c>std::is_base_of&lt;replace_fail_t, std::decay_t&lt;Empty>>::value</c> is not <c>false</c>, configures <c>action_on_empty</c> to be <c>fail</c>.
                   Otherwise, if <c>std::is_base_of&lt;replace_ignore_t, std::decay_t&lt;Empty>>::value</c> is not <c>false</c>, configures it to be <c>ignore</c>.
                   Otherwise, configures it to be <c>copy</c> with an object of <c>T</c> constructed from <c>std::forward&lt;Empty>(on_empty)</c>.
                   Does the same with <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c> and <c>action_on_underflow</c>.</effects>
          <remark>This overload shall not participate in overload resolution unless <c>std::is_base_of&lt;replace_if_conversion_failed&lt;T>, std::decay_t&lt;Empty>>::value</c> is <c>false</c>.</remark>
        </code-item>

        <code-item>
          <code>
replace_if_conversion_failed(const replace_if_conversion_failed&amp; other);
          </code>
          <postcondition>Member functions <c>invalid_format</c>, <c>out_of_range</c> and <c>empty</c> behave the same as those of <c>other</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
replace_if_conversion_failed(replace_if_conversion_failed&amp;&amp; other) noexcept;
          </code>
          <postcondition>Member functions <c>invalid_format</c>, <c>out_of_range</c> and <c>empty</c> behave like <c>other</c> would do before the call.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class Ch> replacement&lt;T> invalid_format(const Ch*, const Ch*) const;
          </code>
          <effects>Does as illustrated in <xref id="table.replace_if_conversion_failed.invalid_format"/> in reference to the <c>action_on_invalid_format</c> of <c>*this</c>.</effects>

          <table id="table.replace_if_conversion_failed.invalid_format">
            <caption>Effects of calling of <c>invalid_format</c></caption>
            <col width="5"/><col width="8"/><col width="5"/><col width="18"/>

            <tr>
              <th>#</th>
              <th>Referenced action</th>
              <th>Type of the action</th>
              <th>Effects</th>
            </tr>

            <tr>
              <td>(1)</td>
              <td rowspan="3"><c>action_on_invalid_format</c></td>
              <td><c>copy</c></td>
              <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
            </tr>

            <tr>
              <td>(2)</td>
              <td><c>ignore</c></td>
              <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
            </tr>

            <tr>
              <td>(3)</td>
              <td><c>fail</c></td>
              <td>Throws an object of <c>field_invalid_format</c> (<xref id="field_invalid_format"/>).</td>
            </tr>
          </table>
        </code-item>

        <code-item>
          <code>
template &lt;class Ch> replacement&lt;T> out_of_range(const Ch*, const Ch*, int sign) const;
          </code>
          <effects>Does as illustrated in <xref id="table.replace_if_conversion_failed.out_of_range"/> in reference to <c>sign</c> and the <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c> and <c>action_on_underflow</c> of <c>*this</c>.</effects>

          <table id="table.replace_if_conversion_failed.out_of_range">
            <caption>Effects of calling of <c>out_of_range</c></caption>
            <col width="2"/><col width="3"/><col width="8"/><col width="5"/><col width="18"/>

            <tr>
              <th>#</th>
              <th><c>sign</c></th>
              <th>Referenced action</th>
              <th>Type of the action</th>
              <th>Effects</th>
            </tr>

            <tr>
              <td>(1)</td>
              <td rowspan="3">positive</td>
              <td rowspan="3"><c>action_on_above_upper_limit</c></td>
              <td><c>copy</c></td>
              <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
            </tr>

            <tr>
              <td>(2)</td>
              <td><c>ignore</c></td>
              <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
            </tr>

            <tr>
              <td>(3)</td>
              <td><c>fail</c></td>
              <td>Throws an object of <c>field_out_of_range</c> (<xref id="field_out_of_range"/>).</td>
            </tr>

            <tr>
              <td>(4)</td>
              <td rowspan="3">negative</td>
              <td rowspan="3"><c>action_on_below_lower_limit</c></td>
              <td><c>copy</c></td>
              <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
            </tr>

            <tr>
              <td>(5)</td>
              <td><c>ignore</c></td>
              <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
            </tr>

            <tr>
              <td>(6)</td>
              <td><c>fail</c></td>
              <td>Throws an object of <c>field_out_of_range</c> (<xref id="field_out_of_range"/>).</td>
            </tr>

            <tr>
              <td>(7)</td>
              <td rowspan="3"><c>0</c></td>
              <td rowspan="3"><c>action_on_underflow</c></td>
              <td><c>copy</c></td>
              <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
            </tr>

            <tr>
              <td>(8)</td>
              <td><c>ignore</c></td>
              <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
            </tr>

            <tr>
              <td>(9)</td>
              <td><c>fail</c></td>
              <td>Throws an object of <c>field_out_of_range</c> (<xref id="field_out_of_range"/>).</td>
            </tr>
          </table>
        </code-item>

        <code-item>
          <code>
replacement&lt;T> empty() const;
          </code>
          <effects>Does as illustrated in <xref id="table.replace_if_conversion_failed.empty"/> in reference to the <c>action_on_empty</c> of <c>*this</c>.</effects>

          <table id="table.replace_if_conversion_failed.empty">
            <caption>Effects of a call to <c>empty</c></caption>
            <col width="5"/><col width="8"/><col width="5"/><col width="18"/>

            <tr>
              <th>#</th>
              <th>Referenced action</th>
              <th>Type of the action</th>
              <th>Effects</th>
            </tr>

            <tr>
              <td>(1)</td>
              <td rowspan="3"><c>action_on_empty</c></td>
              <td><c>copy</c></td>
              <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
            </tr>

            <tr>
              <td>(2)</td>
              <td><c>ignore</c></td>
              <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
            </tr>

            <tr>
              <td>(3)</td>
              <td><c>fail</c></td>
              <td>Throws an object of <c>field_empty</c> (<xref id="field_empty"/>).</td>
            </tr>
          </table>
        </code-item>
    </section>
  </section>

    <section id="arithmetic_field_translator">
      <name>Class template <c>arithmetic_field_translator</c></name>

      <codeblock>
namespace commata {
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class arithmetic_field_translator {
  public:
    <c>// <n><xref id="arithmetic_field_translator.cons"/>, construct/copy/destroy:</n></c>
    explicit arithmetic_field_translator(
             Sink sink, SkippingHandler handle_skipping = SkippingHandler(),
             ConversionErrorHandler handle_conversion_error = ConversionErrorHandler());
    arithmetic_field_translator(arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~arithmetic_field_translator();

    <c>// <n><xref id="arithmetic_field_translator.handler_access"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler() noexcept;
    const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
          ConversionErrorHandler&amp; get_conversion_error_handler() noexcept;

    <c>// <n><xref id="arithmetic_field_translator.scanner"/>, members to meet the BodyFieldScanner requirements (<xref id="field_scanner.requirements"/>):</n></c>
    template &lt;class Ch> void field_value(const Ch* begin, const Ch* end);
    void field_skipped();
  };
}
      </codeblock>

      <p>The <c>arithmetic_field_translator</c> class template provides a simple implementation for arithmetic types that meets the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>).</p>
      <p><c>T</c> is the target type (<xref id="scanner.builtin_field_scanners.general"/>) and shall be either of <c>char</c>, <c>signed char</c>, <c>unsigned char</c>, <c>short</c>, <c>unsigned short</c>, <c>int</c>, <c>unsigned</c>, <c>long</c>, <c>unsigned long</c>, <c>long long</c>, <c>unsigned long long</c>, <c>float</c>, <c>double</c>, or <c>long double</c>.
         <c>Sink</c> shall be a <c>FieldTranslatorSink</c> type for the type <c>T</c> (<xref id="field_translator_sink.requirements"/>).
         The template parameter <c>SkippingHandler</c> shall be a <c>SkippingHandler</c> type for the type <c>T</c> (<xref id="skipping_handler.requirements"/>).
         The template parameter <c>ConversionErrorHandler</c> shall be a <c>ConversionErrorHandler</c> type for the type <c>T</c> (<xref id="conversion_error_handler.requirements"/>).</p>

      <section id="arithmetic_field_translator.cons">
        <name><c>arithmetic_field_translator</c> construct/copy/destroy</name>
        <code-item>
          <code>
explicit arithmetic_field_translator(
         Sink sink, SkippingHandler handle_skipping = SkippingHandler(),
         ConversionErrorHandler handle_conversion_error = ConversionErrorHandler());
          </code>
          <effects>Initializes a object of <c>arithmetic_field_translator</c> that holds copies of <c>sink</c>, <c>handle_skipping</c> and <c>handle_conversion_error</c>
                   as the field translator sink object, the skipping handler object and the conversion error handler object respectively.</effects>
        </code-item>

        <code-item>
          <code>
arithmetic_field_translator(arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes a object of <c>arithmetic_field_translator</c> that holds a field translator sink object, a skipping handler object and a conversion error handler object initialized with xvalues of the corresponding objects of <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;Sink>::value &amp;&amp; std::is_nothrow_move_constructible&lt;SkippingHandler>::value &amp;&amp; std::is_nothrow_move_constructible&lt;ConversionErrorHandler>::value</c>.
                  When this constructor exits via an exception, <c>other</c> will be placed in an unspecified state.</remark>
        </code-item>
      </section>

      <section id="arithmetic_field_translator.handler_access">
        <name><c>arithmetic_field_translator</c> handler access</name>
        <code-item>
          <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler() noexcept;
          </code>
          <returns>A reference of the skipping handler held by <c>*this</c>.</returns>
        </code-item>

        <code-item>
          <code>
const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
      ConversionErrorHandler&amp; get_conversion_error_handler() noexcept;
          </code>
          <returns>A reference of the conversion error handler held by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="arithmetic_field_translator.scanner">
        <name><c>arithmetic_field_translator</c> members to meet the <c>BodyFieldScanner</c> requirements</name>
        <code-item>
          <code>
template &lt;class Ch> void field_value(const Ch* begin, const Ch* end);
          </code>
          <requires><c>Ch</c> shall be <c>char</c> or <c>wchar_t</c>.</requires>
          <effects>First calls a parsing function indicated in <xref id="table.arithmetic_field_translator.parsing_functions"/> for <c>T</c> and <c>Ch</c> to get a arithmetic value <c>v</c> of the range [<c>begin</c>, <c>end</c>).
                   Then does an action indicated in <xref id="table.arithmetic_field_translator.branching"/> depending on the consequence of the call of the parsing function and <c>errno</c>.
                   In <xref id="table.arithmetic_field_translator.branching"/>, <c>ceh</c> is the conversion error handler, <c>n</c> is a null pointer of type <c>T*</c>, and <c>g</c> is a positive value if the field value should be translated into a value above the domain of <c>T</c>, a negative value if the field value should be translated into a value below the domain of <c>T</c>, zero otherwise.</effects>

          <table id="table.arithmetic_field_translator.parsing_functions">
            <caption>The parsing functions used by <c>arithmetic_field_translator</c></caption>
            <col width="6"/><col width="2"/><col width="2"/>

            <tr>
              <th><c>T</c></th>
              <th><c>Ch</c> is <c>char</c></th>
              <th><c>Ch</c> is <c>wchar_t</c></th>
            </tr>

            <tr>
              <td><c>char</c> (only if signed), <c>signed char</c>, <c>short</c>, <c>int</c>, or <c>long</c></td>
              <td><c>std::strtol</c></td>
              <td><c>std::wcstol</c></td>
            </tr>

            <tr>
              <td><c>char</c> (only if unsigned), <c>unsigned char</c>, <c>unsigned short</c>, <c>unsigned</c>, or <c>unsigned long</c></td>
              <td><c>std::strtoul</c></td>
              <td><c>std::wcstoul</c></td>
            </tr>

            <tr>
              <td><c>long long</c></td>
              <td><c>std::strtoll</c></td>
              <td><c>std::wcstoll</c></td>
            </tr>

            <tr>
              <td><c>unsigned long long</c></td>
              <td><c>std::strtoull</c></td>
              <td><c>std::wcstoull</c></td>
            </tr>

            <tr>
              <td><c>float</c> or <c>double</c></td>
              <td><c>std::strtod</c></td>
              <td><c>std::wcstod</c></td>
            </tr>

            <tr>
              <td><c>long double</c></td>
              <td><c>std::strtold</c></td>
              <td><c>std::wcstold</c></td>
            </tr>
          </table>

          <table id="table.arithmetic_field_translator.branching">
            <caption>The value <c>arithmetic_field_translator</c> puts into the field translator sink</caption>
            <col width="5"/><col width="5"/><col width="3"/><col width="3"/><col width="8"/>

            <tr>
              <th>The call leaves some non-whitespace characters in the range unconsumed</th>
              <th>The call consumes some characters in the range</th>
              <th><c>errno == ERANGE</c></th>
              <th><c>v</c> is in the domain of <c>T</c></th>
              <th>Action</th>
            </tr>

            <tr>
              <td>No</td>
              <td>Yes</td>
              <td>No</td>
              <td>Yes</td>
              <td>Puts <c>v</c> into the field translator sink.</td>
            </tr>

            <tr>
              <td>No</td>
              <td>Yes</td>
              <td>No</td>
              <td>No</td>
              <td rowspan="2">Evaluates <c>ceh.out_of_range(begin, end, g)</c> or <c>ceh.out_of_range(begin, end, g, n)</c> and let <c>r</c> be the return value.
                  Then puts the <c>*r</c> into the field translator sink if <c>r.get() == nullptr</c> is <c>false</c>.</td>
            </tr>

            <tr>
              <td>No</td>
              <td>Yes</td>
              <td>Yes</td>
              <td>&#8211;</td>
            </tr>

            <tr>
              <td>No</td>
              <td>No</td>
              <td>&#8211;</td>
              <td>&#8211;</td>
              <td>Evaluates <c>ceh.empty()</c> or <c>ceh.empty(n)</c> and let <c>r</c> be the return value.
                  Then puts the <c>*r</c> into the field translator sink if <c>r.get() == nullptr</c> is <c>false</c>.</td>
            </tr>

            <tr>
              <td>Yes</td>
              <td>&#8211;</td>
              <td>&#8211;</td>
              <td>&#8211;</td>
              <td>Evaluates <c>ceh.invalid_format(begin, end)</c> or <c>ceh.invalid_format(begin, end, n)</c> and let <c>r</c> be the return value.
                  Then puts the <c>*r</c> into the field translator sink if <c>r.get() == nullptr</c> is <c>false</c>.</td>
            </tr>
          </table>
        </code-item>

        <code-item>
          <code>
void field_skipped();
          </code>
          <effects>Evaluates <c>sh()</c> and puts the result into the field translator sink where <c>sh</c> is the skipping handler.</effects>
        </code-item>
      </section>
    </section>

    <section id="locale_based_arithmetic_field_translator">
      <name>Class template <c>locale_based_arithmetic_field_translator</c></name>

      <codeblock>
namespace commata {
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class locale_based_arithmetic_field_translator {
  public:
    <c>// <n><xref id="locale_based_arithmetic_field_translator.cons"/>, construct/copy/destroy:</n></c>
    explicit locale_based_arithmetic_field_translator(
             Sink sink, const std::locale&amp; loc,
             SkippingHandler handle_skipping = SkippingHandler(),
             ConversionErrorHandler handle_conversion_error = ConversionErrorHandler());
    locale_based_arithmetic_field_translator(
      locale_based_arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~locale_based_arithmetic_field_translator();

    <c>// <n><xref id="locale_based_arithmetic_field_translator.handler_access"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler() noexcept;
    const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
          ConversionErrorHandler&amp; get_conversion_error_handler() noexcept;

    <c>// <n><xref id="locale_based_arithmetic_field_translator.scanner"/>, members to meet the BodyFieldScanner requirements (<xref id="field_scanner.requirements"/>):</n></c>
    template &lt;class Ch> void field_value(Ch* begin, Ch* end);
    void field_skipped();
  };
}
      </codeblock>

      <p>The <c>locale_based_arithmetic_field_translator</c> class template provides an implementation for arithmetic types that meets the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>) in addition to the <c>arithmetic_field_translator</c> class template (<xref id="arithmetic_field_translator"/>).
         The difference is that an object of <c>locale_based_arithmetic_field_translator</c> can correctly handle the decimal radix separator character and the digit group separator character that differ from those of the C-language locale.</p>
      <p><c>T</c> is the target type (<xref id="scanner.builtin_field_scanners.general"/>) and shall be either of <c>char</c>, <c>signed char</c>, <c>unsigned char</c>, <c>short</c>, <c>unsigned short</c>, <c>int</c>, <c>unsigned</c>, <c>long</c>, <c>unsigned long</c>, <c>long long</c>, <c>unsigned long long</c>, <c>float</c>, or <c>double</c>.
         <c>Sink</c> shall be a <c>FieldTranslatorSink</c> type for the type <c>T</c> (<xref id="field_translator_sink.requirements"/>).
         The template parameter <c>SkippingHandler</c> shall be a <c>SkippingHandler</c> type for the type <c>T</c> (<xref id="skipping_handler.requirements"/>).
         The template parameter <c>ConversionErrorHandler</c> shall be a <c>ConversionErrorHandler</c> type for the type <c>T</c> (<xref id="conversion_error_handler.requirements"/>).</p>

      <section id="locale_based_arithmetic_field_translator.cons">
        <name><c>locale_based_arithmetic_field_translator</c> construct/copy/destroy</name>
        <code-item>
          <code>
explicit locale_based_arithmetic_field_translator(
         Sink sink, const std::locale&amp; loc,
         SkippingHandler handle_skipping = SkippingHandler(),
         ConversionErrorHandler handle_conversion_error = ConversionErrorHandler());
          </code>
          <effects>Initializes a object of <c>locale_based_arithmetic_field_translator</c> that holds copies of <c>sink</c>, <c>loc</c>, <c>handle_skipping</c> and <c>handle_conversion_error</c>
                   as the field translator sink object, the locale object, the skipping handler object and the conversion error handler object respectively.</effects>
        </code-item>

        <code-item>
          <code>
locale_based_arithmetic_field_translator(
  locale_based_arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes a object of <c>locale_based_arithmetic_field_translator</c> that holds a field translator sink object, a locale object, a skipping handler object and a conversion error handler object initialized with xvalues of the corresponding objects of <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;Sink>::value &amp;&amp; std::is_nothrow_move_constructible&lt;SkippingHandler>::value &amp;&amp; std::is_nothrow_move_constructible&lt;ConversionErrorHandler>::value</c>.
                  When this constructor exits via an exception, <c>other</c> will be placed in an unspecified state.</remark>
        </code-item>
      </section>

      <section id="locale_based_arithmetic_field_translator.handler_access">
        <name><c>locale_based_arithmetic_field_translator</c> handler access</name>
        <code-item>
          <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler() noexcept;
          </code>
          <returns>A reference of the skipping handler held by <c>*this</c>.</returns>
        </code-item>

        <code-item>
          <code>
const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
      ConversionErrorHandler&amp; get_conversion_error_handler() noexcept;
          </code>
          <returns>A reference of the conversion error handler held by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="locale_based_arithmetic_field_translator.scanner">
        <name><c>locale_based_arithmetic_field_translator</c> members to meet the <c>BodyFieldScanner</c> requirements</name>
        <code-item>
          <code>
template &lt;class Ch> void field_value(Ch* begin, Ch* end);
          </code>
          <requires><c>Ch</c> shall be <c>char</c> or <c>wchar_t</c>.</requires>
          <effects>If the specified locale has a non-empty grouping spec of the numeric output, removes all digit group separator characters of the specified locale in the range [<c>begin</c>, <c>end</c>) in place.
                   Replaces the decimal radix separator character of the specified locale in the resulted range on its first occurrence in place with the decimal radix separator character of the C-language locale.
                   Then calls a parsing function with the resulted range and put a value into the field translator sink as if a <c>arithmetic_field_translator</c> (<xref id="arithmetic_field_translator"/>) object does.</effects>
          <remark>Suppose that <c>npf</c> is <c>std::use_facet&lt;std::numpunct&lt;Ch>>(l)</c> where <c>l</c> is the specified locale.
                  The grouping spec of the numeric output of it is <c>npf.grouping()</c>.
                  The digit group separator character of the specified locale is <c>npf.thousands_sep()</c>.
                  The decimal radix separator character of it is <c>npf.decimal_point()</c>.
                  The decimal radix separator character of the C-language locale is <c>*std::localeconv()->decimal_point</c> conditionally widen with <c>std::btowc</c> to get a value of the type <c>Ch</c>.</remark>
        </code-item>

        <code-item>
          <code>
void field_skipped();
          </code>
          <effects>Evaluates <c>sh()</c> and puts the result into the field translator sink where <c>sh</c> is the skipping handler.</effects>
        </code-item>
      </section>
    </section>

    <section id="string_field_translator">
      <name>Class template <c>string_field_translator</c></name>

      <codeblock>
namespace commata {
  template &lt;class Sink, class Ch, class Tr = std::char_traits&lt;Ch>,
            class Allocator = std::allocator&lt;Ch>,
            class SkippingHandler = fail_if_skipped&lt;std::basic_string&lt;Ch, Tr, Allocator>>>
    class string_field_translator {
  public:
    using allocator_type = Allocator;

    <c>// <n><xref id="string_field_translator.cons"/>, construct/copy/destroy:</n></c>
    explicit string_field_translator(Sink sink,
                                     SkippingHandler handle_skipping = SkippingHandler());
    string_field_translator(std::allocator_arg_t, const Allocator&amp; alloc, Sink sink,
                            SkippingHandler handle_skipping = SkippingHandler());
    string_field_translator(string_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~string_field_translator();

    <c>// <n><xref id="string_field_translator.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="string_field_translator.handler_access"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler() noexcept;

    <c>// <n><xref id="string_field_translator.scanner"/>, members to meet the BodyFieldScanner requirements (<xref id="field_scanner.requirements"/>):</n></c>
    void field_value(const Ch* begin, const Ch* end);
    void field_value(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; value);
    void field_skipped();
  };
}
      </codeblock>

      <p>The <c>string_field_translator</c> class template provides a simple implementation for the standard string type that meets the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>).
         Its target type (<xref id="scanner.builtin_field_scanners.general"/>) is <c>std::basic_string&lt;Ch, Tr, Alloc></c>.</p>
      <p><c>Sink</c> shall be a <c>FieldTranslatorSink</c> type for <c>std::basic_string&lt;Ch, Tr, Alloc></c> (<xref id="field_translator_sink.requirements"/>).
         The template parameter <c>SkippingHandler</c> shall be a <c>SkippingHandler</c> type for the type <c>std::basic_string&lt;Ch, Tr, Alloc></c> (<xref id="skipping_handler.requirements"/>).</p>

      <section id="string_field_translator.cons">
        <name><c>string_field_translator</c> construct/copy/destroy</name>
        <code-item>
          <code>
string_field_translator(Sink sink,
                        SkippingHandler handle_skipping = SkippingHandler());
          </code>
          <requires><c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <effects>Initializes a object of <c>string_field_translator</c> that holds a default-constructed <c>Allocator</c> object as its allocator, and copies of <c>sink</c> and <c>handle_skipping</c>
                   as the field translator sink object and the skipping handler object respectively.</effects>
        </code-item>

        <code-item>
          <code>
string_field_translator(std::allocator_arg_t, const Allocator&amp; alloc, Sink sink,
                        SkippingHandler handle_skipping = SkippingHandler());
          </code>
          <effects>Initializes a object of <c>string_field_translator</c> that holds copies of <c>alloc</c>, <c>sink</c> and <c>handle_skipping</c>
                   as the allocator object, the field translator sink object and the skipping handler object respectively.</effects>
        </code-item>

        <code-item>
          <code>
string_field_translator(string_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes a object of <c>string_field_translator</c> that holds an allocator object, a field translator sink object, and a skipping handler object initialized with xvalues of the corresponding objects of <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;Sink>::value &amp;&amp; std::is_nothrow_move_constructible&lt;SkippingHandler>::value</c>.
                  When this constructor exits via an exception, <c>other</c> will be placed in an unspecified state.</remark>
        </code-item>
      </section>

      <section id="string_field_translator.allocator">
        <name><c>string_field_translator</c> allocator access</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object used to construct the string.</returns>
        </code-item>
      </section>

      <section id="string_field_translator.handler_access">
        <name><c>string_field_translator</c> handler access</name>
        <code-item>
          <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler() noexcept;
          </code>
          <returns>A reference of the skipping handler held by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="string_field_translator.scanner">
        <name><c>string_field_translator</c> members to meet the <c>BodyFieldScanner</c> requirements</name>
        <code-item>
          <code>
void field_value(const Ch* begin, const Ch* end);
          </code>
          <effects>Puts <c>std::basic_string&lt;Ch, Tr, Alloc>(begin, end, get_allocator())</c> into the field translator sink.</effects>
        </code-item>

        <code-item>
          <code>
void field_value(std::basic_string&lt;Ch, Tr, Alloc>&amp;&amp; value);
          </code>
          <effects>If <c>value.get_allocator() == get_allocator()</c>, puts <c>std::move(value)</c> into the field translator sink. Otherwise, calls <c>field_value(value.c_str(), value.c_str() + value.size())</c>.</effects>
        </code-item>

        <code-item>
          <code>
void field_skipped();
          </code>
          <effects>Evaluates <c>sh()</c> and puts the result into the field translator sink where <c>sh</c> is the skipping handler.</effects>
        </code-item>
      </section>
    </section>

    <section id="make_field_translator">
      <name>Creation of default field scanners</name>

      <p>In this subclause, a type <c>S</c> is <n>deemed to be an acceptable sink</n> of a type <c>T</c> if:</p>
      <ul>
        <li><c>std::iterator_traits&lt;S>::iterator_category</c> is a type equal to <c>std::output_iterator_tag</c>, <c>std::forward_iterator_tag</c>, or their derived type; or</li>
        <li><c>s(t)</c> is a valid expression where <c>s</c> is an lvalue of <c>S</c> and <c>t</c> is an rvalue of <c>T</c>.</li>
      </ul>

      <code-item>
        <code>
template &lt;class T, class Sink, class... Appendices>
  <nc>see below</nc> make_field_translator(Sink sink, Appendices&amp;&amp;... appendices);
        </code>
        <returns><c>R(std::move(sink), std::forward&lt;Appendices>(appendices)...)</c> where the type <c>R</c> is decided as follows:
                 <ul>
                   <li>If <c>T</c> is <c>std::basic_string&lt;Ch, Tr, Allocator></c> for a certain combination of <c>Ch</c>, <c>Tr</c> and <c>Allocator</c>, <c>string_field_translator&lt;Sink, Ch, Tr, Allocator, Appendices...></c>,</li>
                   <li>otherwise, if the reference-removed type of the first type of <c>Appendices</c> is a possibly cv-qualified <c>std::locale</c> or its derived type,
                       <c>locale_based_arithmetic_field_translator&lt;T, Sink, TailOfAppendices...></c> where <c>TailOfAppendices...</c> represents the types of <c>Appendices...</c> without its first type,</li>
                   <li>otherwise, <c>arithmetic_field_translator&lt;T, Sink, Appendices...></c>.</li>
                 </ul>
        </returns>
        <remark>This overload shall not participate in overload resolution unless <c>Sink</c> is deemed to be an acceptable sink of <c>T</c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class T, class Allocator, class Sink, class... Appendices>
  <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                  Sink sink, Appendices&amp;&amp;... appendices);
        </code>
        <returns><c>string_field_translator&lt;Sink, typename T::value_type, typename T::traits_type, Appendices...>(std::allocator_arg, alloc, std::move(sink), std::forward&lt;Appendices>(appendices)...)</c>.</returns>
        <remark>This overload shall not participate in overload resolution unless <c>Sink</c> is deemed to be an acceptable sink of <c>T</c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class Container, class... Appendices>
  <nc>see below</nc> make_field_translator(Container&amp; values, Appendices&amp;&amp;... appendices);
template &lt;class Allocator, class Container, class... Appendices>
  <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                  Container&amp; values, Appendices&amp;&amp;... appendices);
        </code>
        <returns><c>make_field_translator(std::move(s), std::forward&lt;Appendices>(appendices)...)</c> (first overload) or
                 <c>make_field_translator(std::allocator_arg, alloc, std::move(s), std::forward&lt;Appendices>(appendices)...)</c> (second overload) where <c>s</c> is an object constructed as follows:
                 <ul>
                   <li>if <c>values.push_back(t)</c> is a valid expression where <c>t</c> is an rvalue of <c>typename Container::value_type</c>, <c>std::back_inserter(values)</c>,</li>
                   <li>otherwise, <c>std::inserter(values, values.end())</c>.</li>
                 </ul>
        </returns>
        <remark>These overloads shall not participate in overload resolution unless <c>c.insert(c.end(), t)</c> is a valid expression where <c>c</c> is an lvalue of <c>Container</c> and <c>t</c> is an rvalue of <c>typename Container::value_type</c>.</remark>
      </code-item>
    </section>
  </section>
</section>

</document>

