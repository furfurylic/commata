<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="Commata.xsl"?>
<document>
<title>Specification of Commata, which is just another C++17 CSV parser</title>
<signature>2024-03-09 (UTC)</signature>

<section id="introduction">
  <name>Introduction</name>

  <section id="introduction.general">
    <name>General</name>

    <p>This document describes the specifications of Commata, which is a header-only library in C++17 to handle formatted texts, such as CSV texts.</p>
    <p>In this document, many terms and names introduced in ISO C++17 standard are referred without notice.
       &#x2018;Unspecified behaviour&#x2019;, &#x2018;<c>DefaultConstructible</c> requirements&#x2019;, &#x2018;formatted output function&#x2019;, &#x2018;<c>&lt;string></c>&#x2019; (as a header name) and &#x2018;<c>std::string</c>&#x2019; are the examples.</p>

    <p>The normativity of the specifications on this document is the same as the normativity of the description of the ISO C++17 standard for its conforming standard library implementations except that:</p>
    <ul>
      <li>class templates and function templates shall not have any additional template parameters no matter whether they have their default template arguments, except that deduction guides can have ones with their default template arguments, </li>
      <li>member templates shall not have any additional template parameters no matter whether they have their default template arguments, except that constructor templates can have ones with their default template arguments, and</li>
      <li>member function templates shall not have any additional parameters no matter whether they have their default arguments.</li>
    </ul>
  </section>

  <section id="introduction.using">
    <name>Using Commata</name>

    <p>A translation unit may include headers described in this document in any order.
       Each may be included more than once, with no effect different from being included exactly once.</p>
    <p>A translation unit shall include a header described in this document only outside of any external declaration or definition, and shall include the header lexically before the first reference in that translation unit to any of the entities declared in that header.</p>
    <p>A translation unit shall not define a macro whose name meets one of the following before a point of an <c>#include</c> preprocessor directive that includes a header described in this document:</p>
    <ul>
      <li>it consists only of one uppercase alphabetic letter,</li>
      <li>it begins with a lowercase alphabetic letter,</li>
      <li>it consists only of alphabetic letters and possibly zero decimal digit characters, and contains both of an uppercase alphabetic letter and a lowercase one, or</li>
      <li>it begins with <c>COMMATA_</c>.</li>
    </ul>
    <p>Headers described in this document may define macros whose name begin with <c>COMMATA_</c> and may not define any macros with other names.</p>
  </section>

  <section id="concepts">
    <name>Basic concepts</name>

    <p>Users of Commata process texts coordinating two kinds of objects below:</p>
    <ul>
      <li><n>table parsers</n> (<xref id="table_parser.requirements"/>), which retrieve a sequence of char-like objects in a certain format such as a CSV text (<xref id="definitions.csv_text"/>) from an input, which is, for example, a stream or a stream buffer, and emits events to their tied table handlers, and</li>
      <li><n>table handlers</n> (<xref id="table_handler.requirements"/>), which receive events from the table parser and do some operation on them.</li>
      <li><n>table sources</n> (<xref id="table_source.requirements"/>), which hold a sequence of char-like objects and work as factories of table parsers.</li>
    </ul>
    <p>Commata offers some default implementations of above two kinds of concepts.
       Users of Commata can unsurprisingly implement their own table handlers or table parsers, and make them collaborate with the default implementations.</p>
  </section>

  <section id="definitions">
    <name>Definitions</name>

    <section id="definitions.text_table">
      <name>Text tables</name>

      <p>Events that table handlers receive from the parser conform the <n>text table</n> model following:</p>
      <ul>
        <li>Each text table has its <n>char type</n> that is a char-like type.</li>
        <li>A text table is a sequence of <n>text records</n>.</li>
        <li>A text record is a sequence of <n>text fields</n>.</li>
        <li>Each text field has its <n>text value</n>, which is a sequence of the char type objects.</li>
      </ul>
    </section>

    <section id="definitions.others">
      <name>Other definitions</name>

      <p>Addtional terms on text tables used in this document are as follows:</p>
      <ul>
        <li>A <n>record index</n> of a text record in a text table is a number i where the record is the i-th record in the text table.
            It depends on situation whether i is zero-based or one-based.</li>
        <li>A <n>field index</n> of a text field in a text record is a number j where the field is the j-th field in the text record.
            It depends on situation whether j is zero-based or one-based.</li>
        <li>A <n>line</n> or <n>physical line</n> in a sequence of char-like objects is a sequence of characters delimited by line breaks. It does not contain any line breaks in it.</li>
        <li>A <n>column</n> or <n>physical column</n> in a sequence of char-like objects is a bundle of the same distant characters from the first character of each line.</li>
        <li>A <n>position</n> or <n>physical position</n> of a character in a sequence of char-like objects is the pair of m and n where the character belongs to the m-th line and the n-th column.
            It depends on situation whether m and n are zero-based or one-based.</li>
      </ul>
    </section>
  </section>

  <section id="requirements">
    <name>Basic requirements</name>

    <p>This subclause specifies requirements that correspond the basic concepts of Commata (<xref id="concepts"/>).</p>

    <section id="table_handler.requirements">
      <name><c>TableHandler</c> requirements</name>

      <p>A type <c>T</c> meets the <c>TableHandler</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
      <ul>
        <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>,</li>
        <li>the expressions shown in <xref id="table.table_handler.requirements"/> are valid and have the indicated semantics, and</li>
        <li>moved-to objects of <c>T</c> takes over the states of moved-from objects in terms of <xref id="table.table_handler.requirements"/>.</li>
      </ul>

      <p>In <xref id="table.table_handler.requirements"/>, <c>T</c> is cv-unqualified. <c>t</c> is an lvalue of <c>T</c>. <c>ct</c> is an lvalue of <c>const T</c>.
         <c>b</c> is an rvalue of <c>Ch*</c>.
         <c>bb</c>, <c>be</c>, <c>bm</c>, <c>w</c>, <c>rb</c>, <c>re</c>, <c>f</c> and <c>l</c> are rvalues of <c>T::char_type*</c>, which is specified as (1) in <xref id="table.table_handler.requirements"/>.
         <c>p</c> is an rvalue of <c>std::size_t</c>.</p>

      <p>A requirement is optional if the last column of <xref id="table.table_handler.requirements"/> specifies a default.</p>
      <p>If (2) in <xref id="table.table_handler.requirements"/> is satisfied without falling back on the default, then also (3) shall be so. Likewise, if (3) is satisfied without falling back on the default, then also (2) shall be so.
         That is, <c>T</c> shall either have both of <c>get_buffer</c> and <c>release_buffer</c> member functions or have none of them.</p>
      <p>Exiting via an exception from an evaluation on a table handler described in <xref id="table.table_handler.requirements"/> shall make the corresponding invocation on the parser (<xref id="table_parser.requirements"/>) exit via an exception without making further evaluation on the table handler other than (13).</p>

      <table id="table.table_handler.requirements">
        <caption>TableHandler requirements</caption>
        <col width="2"/><col width="9"/><col width="9"/><col width="20"/><col width="8"/>

        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remarks</th>
          <th>Default behaviour</th>
        </tr>

        <tr>
          <td>(1)</td>
          <td><c>T::char_type</c></td>
          <td></td>
          <td>Shall be an identical type to <c>Ch</c> or <c>const Ch</c>.</td>
          <td></td>
        </tr>

        <tr>
          <td>(2)</td>
          <td><c>t.get_buffer()</c></td>
          <td><c>std::pair&lt;Ch*, std::size_t&gt;</c></td>
          <td><p>Evaluated when the parser requires a new buffer.
                 The parser evaluates this expression only just after it was attached to this handler or just after it evaluated (3).</p>
              <p>Shall return a pair of a pointer that points the first element of a secured buffer and its length.
                 The parser utilizes the range [<c>gb.first</c>, <c>gb.first + gb.second</c>) as a buffer where <c>gb</c> is the return value of this function.</p></td>
          <td><p>At the first evaluation, acquires a buffer of a certain length and returns it. </p>
              <p>Otherwise, returns a pooled buffer.</p></td>
        </tr>

        <tr>
          <td>(3)</td>
          <td><c>t.release_buffer(b)</c></td>
          <td>(Not used)</td>
          <td><p>Evaluated when the parser unhold the buffer acquired by the latest evaluation of (2).</p>
              <p><c>b</c> is <c>gb.first</c> where <c>gb</c> is return value of the latest evaluation of (2).</p>
              <p>Evaluating this shall not exit via an exception.</p></td>
           <td>Stores <c>b</c> into a pool.</td>
        </tr>

        <tr>
          <td>(4)</td>
          <td><c>t.start_buffer(bb, be)</c></td>
          <td>(Not used)</td>
          <td><p>Evaluated when the parser starts using its buffer.
                 If evaluatung this occurs after an evaluation of (2) and before its corresponding evaluation of (3),
                 it shall occur only once between them.</p>
              <p>If evaluating this occurs after an evaluation of (2) and before its corresponding evaluation of (3),
                 <c>bb</c> points <c>*gb.first</c>. <c>be</c> is <c>gb.first + gb.second</c> where <c>gb</c> is the return value of the latest evaluation of (2).</p>
              <p>Just after an evaluation of this, the parser shall secure a sequence of char-like objects retrieved from its input as the range [<c>bb</c>, <c>bm</c>) where <c>bm</c> is a pointer that resides in [<c>bb</c>, <c>be</c>] and reported with (5) later.
                 After an evaluation of this and before the corresponding evaluation of (5), the parser shall report (possibly past-the-end) pointers on this sequence.</p></td>
          <td>Does nothing.</td>
        </tr>

        <tr>
          <td>(5)</td>
          <td><c>t.end_buffer(bm)</c></td>
          <td>(Not used) </td>
          <td><p>Evaluated when the parser finishes using its buffer.
                 Evaluating this shall occur after an evaluation of (4) only once.
                 If the latest evaluating of (4) occurred after an evaluation of (2) and before its corresponding evaluation of (3), evaluating this shall also occur before the evaluation of (3).</p>
              <p><c>bm</c> points the one past the last element of the range in the buffer actually used, and resides in [<c>bb</c>, <c>be</c>] where <c>bb</c> and <c>be</c> are the arguments of the latest evaluation of (4) in order.</p></td>
          <td>Does nothing.</td>
        </tr>

        <tr>
          <td>(6)</td>
          <td><c>t.empty_physical_line(w)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Evaluated when the parser finds an empty line outside any record.
                 Evaluating this shall occur after an evaluation of (4) and before its corresponding evaluation of (5)
                 and shall not occur between an evaluation of (7) and its corresponding evaluation of (8).</p>
              <p>Here let:</p>
              <ul>
                <li><c>gb</c> be the return value of the latest evaluation of (2), and</li>
                <li><c>bb</c> be the first argument of the latest evaluation of (4).</li>
              </ul>
              <p>Then <c>w</c> points to the last line break character, which resides in [<c>bb</c>, <c>gb.first + gb.second</c>).</p>
              <p>If the contextually converted value to <c>bool</c> of this expression is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td>Does nothing.</td>
        </tr>

        <tr>
          <td>(7)</td>
          <td><c>t.start_record(rb)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Evaluated when the parser begins to process a record.
                 Evaluating this shall occur after an evaluation of (4) and before its corresponding evaluation of (5).</p>
              <p>Here let:</p>
              <ul>
                <li><c>gb</c> be the return value of the latest evaluation of (2), and</li>
                <li><c>bb</c> be the first argument of the latest evaluation of (4).</li>
              </ul>
              <p>Then <c>rb</c> points the first character of the record, not of the text value of the first field of the record.
                 <span class="note">To be specific, for example, if the parser conforms to the CSV text model (<xref id="definitions.csv_text"/>) and the first field of the records is quoted, <c>*rb</c> shall be a double quote.</span>
                 The pointee of <c>rb</c> which resides in [<c>bb</c>, <c>gb.first + gb.second</c>).</p>
              <p>If the contextually converted value to <c>bool</c> of this expression is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td/>
        </tr>

        <tr>
          <td>(8)</td>
          <td><c>t.end_record(re)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Evaluated when the parser finishes processing a record.
                 Evaluating this shall occur after an evaluation of (7) only once; and
                 after an evaluation of (4) and before its corresponding evaluation of (5).</p>
              <p>Here let:</p>
              <ul>
                <li><c>vb</c> be the argument of the latest evaluation of (4) (first argument), (7), (9) (second argument) or (10) (second argument), and</li>
                <li><c>be</c> be the second argument of the latest evaluation of (4).</li>
              </ul>
              <p>Then <c>re</c> points one past the last element of the characters that forms the record, not of the text value of the final field of the record.
                 <span class="note">To be specific, for example, if the parser conforms to the CSV text model (<xref id="definitions.csv_text"/>) and the final field of the record is quoted, <c>*(re - 1)</c> shall be a double quote.</span>
                 The pointee of <c>re</c> resides in [<c>vb</c>, <c>be</c>).</p>
              <p>If the contextually converted value to <c>bool</c> of this expression is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td/>
        </tr>

        <tr>
          <td>(9)</td>
          <td><c>t.update(f, l)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Evaluated when the parser finds a non-final chunk of a field value.
                 Evaluating this shall occur after an evaluation of (4) and before its corresponding evaluation of (5), and after an evaluation of (7) and before its corresponding evaluation of (8).</p>
              <p>Here let:</p>
              <ul>
                <li><c>vb</c> be the argument of the latest evaluation of (4) (first argument), (7), this (second argument) or (10) (second argument), and</li>
                <li><c>bb</c> and <c>be</c> be the arguments of the latest evaluation of (4) in order.</li>
              </ul>
              <p>Then the range [<c>f</c>, <c>l</c>) shall not be empty.
                 The chunk is a sequence of char-like objects in [<c>f</c>, <c>l</c>).
                 The pointee of <c>f</c> resides in [<c>vb</c>, <c>be</c>), and the pointee of <c>l</c> resides in [<c>f</c>, <c>be</c>).</p>
              <p>After the evaluation, the parser shall not dereference the range [<c>bb</c>, <c>l</c>) before the next evaluation of (5).
                 <span class="note">Therefore the table handler may freely modify the element in the range if <c>T::char_type</c> is not const-qualified.</span></p>
              <p>If the contextually converted value to <c>bool</c> of this expression is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td/>
        </tr>

        <tr>
          <td>(10)</td>
          <td><c>t.finalize(f, l)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Evaluated when the parser finds a final chunk of a field value.
                 Evaluating of this shall occur after an evaluation of (4) and before its corresponding evaluation of (5), and after an evaluation of (7) and before its corresponding evaluation of (8).</p>
              <p>Here let:</p>
              <ul>
                <li><c>vb</c> be the argument of the latest evaluation of (4) (first argument), (7), (9) (second argument) or this (second argument), and</li>
                <li><c>bb</c> and <c>be</c> be the arguments of the latest evaluation of (4) in order.</li>
              </ul>
              <p>Then the range [<c>f</c>, <c>l</c>) may be empty.
                 The chunk is a sequence of char-like objects in [<c>f</c>, <c>l</c>).
                 The pointee of <c>f</c> resides in [<c>vb</c>, <c>be</c>), and the pointee of <c>l</c> resides in [<c>f</c>, <c>be</c>).</p>
              <p>After evaluating, the parser shall not dereference the range [<c>bb</c>, <c>l</c>] before the next evaluation of (5).
                 <span class="note">Therefore the table handler may freely modify the element in the range if <c>T::char_type</c> is not const-qualified.</span></p>
              <p>If the contextually converted value to <c>bool</c> of this expression is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td/>
        </tr>

        <tr>
          <td>(11)</td>
          <td><c>t.yield(p)</c></td>
          <td>A type contextually convertible to <c>bool</c></td>
          <td><p>Evaluated when the parser reaches an execution point where the parser can suspend the execution and return the control to its invoker.
                 The parser shall evaluate this also just after evaluating (5).</p>
              <p><c>p</c> is an rvalue whose type is <c>std::size_t</c> and whose value is a number that can identificate the execution point where the evaluation of this occurred.
                 Its value shall not be equal to <c>0</c>.
                 Its value of <c>-1</c> shall mean that the parser is about to complete the execution.</p>
              <p>If the contextually converted value to <c>bool</c> of this expression is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td>Returns <c>false</c>.</td>
        </tr>

        <tr>
          <td>(12)</td>
          <td><c>ct.yield_location()</c></td>
          <td><c>std::size_t</c></td>
          <td><p>Evaluated when the parser is about to start the execution or restart the execution after a suspension due to the latest return value of (11).</p>
              <p>Shall return the value of the parameter <c>p</c> of the latest evaluation of (11) with the return value being <c>true</c>; otherwise shall return <c>0</c>.</p></td>
          <td>Returns <c>0</c>.</td>
        </tr>

        <tr>
          <td>(13)</td>
          <td><c>t.handle_exception()</c></td>
          <td>(Not used) </td>
          <td><p>Evaluated when the parser catches an exception that otherwise should cause the invocation to the parser to exit via it.
                 When evaluated, the caught exception shall be referrable as a currently handled exception.</p>
              <p>If evaluating this does not exit via an exception, the parser shall rethrow the currently handled exception to make the invocation to the parser exit via it.</p></td>
          <td>Does nothing.</td>
         </tr>
      </table>

      <p>A moved-from object whose type satisfies <c>TableHandler</c> requirements may cause undefined behaviour when used in terms of <xref id="table.table_handler.requirements"/>.</p>
      <p>A type that meets the <c>TableHandler</c> requirements for a certain char-like type is called <n>deemed to have buffer control</n> if it satisfies both of (1) and (2) in <xref id="table.table_handler.requirements"/> without falling back on the defaults. Otherwise, it is called <n>deemed to have no buffer control</n>.</p>
    </section>

    <section id="table_parser.requirements">
      <name><c>TableParser</c> requirements</name>

      <p>A type <c>T</c> meets the <c>TableParser</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
      <ul>
        <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
        <li>each object of <c>T</c> has (possibly a reference to) a <n>tied character input</n> object, and (similarly, possibly a reference to) a <n>tied table handler</n> object whose type meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>);
            and the expressions shown in <xref id="table.table_parser.requirements"/> are valid and have the indicated semantics.</li>
      </ul>

      <p>In <xref id="table.table_parser.requirements"/> and <xref id="table.table_parser.optional"/>, <c>T</c> is cv-unqualified. <c>t</c> is an lvalue of <c>T</c>. <c>ct</c> is an lvalue of <c>const T</c>.</p>

      <table id="table.table_parser.requirements">
        <caption>TableParser requirements</caption>
        <col width="2"/><col width="9"/><col width="9"/><col width="28"/>

        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remarks</th>
        </tr>

        <tr>
          <td>(1)</td>
          <td><c>t()</c></td>
          <td>A type contextually convertible to <c>bool</c></td>
          <td>Retrieves the text content from its tied character input, parses the text content, and calls the member functions of its tied table handler object compliantly with the <c>TableHandler</c> requirements.
              Returns <c>false</c> if the return value of a call on <c>empty_physical_line</c>, <c>start_record</c>, <c>end_record</c>, <c>update</c>, or <c>finalize</c> is <c>false</c>; <c>true</c> otherwise.
              If this returns <c>false</c> or exits via an exception, then this becomes unable to be called again.</td>
        </tr>

        <tr>
          <td>(2)</td>
          <td><c>ct.~T()</c></td>
          <td>(Not used)</td>
          <td>Calls <c>release_buffer</c> of its tied table handler object if and only if the latest call of (1) left a buffer obtained with <c>get_buffer</c> of the table handler object unreleased.</td>
        </tr>
      </table>

      <p><xref id="table.table_parser.optional"/> lists operations provided for some types of <c>TableParser</c>s but not others.
         Those types for which the listed operations are provided shall implement the semantics described in <xref id="table.table_parser.optional"/> unless otherwise stated.</p>

      <table id="table.table_parser.optional">
        <caption>Optional TableParser operations</caption>
        <col width="2"/><col width="9"/><col width="9"/><col width="28"/>

        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remarks</th>
        </tr>

        <tr>
          <td>(3)</td>
          <td><c>T::reads_direct</c></td>
          <td>Identical to or derived from <c>std::true_type</c> or <c>std::false_type</c></td>
          <td><c>std::true_type</c> only if any objects of <c>T</c> do not require any buffers to store char-like objects informed to its tied table handler object.</td>
        </tr>

        <tr>
          <td>(4)</td>
          <td><c>ct.get_physical_position()</c></td>
          <td><c>std::pair&lt;std::size_t, std::size_t></c></td>
          <td>Returns a pair of the physical line number and the physical column number (<xref id="definitions.others"/>).
              The numbers are zero-based.
              <c>-1</c> means shall mean &#x2018;no information&#x2019;.
              Shall not exit via an exception.</td>
        </tr>
      </table>
    </section>

    <section id="table_source.requirements">
      <name><c>TableSource</c> requirements</name>
  
      <p>A type <c>T</c> meets the <c>TableSource</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
      <ul>
        <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
        <li>each object of <c>T</c> has (possibly a reference to) a <n>wrapped character input</n> object, and the expressions shown in <xref id="table.table_source.requirements"/> are valid and have the indicated semantics.</li>
      </ul>
  
      <p>In <xref id="table.table_source.requirements"/> and <xref id="table.table_source.optional"/>,</p>
      <ul>
        <li><c>H</c> is a type that meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>Ch</c>,</li>
        <li><c>K</c> is a type that meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>Ch</c> and that is deemed to no have buffer control,</li>
        <li><c>A</c> is a type that meets the <c>Allocator</c> requirements for <c>Ch</c>,</li>
        <li><c>ct</c> is an lvalue of <c>const T</c>,</li>
        <li><c>rt</c> is an rvalue of <c>T</c>,</li>
        <li><c>h</c> is an expression whose type meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>Ch</c>,</li>
        <li><c>k</c> is an expression whose type meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>Ch</c> and that is deemed to have no buffer control,</li>
        <li><c>s</c> is an rvalue of <c>std::size_t</c>, and</li>
        <li><c>a</c> is an rvalue whose type meets the <c>Allocator</c> requirement for <c>Ch</c>.</li>
      </ul>
  
      <table id="table.table_source.requirements">
        <caption><c>TableSource</c> requirements</caption>
        <col width="2"/><col width="9"/><col width="18"/><col width="28"/>
  
        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remarks</th>
        </tr>
  
        <tr>
          <td>(1)</td>
          <td><c>T::char_type</c></td>
          <td></td>
          <td>Shall be an identical type to <c>Ch</c>.</td>
        </tr>
  
        <tr>
          <td>(2)</td>
          <td><c>T::traits_type</c></td>
          <td></td>
          <td>Shall be a character traits type for <c>Ch</c>.</td>
        </tr>
  
        <tr>
          <td>(3)</td>
          <td><c>T::parser_type&lt;H></c></td>
          <td></td>
          <td>Shall be a type that meets the <c>TableParser</c> requirements (<xref id="table_parser.requirements"/>) for <c>Ch</c>.</td>
        </tr>

        <tr>
          <td>(4)</td>
          <td><c>ct(h)</c></td>
          <td rowspan="2"><c>T::parser_type&lt;std::decay_t&lt;decltype(h)>></c></td>
          <td rowspan="2">
            <p>Creates a table parser object <c>p</c> and returns it.</p>
            <p><c>p</c> has its tied character input object which is copy constructed (on (4)) or move constructed (on (5)) from the wrapped character input object of <c>*this</c> and
               its tied table handler object which is constructed with <c>std::move(h)</c> (if <c>h</c> is an rvalue) or with <c>h</c> (otherwise).</p>
          </td>
        </tr>
  
        <tr>
          <td>(5)</td>
          <td><c>rt(h)</c></td>
        </tr>
      </table>

      <p>Some types of <c>TableSource</c>s additionally offer optional operations for <c>TableHandler</c> types that is deemed to have no buffer control, as described in <xref id="table.table_source.optional"/>.
         Those types for which the listed operations are provided shall implement the semantics described in <xref id="table.table_source.optional"/> unless otherwise stated.</p>
 
      <table id="table.table_source.optional">
        <caption>Optional <c>TableSource</c> operations</caption>
        <col width="2"/><col width="9"/><col width="18"/><col width="28"/>
  
        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remarks</th>
        </tr>
  
        <tr>
          <td>(6)</td>
          <td><c>T::parser_type&lt;K, A></c></td>
          <td></td>
          <td>
            <p>Shall be a type that meets the <c>TableParser</c> requirements (<xref id="table_parser.requirements"/>) for <c>Ch</c>.</p>
            <p>An object of this type holds an object of <c>A</c> and use it to allocate and deallocate buffers.</p>
          </td>
        </tr>

        <tr>
          <td>(7)</td>
          <td><c>ct(k, s)</c></td>
          <td rowspan="2"><c>T::parser_type&lt;std::decay_t&lt;decltype(k)>></c></td>
          <td rowspan="4">
            <p>Creates a table parser object <c>p</c> and returns it.</p>
            <p><c>p</c> has its tied character input object which is copy constructed (on (2) and (4)) or move constructed (on (3) and (5)) from the wrapped character input object of <c>*this</c> and
               its tied table handler object which is constructed with <c>std::move(k)</c> (if <c>k</c> is an rvalue) or with <c>k</c> (otherwise).</p>
            <p><c>p</c> refers <c>s</c> as a hint of the size (that is, the number of <c>Ch</c> objects) to allocate buffers.
              <c>s</c> can be equal to zero, which means ‘no hint’.</p>
            <p>On (4) and (5), <c>p</c> is also configured to hold a copy of <c>a</c> to allocate and deallocate buffers.</p>
          </td>
        </tr>
  
        <tr>
          <td>(8)</td>
          <td><c>rt(k, s)</c></td>
        </tr>

        <tr>
          <td>(9)</td>
          <td><c>ct(k, s, a)</c></td>
          <td rowspan="2"><c>T::parser_type&lt;std::decay_t&lt;decltype(k)>, std::decay_t&lt;decltype(a)>></c></td>
        </tr>
  
        <tr>
          <td>(10)</td>
          <td><c>rt(k, s, a)</c></td>
        </tr>
      </table>

      <p>A type <c>U</c> that meets the <c>TableSource</c> requirements is called <n>direct</n> if all of the following conditions meet
         where <c>X</c> is a type that meets the <c>TableHandler</c> requirements, that is deemed to have no buffer control, and whose <c>char_type</c> is const-qualified:</p>
      <ul>
        <li><c>U::parser_type&lt;X>::reads_direct</c> is a type idential to or derived from <c>std::true_type</c> for any <c>X</c>, and</li>
        <li>If <c>U</c> offers (6) in <xref id="table.table_source.optional"/>, then <c>U::parser_type&lt;X, B>::reads_direct</c> is a type idential or derived from <c>std::true_type</c> for any <c>X</c>
        and <c>B</c> given the type <c>B</c> meets the <c>Allocator</c> requirements for <c>std::remove_const_t&lt;X::char_type></c>.</li>
      </ul>
      <p>A type <c>U</c> that meets the <c>TableSource</c> requirements is called <n>indirect</n> if it is not direct.</p>
    </section>
  </section>

  <section id="requirements.other">
    <name>Other library-wide requirements</name>

    <p>This subclause specifies requirements that apply to the entire Commata library other than basic ones (<xref id="requirements"/>).</p>

    <section id="iterator_end.requirements">
      <name><c>IteratorEnd</c> requirements</name>

      <p>A type <c>J</c> meets the <c>IteratorEnd</c> requirements for an iterator type <c>I</c> if:</p>
      <ul>
        <li><c>J</c> meets the <c>CopyConstructible</c>, <c>CopyAssignable</c> and <c>Destructible</c> requirements,</li>
        <li><c>std::declval&lt;const I&amp;>() == std::declval&lt;const J&amp;>()</c> is well-formed when treated as an unevaluated operand and is able to be contextually converted to <c>bool</c>.</li>
      </ul>
      <p><span class="note">That a type <c>J</c> meets this requirements for an iterator type <c>I</c> means that an object of <c>J</c> can work as a so-called &#x2018;sentinel&#x2019; of a range that contains an element pointed by an object of <c>I</c>.</span></p>
    </section>

    <section id="accessible_range.requirements">
      <name><c>AccessibleRange</c> and <c>ForwardAccessibleRange</c> requirements</name>

      <p>A non-reference type <c>R</c> meets the <c>AccessibleRange</c> requirements for a type <c>E</c> if:</p>
      <ul>
        <li><c>std::cbegin(std::declval&lt;const R&amp;>())</c> and <c>std::cend(std::declval&lt;const R&amp;>())</c> are well-formed when treated as unevaluated operands,</li>
        <li>The type of the expression <c>std::cbegin(std::declval&lt;const R&amp;>())</c> is an input iterator type whose value type <c>D</c> satisfies that <c>std::is_convertible_v&lt;D, E></c> is <c>true</c>, and</li>
        <li>The type of the expression <c>std::cend(std::declval&lt;const R&amp;>())</c> meets the <c>IteratorEnd</c> requirements for the type of the expression <c>std::cbegin(std::declval&lt;const R&amp;>())</c>.</li>
      </ul>

      <p>A type <c>R</c> meets the <c>ForwardAccessibleRange</c> requirements for a type <c>E</c> if:</p>
      <ul>
        <li><c>R</c> meets the <c>AccessibleRange</c> requirements, and</li>
        <li>The type of the expression <c>std::cbegin(std::declval&lt;const R&amp;>())</c> is a forward iterator type (not necessarily a mutable iterator type).</li>
      </ul>
    </section>

    <section id="form_accessible_range">
      <name>Forming an accessible range</name>

      <p>In this subclause, let <c>f</c> and <c>l</c> are expressions, and let <c>F</c> and <c>L</c> are the types of <c>f</c> and <c>l</c> respectively.</p>

      <p><c>f</c> and <c>l</c> <n>form an accessible range</n> for a type <c>T</c> if and only if:</p>
      <ul>
        <li><c>F</c> is a input iterator type whose value type <c>U</c> satisfies that <c>std::is_convertible_v&lt;U, T></c> is <c>true</c>,</li>
        <li><c>L</c> meets the <c>IteratorEnd</c> requirements for <c>F</c> (<xref id="iterator_end.requirements"/>), and</li>
        <li>there exists an non-negative integer <c>n</c> whose type is <c>std::iterator_traits&lt;F>::difference_type</c> that satisfies:
            <ul>
              <li><c>std::next(f, n) == l</c> holds <c>true</c>, and</li>
              <li>for each integer <c>i</c> in [0, <c>n</c>), <c>std::next(f, i)</c> is dereferenceable and <c>std::next(f, i) == l</c> holds <c>false</c>.</li>
            </ul>
        </li>
      </ul>

      <p>When <c>f</c> and <c>l</c> form an accessible range:</p>
      <ul>
        <li>with <c>n</c> above, the range [<c>f</c>, <c>std::next(f, n)</c>) is referred as [<c>f</c>, <c>l</c>) in shorthand,</li>
        <li>the range [<c>f</c>, <c>l</c>) is called the range <n>formed by</n> <c>f</c> and <c>l</c>, and</li>
        <li><c>n</c> above is called the <n>size</n> of the range [<c>f</c>, <c>l</c>).</li>
      </ul>

      <p>Additionally, let <c>t</c> is an expression whose type <c>T</c> meets the <c>RangeAccessible</c> requirements.
         Then if <c>std::cbegin(t)</c> and <c>std::cend(t)</c> form an accessible range, the range [<c>std::cbegin(t)</c>, <c>std::cend(t)</c>) is called the range <n>formed by</n> <c>t</c>.</p>
    </section>
  </section>
</section>

<section id="utility">
  <name>General utilities</name>

  <section id="diagnostics">
    <name>Diagnostic facilities</name>

    <section id="diagnostics.general">
      <name>General</name>
      <p>This subclause describes an exception class <c>text_error</c> (<xref id="text_error"/>), which defines the base class for the types of objects thrown while the parsers are comsuming the texts, and some facilities to access information that <c>text_error</c> objects hold.</p>
    </section>

    <section id="hpp.text_error.syn">
      <name>Header <c>"commama/text_error.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;cstddef>
#include &lt;exception>
#include &lt;optional>
#include &lt;ostream>
#include &lt;string>
#include &lt;string_view>

namespace commata {
  <c>// <n><xref id="text_error"/>, text_error:</n></c>
  class text_error;

  <c>// <n><xref id="text_error_info"/>, text_error_info:</n></c>
  class text_error_info;

  template &lt;class Tr>
    std::basic_ostream&lt;char, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;char, Tr>&amp; os,
                                             const text_error_info&amp; i);
  template &lt;class Tr>
    std::basic_ostream&lt;wchar_t, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;wchar_t, Tr>&amp; os,
                                                const text_error_info&amp; i);
  std::string to_string(const text_error_info&amp; i);
  std::wstring to_wstring(const text_error_info&amp; i);
}
      </codeblock>
    </section>

    <section id="text_error">
      <name>Class <c>text_error</c></name>

      <codeblock>
namespace commata {
  class text_error : public std::exception {
  public:
    static constexpr std::size_t npos = -1;

    <c>// <n><xref id="text_error.cons"/>, constructors and assignment operators:</n></c>
    text_error() noexcept;
    template &lt;class Tr>
      explicit text_error(std::basic_string_view&lt;char, Tr> what_arg);
    template &lt;class Tr, class Allocator>
      explicit text_error(std::basic_string&lt;char, Tr, Allocator>&amp;&amp; what_arg);
    text_error(const char* what_arg);
    text_error(const text_error&amp; other) noexcept;
    text_error(text_error&amp;&amp; other) noexcept;
    text_error&amp; operator=(const text_error&amp; other) noexcept;
    text_error&amp; operator=(text_error&amp;&amp; other) noexcept;

    const char* what() const noexcept override;

    <c>// <n><xref id="text_error.physical_position"/>, physical postion information:</n></c>
    text_error&amp; set_physical_position(std::size_t row = npos, std::size_t col = npos) noexcept;
    std::optional&lt;std::pair&lt;std::size_t, std::size_t>> get_physical_position() const noexcept;
  };
}
      </codeblock>

      <p>The class <c>text_error</c> defines the base class for the types of the objects thrown by Commata library.</p>
      <p>An object of <c>text_error</c> can optionally have a physical position information (<xref id="definitions.others"/>), which consists of the line number and the column number of the point in the input text that has made the exception thrown.
         <c>npos</c> is a special value for the line number and the column number which indicates &#x2018;no information&#x2019;.</p>

      <section id="text_error.cons">
        <name><c>text_error</c> constructors and assignment operators</name>

        <code-item>
          <code>
text_error() noexcept;
          </code>
          <postcondition><c>(*what() == '\0') &amp;&amp; !get_physical_position()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class Tr>
  explicit text_error(std::basic_string_view&lt;char, Tr> what_arg);
          </code>
          <postcondition><c>(std::strcmp(what(), w.c_str()) == 0) &amp;&amp; !get_physical_position()</c> shall be <c>true</c> where <c>w</c> is an object of <c>std::string</c> constructed with <c>what_arg</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class Tr, class Allocator>
  explicit text_error(std::basic_string&lt;char, Tr, Allocator>&amp;&amp; what_arg);
          </code>
          <postcondition><c>(std::strcmp(what(), w.c_str()) == 0) &amp;&amp; !get_physical_position()</c> shall be <c>true</c> where <c>w</c> is an object that would be copy constructed from <c>what_arg</c> before the call.</postcondition>
        </code-item>

        <code-item>
          <code>
explicit text_error(const char* what_arg);
          </code>
          <requires><c>what_arg</c> shall be a valid pointer to an element in a null terminated sequence.</requires>
          <postcondition><c>(std::strcmp(what(), what_arg) == 0) &amp;&amp; !get_physical_position()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
text_error(const text_error&amp; other) noexcept;
          </code>
          <postcondition><c>(std::strcmp(what(), other.what()) == 0) &amp;&amp; (other.get_physical_position() ? (*other.get_physical_position() == *get_physical_position()) : !get_physical_position())</c> is <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
text_error(text_error&amp;&amp; other) noexcept;
          </code>
          <postcondition><c>(std::strcmp(what(), c.what()) == 0) &amp;&amp; (c.get_physical_position() ? (*c.get_physical_position() == *get_physical_position()) : !get_physical_position())</c> shall be <c>true</c> where <c>c</c> is an object that should be copy constructed from <c>other</c> before the call.</postcondition>
        </code-item>

        <code-item>
          <code>
text_error&amp; operator=(const text_error&amp; other) noexcept;
          </code>
          <postcondition><c>(std::strcmp(what(), other.what()) == 0) &amp;&amp; (other.get_physical_position() ? (*other.get_physical_position() == *get_physical_position()) : !get_physical_position())</c> shall be <c>true</c>.</postcondition>
          <returns><c>*this</c>.</returns>
        </code-item>

        <code-item>
          <code>
text_error&amp; operator=(text_error&amp;&amp; other) noexcept;
          </code>
          <postcondition><c>(std::strcmp(what(), other.what()) == 0) &amp;&amp; (c.get_physical_position() ? (*c.get_physical_position() == *get_physical_position()) : !get_physical_position() == nullptr)</c> shall be <c>true</c> where <c>c</c> is an object that should be copy constructed from <c>other</c> before the call.</postcondition>
          <returns><c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="text_error.physical_position">
        <name><c>text_error</c> physical position information</name>

        <code-item>
          <code>
text_error&amp; set_physical_position(std::size_t line = npos, std::size_t col = npos) noexcept;
          </code>
          <postcondition>If both of <c>line</c> and <c>col</c> are equal to <c>npos</c>, <c>*this</c> holds no physical position information and <c>get_physical_position() == std::nullopt</c> shall be <c>true</c>. Otherwise, <c>*this</c> holds a physical position information and <c>*get_physical_position() == std::make_pair(line, col)</c> shall be <c>true</c>.</postcondition>
          <returns><c>*this</c>.</returns>
          <remark><c>line</c> and <c>col</c> shall be <c>npos</c> or zero-based numbers of the row and the column.
                  <c>npos</c> shall mean &#x2018;no information&#x2019;.</remark>
        </code-item>

        <code-item>
          <code>
std::optional&lt;std::pair&lt;std::size_t, std::size_t>> get_physical_position() const noexcept;
          </code>
          <returns>If <c>*this</c> holds a physical position information possibly set by the last invocation of <c>set_physical_position</c>, an pair of its line number and column number. Otherwise, <c>std::nullopt</c>.</returns>
          <remark><c>p->first</c> and <c>p->second</c> shall be <c>npos</c> or zero-based numbers of the row and the column where <c>p</c> is the return value that is not equal to <c>std::nullopt</c>.
                  <c>npos</c> shall mean &#x2018;no information&#x2019;.</remark>
        </code-item>
      </section>
    </section>

    <section id="text_error_info">
      <name>Class <c>text_error_info</c></name>

      <codeblock>
namespace commata {
  class text_error_info {
  public:
    <c>// <n><xref id="text_error_info.cons"/>, constructors and assignment operators:</n></c>
    text_error_info(const text_error&amp; ex, std::size_t base = 1) noexcept;
    text_error_info(const text_error_info&amp; other) = default;
    text_error_info&amp; operator=(const text_error_info&amp; other) = default;

    <c>// <n><xref id="text_error_info.observe"/>, observers:</n></c>
    const text_error&amp; error() const noexcept;
    std::size_t get_base() const noexcept;

  private:
    const text_error* e;  <c>// <n>exposition only</n></c>
    std::size_t b;        <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="text_error_info.char_repr"/>, chracter representations:</n></c>
  template &lt;class Tr>
    std::basic_ostream&lt;char, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;char, Tr>&amp; os,
                                             const text_error_info&amp; i);
  template &lt;class Tr>
    std::basic_ostream&lt;wchar_t, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;wchar_t, Tr>&amp; os,
                                                const text_error_info&amp; i);
  std::string to_string(const text_error_info&amp; i);
  std::wstring to_wstring(const text_error_info&amp; i);
}
      </codeblock>

      <p>An object of the class <c>text_error_info</c> is a mere reference-wrapper of an object of the class <c>text_error</c>.
         This class offers a simple character representation of objects of the class <c>text_error</c>.</p>

      <p><c>text_error_info</c> shall be a trivially copyable type.</p>

      <section id="text_error_info.cons">
        <name><c>text_error_info</c> constructors and assignment operators</name>

        <code-item>
          <code>
text_error_info(const text_error&amp; ex, std::size_t base = 1) noexcept;
          </code>
          <effects>Initializes <c>e</c> with <c>std::addressof(ex)</c> and <c>b</c> with <c>base</c>.</effects>
        </code-item>
      </section>

      <section id="text_error_info.observe">
        <name><c>text_error_info</c> observers</name>

        <code-item>
          <code>
const text_error&amp; error() const noexcept;
          </code>
          <returns><c>*e</c>.</returns>
        </code-item>

        <code-item>
          <code>
std::size_t get_base() const noexcept;
          </code>
          <returns><c>b</c>.</returns>
        </code-item>
      </section>

      <section id="text_error_info.char_repr">
        <name><c>text_error_info</c> character representations</name>

        <code-item>
          <code>
template &lt;class Tr>
  std::basic_ostream&lt;char, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;char, Tr>&amp; os,
                                           const text_error_info&amp; i);
template &lt;class Tr>
  std::basic_ostream&lt;wchar_t, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;wchar_t, Tr>&amp; os,
                                              const text_error_info&amp; i);
          </code>
          <effects>Behaves as a formatted output function of <c>os</c>.
                   Forms a character sequence <c>seq</c> of an unspecified concise character representation of <c>i.error()</c> from <c>i.error().what()</c> and <c>i.error().get_physical_position()</c>, in which the line number and the column number are <c>i.get_base()</c>-based.
                   Determines padding for <c>seq</c>. Then inserts <c>seq</c> as if by calling <c>os.rdbuf()->sputn(seq, n)</c> where <c>n</c> is the larger of <c>os.width()</c> and the size of <c>seq</c>. Then calls <c>os.width(0)</c>.</effects>
          <returns><c>os</c>.</returns>
          <remark>The second function template shall widen each character <c>c</c> in the null-terminated byte string pointed by <c>i.error().what()</c> with <c>os.widen(c)</c>.</remark>
          <note>The second function template may not recover the full information of <c>i.error().what()</c> when it is an NTMBS because of the nature of <c>std::basic_ostream&lt;wchar_t, Tr>::widen</c>.</note>
        </code-item>

        <code-item>
          <code>
std::string to_string(const text_error_info&amp; i);
std::wstring to_wstring(const text_error_info&amp; i);
          </code>
          <returns>A character representation of <c>i.error()</c> that is the same as the <c>operator&lt;&lt;</c> inserts into a stream.</returns>
        </code-item>
      </section>
    </section>

    <section id="hpp.parse_error.syn">
      <name>Header <c>"commama/parse_error.hpp"</c> synopsis</name>
      <codeblock>
#include "text_error.hpp"

namespace commata {
  <c>// <n><xref id="parse_error"/>, parse_error:</n></c>
  class parse_error;
}
      </codeblock>
    </section>

    <section id="parse_error">
      <name>Class <c>parse_error</c></name>

      <codeblock>
namespace commata {
  class parse_error : public text_error {
  public:
    using text_error::text_error;
  };
}
      </codeblock>

      <p>An exception of type <c>parse_error</c> is thrown by the parser, for example by <c>parse_csv</c> (<xref id="parse_csv"/>), when the text does not have an appropriate format.</p>
    </section>
  </section>

  <section id="handler_wrappers">
    <name>Wrappers of table handlers</name>

    <section id="hpp_wrapper_handlers.syn">
      <name>Header <c>"commama/wrapper_handlers.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;functional>

namespace commata {
  <c>// <n><xref id="reference_handler"/>, reference_handler:</n></c>
  template &lt;class Handler> class reference_handler;

  template &lt;class Handler>
    reference_handler&lt;Handler> wrap_ref(Handler&amp; handler)                        noexcept;
  template &lt;class Handler>
    reference_handler&lt;Handler> wrap_ref(std::reference_wrapper&lt;Handler> handler) noexcept;
  template &lt;class Handler>
    reference_handler&lt;Handler> wrap_ref(reference_handler&lt;Handler> handler)      noexcept;

  <c>// <n><xref id="empty_physical_line_aware_handler"/>, empty_physical_line_aware_handler:</n></c>
  template &lt;class Handler> class empty_physical_line_aware_handler;

  template &lt;class Handler> void swap(
    empty_physical_line_aware_handler&lt;Handler>&amp; left,
    empty_physical_line_aware_handler&lt;Handler>&amp; right) noexcept(noexcept(left.swap(right)));

  template &lt;class HandlerR>
    <nc>see below</nc>
      make_empty_physical_line_aware(HandlerR&amp;&amp; handler) noexcept(<nc>see below</nc>);
  template &lt;class Handler>
    <nc>see below</nc>
      make_empty_physical_line_aware(std::reference_wrapper&lt;Handler> handler) noexcept;
}
      </codeblock>
    </section>

    <section id="reference_handler">
      <name>Class template <c>reference_handler</c></name>

      <codeblock>
namespace commata {
  template &lt;class Handler> class reference_handler {
  public:
    using char_type    = typename Handler::char_type;
    using handler_type = Handler;

    <c>// <n><xref id="reference_handler.cons"/>, construct/copy/destroy:</n></c>
    reference_handler(Handler&amp; handler) noexcept;
    reference_handler(Handler&amp;&amp; handler) = delete;
    reference_handler(const reference_handler&amp; other) noexcept;
    reference_handler&amp; operator=(const reference_handler&amp; other) noexcept;

    <c>// <n><xref id="reference_handler.access"/>, access:</n></c>
    handler_type&amp; base() const noexcept;

    <c>// <n><xref id="reference_handler.inv"/>, invocation:</n></c>
    <nc>see below</nc> get_buffer();
    <nc>see below</nc> release_buffer(char_type* buffer);
    <nc>see below</nc> start_buffer(char_type* buffer_begin, char_type* buffer_end);
    <nc>see below</nc> end_buffer(char_type* buffer_end);
    <nc>see below</nc> empty_physical_line(char_type* where);
    <nc>see below</nc> start_record(char_type* record_begin);
    <nc>see below</nc> end_record(char_type* record_end);
    <nc>see below</nc> update(char_type* first, char_type* last);
    <nc>see below</nc> finalize(char_type* first, char_type* last);
    <nc>see below</nc> yield(std::size_t p);
    <nc>see below</nc> yield_location() const;
    <nc>see below</nc> handle_exception();
  };

  template &lt;class Handler>
    reference_handler(reference_handler&lt;Handler>) -> reference_handler&lt;Handler>;

  <c>// <n><xref id="reference_handler.creation"/>, creation functions:</n></c>
  template &lt;class Handler>
    reference_handler&lt;Handler> wrap_ref(Handler&amp; handler)                        noexcept;
  template &lt;class Handler>
    reference_handler&lt;Handler> wrap_ref(std::reference_wrapper&lt;Handler> handler) noexcept;
  template &lt;class Handler>
    reference_handler&lt;Handler> wrap_ref(reference_handler&lt;Handler> handler)      noexcept;
}
      </codeblock>

      <p>An object of <c>reference_handler&lt;Handler></c> is a wrapper around a reference to an object of <c>Handler</c> that is a (possibly half-fledged) table handler type.</p>
      <p>The template parameter <c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) except that it need not meet either the <c>MoveConstructible</c> requirements or the <c>Destructible</c> requirements.</p>
      <p><c>reference_handler&lt;Handler></c> meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>Handler::char_type</c>.</p>
      <p>An instance of <c>reference_handler</c> shall be a trivially copyable type.</p>

      <section id="reference_handler.cons">
        <name><c>reference_handler</c> construct/copy/destroy</name>

        <code-item>
          <code>
reference_handler(Handler&amp; handler) noexcept;
          </code>
          <effects>Constructs an <c>reference_handler</c> object that stores a reference to <c>handler</c>.</effects>
        </code-item>

        <code-item>
          <code>
reference_handler(const reference_handler&amp; other) noexcept;
          </code>
          <effects>Constructs an <c>reference_handler</c> object that stores a reference to <c>other.base()</c>.</effects>
        </code-item>

        <code-item>
          <code>
reference_handler&amp; operator=(const reference_handler&amp; other) noexcept;
          </code>
          <postcondition><c>*this</c> stores a reference to <c>other.base()</c>.</postcondition>
        </code-item>
      </section>

      <section id="reference_handler.access">
        <name><c>reference_handler</c> access</name>

        <code-item>
          <code>
handler_type&amp; base() const noexcept;
          </code>
          <returns>The stored reference.</returns>
        </code-item>
      </section>

      <section id="reference_handler.inv">
        <name><c>reference_handler</c> invocation</name>

        <code-item>
          <code>
<nc>see below</nc> get_buffer();
          </code>
          <effects>Equivalent to: <c>return base().get_buffer();</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().get_buffer()</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> release_buffer(char_type* buffer);
          </code>
          <effects>Equivalent to: <c>return base().release_buffer(buffer);</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().release_buffer(buffer)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> start_buffer(char_type* buffer_begin, char_type* buffer_end);
          </code>
          <effects>Equivalent to: <c>return base().start_buffer(buffer_begin, buffer_end);</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().start_buffer(buffer_begin, buffer_end)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> end_buffer(char_type* buffer_end);
          </code>
          <effects>Equivalent to: <c>return base().end_buffer(buffer_end);</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().end_buffer(buffer_end)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> empty_physical_line(char_type* where);
          </code>
          <effects>Equivalent to: <c>return empty_physical_line(where);</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().empty_physical_line(where)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> start_record(char_type* record_begin);
          </code>
          <effects>Equivalent to: <c>return base().start_record(record_begin);</c></effects>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> end_record(char_type* record_end);
          </code>
          <effects>Equivalent to: <c>return base().end_record(record_end);</c></effects>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> update(char_type* first, char_type* last);
          </code>
          <effects>Equivalent to: <c>return base().update(first, last);</c></effects>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> finalize(char_type* first, char_type* last);
          </code>
          <effects>Equivalent to: <c>return base().finalize(first, last);</c></effects>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> yield(std::size_t p);
          </code>
          <effects>Equivalent to: <c>return base().yield(p);</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().yield(p)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> yield_location() const;
          </code>
          <effects>Equivalent to: <c>return base().yield_location();</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;const Handler&amp;>().yield_location()</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> handle_exception();
          </code>
          <effects>Equivalent to: <c>return base().handle_exception();</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().handle_exception()</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>
      </section>

      <section id="reference_handler.creation">
        <name><c>reference_handler</c> creation functions</name>

        <code-item>
          <code>
template &lt;class Handler>
  reference_handler&lt;Handler> wrap_ref(Handler&amp; handler) noexcept;
          </code>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) except that it need not meet either the <c>MoveConstructible</c> requirements or the <c>Destructible</c> requirements.</requires>
          <returns><c>reference_handler&lt;Handler>(handler)</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class Handler>
  reference_handler&lt;Handler> wrap_ref(std::reference_wrapper&lt;Handler> handler) noexcept;
          </code>
          <effects>Equivalent to: <c>return reference_handler&lt;Handler>(handler.get());</c></effects>
        </code-item>

        <code-item>
          <code>
template &lt;class Handler>
  reference_handler&lt;Handler> wrap_ref(reference_handler&lt;Handler> handler) noexcept;
          </code>
          <effects>Equivalent to: <c>return reference_handler&lt;Handler>(handler.base());</c></effects>
        </code-item>
      </section>
    </section>

    <section id="empty_physical_line_aware_handler">
      <name>Class template <c>empty_physical_line_aware_handler</c></name>

      <codeblock>
namespace commata {
  template &lt;class Handler> class empty_physical_line_aware_handler {
  public:
    using char_type    = typename Handler::char_type;
    using handler_type = Handler;

    <c>// <n><xref id="empty_physical_line_aware_handler.cons"/>, construct/copy/destroy:</n></c>
    explicit empty_physical_line_aware_handler(const Handler&amp;  handler) noexcept(<nc>see below</nc>);
    explicit empty_physical_line_aware_handler(      Handler&amp;&amp; handler) noexcept(<nc>see below</nc>);
    empty_physical_line_aware_handler(
      const empty_physical_line_aware_handler&amp;  other) noexcept(<nc>see below</nc>);
    empty_physical_line_aware_handler(
            empty_physical_line_aware_handler&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~empty_physical_line_aware_handler();
    empty_physical_line_aware_handler&amp; operator=(
      const empty_physical_line_aware_handler&amp;  other) noexcept(<nc>see below</nc>);
    empty_physical_line_aware_handler&amp; operator=(
            empty_physical_line_aware_handler&amp;&amp; other) noexcept(<nc>see below</nc>);

    <c>// <n><xref id="empty_physical_line_aware_handler.access"/>, access:</n></c>
    const handler_type&amp; base() const noexcept;
          handler_type&amp; base()       noexcept;

    <c>// <n><xref id="empty_physical_line_aware_handler.inv"/>, invocation:</n></c>
    <nc>see below</nc> get_buffer();
    <nc>see below</nc> release_buffer(char_type* buffer);
    <nc>see below</nc> start_buffer(char_type* buffer_begin, char_type* buffer_end);
    <nc>see below</nc> end_buffer(char_type* buffer_end);
    <nc>see below</nc> empty_physical_line(char_type* where);
    <nc>see below</nc> start_record(char_type* record_begin);
    <nc>see below</nc> end_record(char_type* record_end);
    <nc>see below</nc> update(char_type* first, char_type* last);
    <nc>see below</nc> finalize(char_type* first, char_type* last);
    <nc>see below</nc> yield(std::size_t p);
    <nc>see below</nc> yield_location() const;
    <nc>see below</nc> handle_exception();

    void swap(empty_physical_line_aware_handler&amp; other)
        noexcept(std::is_nothrow_swappable_v&lt;Handler>)
      { using std::swap; base().swap(other.base()); }
  };

  <c>// <n><xref id="empty_physical_line_aware_handler.special"/>, specialized algorithms:</n></c>
  template &lt;class Handler> void swap(
    empty_physical_line_aware_handler&lt;Handler>&amp; left,
    empty_physical_line_aware_handler&lt;Handler>&amp; right) noexcept(noexcept(left.swap(right)));

  <c>// <n><xref id="empty_physical_line_aware_handler.creation"/>, creation functions:</n></c>
  template &lt;class HandlerR>
    <nc>see below</nc>
      make_empty_physical_line_aware(HandlerR&amp;&amp; handler) noexcept(<nc>see below</nc>);
  template &lt;class Handler>
    <nc>see below</nc>
      make_empty_physical_line_aware(std::reference_wrapper&lt;Handler> handler) noexcept;
}
      </codeblock>

      <p>An object of <c>empty_physical_line_aware_handler&lt;Handler></c> is a wrapper around an object of <c>Handler</c> that is a table handler type.
         It offers functionality to translate an invocation of <c>empty_physical_line</c> to <c>start_record</c> and <c>end_record</c>.</p>
      <p>The template parameter <c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>).</p>
      <p><c>empty_physical_line_aware_handler&lt;Handler></c> meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>Handler::char_type</c>.
         It shall be a trivially copyable type if <c>std::is_trivially_copyable_v&lt;Handler></c> is <c>true</c>.</p>

      <section id="empty_physical_line_aware_handler.cons">
        <name><c>empty_physical_line_aware_handler</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit empty_physical_line_aware_handler(const Handler&amp; handler) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_copy_constructible_v&lt;Handler></c> shall be <c>true</c>.</requires>
          <effects>Constructs an <c>empty_physical_line_aware_handler</c> object that stores a <c>Handler</c> object constructed with <c>handler</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;Handler></c>.</remark>
        </code-item>

        <code-item>
          <code>
explicit empty_physical_line_aware_handler(Handler&amp;&amp; handler) noexcept(<nc>see below</nc>);
          </code>
          <effects>Constructs an <c>empty_physical_line_aware_handler</c> object that stores a <c>Handler</c> object constructed with <c>std::move(handler)</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;Handler></c>.</remark>
        </code-item>

        <code-item>
          <code>
empty_physical_line_aware_handler(
  const empty_physical_line_aware_handler&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_copy_constructible_v&lt;Handler></c> shall be <c>true</c>.</requires>
          <effects>Constructs an <c>empty_physical_line_aware_handler</c> object that stores a <c>Handler</c> object constructed with <c>other.base()</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;Handler></c>.</remark>
        </code-item>

        <code-item>
          <code>
empty_physical_line_aware_handler(
  empty_physical_line_aware_handler&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Constructs an <c>empty_physical_line_aware_handler</c> object that stores a <c>Handler</c> object constructed with <c>std::move(other.base())</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;Handler></c>.</remark>
        </code-item>

        <code-item>
          <code>
~empty_physical_line_aware_handler();
          </code>
          <effects>Destroys the stored <c>Handler</c> object.</effects>
        </code-item>

        <code-item>
          <code>
empty_physical_line_aware_handler&amp; operator=(
  const empty_physical_line_aware_handler&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects><p>Equivalent to:</p>
                 <code>base() = other.base();
return *this;</code>
          </effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_assignable_v&lt;Handler></c>.</remark>
        </code-item>

        <code-item>
          <code>
empty_physical_line_aware_handler&amp; operator=(
  empty_physical_line_aware_handler&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>base() = std::move(other.base());
return *this;</code>
          </effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_assignable_v&lt;Handler></c>.</remark>
        </code-item>
      </section>

      <section id="empty_physical_line_aware_handler.access">
        <name><c>empty_physical_line_aware_handler</c> access</name>

        <code-item>
          <code>
const handler_type&amp; base() const noexcept;
      handler_type&amp; base()       noexcept;
          </code>
          <returns>A reference to the stored <c>Handler</c> object.</returns>
        </code-item>
      </section>

      <section id="empty_physical_line_aware_handler.inv">
        <name><c>empty_physical_line_aware_handler</c> invocation</name>

        <code-item>
          <code>
<nc>see below</nc> get_buffer();
          </code>
          <effects>Equivalent to: <c>return base().get_buffer();</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().get_buffer()</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> release_buffer(char_type* buffer);
          </code>
          <effects>Equivalent to: <c>return base().release_buffer(buffer);</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().release_buffer(buffer)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> start_buffer(char_type* buffer_begin, char_type* buffer_end);
          </code>
          <effects>Equivalent to: <c>return base().start_buffer(buffer_begin, buffer_end);</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().start_buffer(buffer_begin, buffer_end)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> end_buffer(char_type* buffer_end);
          </code>
          <effects>Equivalent to: <c>return base().end_buffer(buffer_end);</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().end_buffer(buffer_end)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> empty_physical_line(char_type* where);
          </code>
          <effects>First calls <c>base().start_record(where)</c>, and unless the return type is contextually convertible to <c>bool</c> and the contextually converted value of the return value to <c>bool</c> is <c>false</c>, next calls <c>base().end_record(where)</c>.</effects>
          <returns>If both of the return types of <c>base().start_record(where)</c> and <c>base().end_record(where)</c> are <c>void</c>, the return type shall be <c>void</c>.
                   Otherwise, the return type shall be <c>bool</c>, and the return value shall be <c>true</c> unless either call of <c>base().start_record(where)</c> or <c>base().end_record(where)</c> returned a value whose type is contextually convertible to <c>bool</c> and whose contexually converted value to <c>bool</c> is <c>false</c>.</returns>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> start_record(char_type* record_begin);
          </code>
          <effects>Equivalent to: <c>return base().start_record(record_begin);</c></effects>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> end_record(char_type* record_end);
          </code>
          <effects>Equivalent to: <c>return base().end_record(record_end);</c></effects>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> update(char_type* first, char_type* last);
          </code>
          <effects>Equivalent to: <c>return base().update(first, last);</c></effects>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> finalize(char_type* first, char_type* last);
          </code>
          <effects>Equivalent to: <c>return base().finalize(first, last);</c></effects>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> yield(std::size_t p);
          </code>
          <effects>Equivalent to: <c>return base().yield(p);</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().yield(p)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> yield_location() const;
          </code>
          <effects>Equivalent to: <c>return base().yield_location();</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;const Handler&amp;>().yield_location()</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
<nc>see below</nc> handle_exception();
          </code>
          <effects>Equivalent to: <c>return base().handle_exception();</c></effects>
          <remark>This member function shall not be declared unless <c>std::declval&lt;Handler&amp;>().handle_exception()</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>
      </section>

      <section id="empty_physical_line_aware_handler.special">
        <name><c>empty_physical_line_aware_handler</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Handler> void swap(
  empty_physical_line_aware_handler&lt;Handler>&amp; left,
  empty_physical_line_aware_handler&lt;Handler>&amp; right) noexcept(noexcept(left.swap(right)));
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>This overload shall not participate in overload resolution unless <c>std::is_swappable_v&lt;Handler></c> is <c>true</c>.</remark>
        </code-item>
      </section>

      <section id="empty_physical_line_aware_handler.creation">
        <name><c>empty_physical_line_aware_handler</c> creation functions</name>

        <code-item>
          <code>
template &lt;class HandlerR>
  <nc>see below</nc>
    make_empty_physical_line_aware(HandlerR&amp;&amp; handler) noexcept(<nc>see below</nc>);
          </code>
          <preface>Let <c>Handler</c> be <c>std::decay_t&lt;HandlerR></c>.
                   Also let <c>T</c> be <c>Handler</c> if <c>Handler</c> has <c>empty_physical_line</c> member function that meets to the <c>TableHandler</c> requirements,
                   <c>empty_physical_line_aware_handler&lt;Handler></c> otherwise.</preface>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>).</requires>
          <returns>An object of <c>T</c> constructed with <c>std::forward&lt;HandlerR>(handler)</c>.</returns>
          <remark>This overload shall not participate in overload resolution unless <c>Handler</c> is not the same type as <c>std::reference_wrapper&lt;T></c> for any <c>T</c>.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible_v&lt;Handler, HandlerR&amp;&amp;></c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Handler>
  <nc>see below</nc>
    make_empty_physical_line_aware(std::reference_wrapper&lt;Handler> handler) noexcept;
          </code>
          <effects>Equivalent to: <c>return make_empty_physical_line_aware(wrap_ref(handler));</c></effects>
        </code-item>
      </section>
    </section>
  </section>

  <section id="xlate">
    <name>Text value translation</name>

    <section id="xlate.general">
      <name>General</name>
      <p>To <n>translate a text value</n> means making a value that is not necessarily a string value from a text value in a text table (<xref id="definitions.text_table"/>).
        The resulted value of the translation is called a <n>translated text value</n>.</p>
      <p>Commata offers some facilities to do these translation of text values.</p>
    </section>

    <section id="replacement_action">
      <name>Replacement action</name>

      <p>When a text value translator object fails at translation, it should take an action, hereinafter called <n>replacement action</n>, instead of make a translated text value.
          Commata offers three types for it: <n>copy</n>, <n>ignore</n> and <n>fail</n> as illustrated in <xref id="table.replacement_action"/>.</p>

      <table id="table.replacement_action">
        <caption>Types of a replacement action</caption>
        <col width="1"/><col width="2"/><col width="27"/>

        <tr>
          <th>#</th>
          <th>Type</th>
          <th>Effects</th>
        </tr>

        <tr>
          <td>(1)</td>
          <td><c>copy</c></td>
          <td>Copy constructs an object of <c>T</c> from an object installed into this replacement action and use it instead of a translated text value.</td>
        </tr>

        <tr>
          <td>(2)</td>
          <td><c>ignore</c></td>
          <td>Silently ignores the conversion error.</td>
        </tr>

        <tr>
          <td>(3)</td>
          <td><c>fail</c></td>
          <td>Throws an exception.</td>
        </tr>
      </table>
    </section>

    <section id="hpp_field_handing.syn">
      <name>Header <c>"commama/field_handling.hpp"</c> synopsis</name>
      <codeblock>
namespace commata {
  <c>// <n><xref id="replacement_action_tag"/>, replacement action tags:</n></c>
  struct replacement_fail_t {};
  inline constexpr replacement_fail_t{};

  struct replacement_ignore_t {};
  inline constexpr replacement_ignore_t{};

  <c>// <n><xref id="invoke_typing_as"/>, invoke_typing_as and invoke_with_range_typing_as:</n></c>
  template &lt;class T, class... As> decltype(auto) invoke_typing_as(As&amp;&amp;... as);
  template &lt;class T, class F, class X, class Ch, class... As>
    decltype(auto) invoke_with_range_typing_as(F&amp;&amp; f, X x, Ch* first, Ch* last, As&amp;&amp;... as);
}
      </codeblock>

      <section id="replacement_action_tag">
        <name>Replacement action tags</name>

        <codeblock>
namespace commata {
  struct replacement_fail_t {};
  inline constexpr replacement_fail_t{};

  struct replacement_ignore_t {};
  inline constexpr replacement_ignore_t{};
}
        </codeblock>

        <p>The <c>replacement_fail_t</c> struct and the <c>replacement_ignore_t</c> struct are empty types used to specify replacement actions (<xref id="replacement_action"/>).</p>
      </section>

      <section id="invoke_typing_as">
        <name>Function templates <c>invoke_typing_as</c> and <c>invoke_with_range_typing_as</c></name>

        <code-item>
          <code>
template &lt;class T, class... As> decltype(auto) invoke_typing_as(As&amp;&amp;... as);
          </code>
          <effects><p>Equivalent to:</p>
            <code>
constexpr T* n = static_cast&lt;T*>(nullptr);
if constexpr (std::is_invocable_v&lt;As..., T*>) {
  return std::invoke(std::forward&lt;As>(as)..., n);
} else {
  return std::invoke(std::forward&lt;As>(as)...);
}
      </code>
          </effects>
          <note>This function template may be useful when invoking <c>ConversionErrorHandler</c> objects (<xref id="conversion_error_handler.requirements"/>) or <c>SkippingHandler</c> objects (<xref id="skipping_handler.requirements"/>).</note>
        </code-item>

        <code-item>
          <code>
template &lt;class T, class F, class X, class Ch, class... As>
  decltype(auto) invoke_with_range_typing_as(F&amp;&amp; f, X x, Ch* first, Ch* last, As&amp;&amp;... as);
          </code>
          <effects><p>Equivalent to:</p>
            <code>
constexpr T* n = static_cast&lt;T*>(nullptr);
if constexpr (std::is_invocable_v&lt;F, X, Ch*, Ch*, As..., T*>) {
  return std::invoke(std::forward&lt;F>(f), x, first, last, std::forward&lt;As>(as)..., n);
} else if constexpr (std::is_invocable_v&lt;F, X, As..., T*>) {
  return std::invoke(std::forward&lt;F>(f), x, std::forward&lt;As>(as)..., n);
} else if constexpr (std::is_invocable_v&lt;F, X, T*>) {
  return std::invoke(std::forward&lt;F>(f), x, n);
} else if constexpr (std::is_invocable_v&lt;F, X, Ch*, Ch*, As...>) {
  return std::invoke(std::forward&lt;F>(f), x, first, last, std::forward&lt;As>(as)...);
} else if constexpr (std::is_invocable_v&lt;F, X, As...>) {
  return std::invoke(std::forward&lt;F>(f), x, std::forward&lt;As>(as)...);
} else {
  return std::invoke(std::forward&lt;F>(f), x);
}
</code>
          </effects>
          <note>This function template may be useful when invoking <c>ConversionErrorHandler</c> objects (<xref id="conversion_error_handler.requirements"/>).</note>
        </code-item>
      </section>
    </section>

    <section id="hpp_text_value_translation.syn">
      <name>Header <c>"commama/text_value_translation.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;locale>
#include &lt;optional>

#include "field_handling.hpp"
#include "text_error.hpp"

namespace commata {
  <c>// <n><xref id="xlate.builtin.exceptions"/>, exception classes:</n></c>
  class text_value_translation_error;
    class text_value_invalid_format;
      class text_value_empty;
    class text_value_out_of_range;

  <c>// <n>Conversion error tags for the ConversionErrorHandler requirements (<xref id="conversion_error_handler.requirements"/>):</n></c>
  struct invalid_format_t {};
  struct out_of_range_t {};
  struct empty_t {};

  <c>// <n><xref id="fail_if_conversion_failed"/>, fail_if_conversion_failed:</n></c>
  struct fail_if_conversion_failed;

  <c>// <n><xref id="ignore_if_conversion_failed"/>, ignore_if_conversion_failed:</n></c>
  struct ignore_if_conversion_failed;

  <c>// <n><xref id="replace_if_conversion_failed"/>, replace_if_conversion_failed:</n></c>
  template &lt;class T> class replace_if_conversion_failed;
  template &lt;class T>
    void swap(replace_if_conversion_failed&lt;T>&amp; left,
              replace_if_conversion_failed&lt;T>&amp; right) noexcept(noexcept(left.swap(right)));

  <c>// <n><xref id="is_default_translatable_arithmetic_type"/>, is_default_translatable_arithmetic_type:</n></c>
  template &lt;class T> struct is_default_translatable_arithmetic_type;
  template &lt;class T> inline constexpr bool is_default_translatable_arithmetic_type_v =
    is_default_translatable_arithmetic_type&lt;T>::value;

  <c>// <n><xref id="to_arithmetic"/>, arithmetic conversion functions:</n></c>
  template &lt;class T, class ConversionErrorHandler, class V>
    T to_arithmetic(const V&amp; v, ConversionErrorHandler&amp;&amp; handler);
  template &lt;class T, class V> T to_arithmetic(const V&amp; v);

  <c>// <n><xref id="numpunct_replacer_to_c"/>, numpunct_replacer_to_c:</n></c>
  class numpunct_replacer_to_c;
}
      </codeblock>

      <p>The header <c>"commama/text_value_translation.hpp"</c> defines some facilities to do text value translation (<xref id="xlate.general"/>).</p>
    </section>

    <section id="conversion_error_handler.requirements">
      <name><c>ConversionErrorHandler</c> requirements</name>

      <p>A <c>ConversionErrorHandler</c> type is a function object type used to instruct how to handle text translation errors to some class templates and function templates defined in this header.
         A type <c>H</c> meets the <c>ConversionErrorHandler</c> requirements for a char-like type <c>Ch</c> and the target type <c>T</c> if:</p>
      <ul>
        <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
        <li>the expressions shown in <xref id="table.conversion_error_handler.requirements"/> are valid and have the indicated semantics.</li>
      </ul>

      <p><xref id="table.conversion_error_handler.requirements"/> shows two, four or six expressions per row.
         It is required that at least one of these two expression qualifies; that is, it is not needed that more than one of them do.
         When multiple expressions in one row qualify, it shall be the first one that is selected to be evaluated.
         This selection shall be done at compile time.
         <span class="note">To evaluate these expressions as specified here, function templates <c>invoke_typing_as</c> and <c>invoke_with_range_typing_as</c> (<xref id="invoke_typing_as"/>) can be used.</span></p>

      <p>In <xref id="table.conversion_error_handler.requirements"/>, <c>h</c> is an lvalue of cv-unqualified <c>H</c>.
          <c>i</c>, <c>o</c> and <c>e</c> are values of <c>invalid_format_t</c>, <c>out_of_range_t</c> and <c>empty_t</c> respectively.
          <c>f</c> and <c>l</c> are pointers to volatile-unqualified <c>const Ch</c> object.
          The range [<c>f</c>, <c>l</c>) is the text value of the field.
          <c>l</c> can be dereferenced and points the terminating zero.
          The type of <c>s</c> is <c>int</c>.
          <c>n</c> is a null pointer whose type is <c>T*</c>.</p>

      <table id="table.conversion_error_handler.requirements">
        <caption><c>ConversionErrorHandler</c> requirements</caption>
        <col width="1"/><col width="3"/><col width="3"/><col width="16"/>

        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remarks</th>
        </tr>

        <tr>
          <td rowspan="4">(1)</td>
          <td><c>h(i, f, l, n)</c></td>
          <td rowspan="4">Convertible to <c>std::optional&lt;T></c></td>
          <td rowspan="4">Evaluated when the corresponding text value can not be converted a value of <c>T</c> due to a format error.</td>
        </tr>
        <tr>
          <td><c>h(i, n)</c></td>
        </tr>
        <tr>
          <td><c>h(i, f, l)</c></td>
        </tr>
        <tr>
          <td><c>h(i)</c></td>
        </tr>

        <tr>
          <td rowspan="6">(2)</td>
          <td><c>h(o, f, l, s, n)</c></td>
          <td rowspan="6">Convertible to <c>std::optional&lt;T></c></td>
          <td rowspan="6">Evaluated when the corresponding text value can not be converted a value of <c>T</c> due to a range error.
                          The value of <c>s</c> shall be positive if the text value shall represent a value above the range of <c>T</c>, negative if it shall do a value below it, or <c>0</c> otherwise.</td>
        </tr>
        <tr>
          <td><c>h(o, s, n)</c></td>
        </tr>
        <tr>
          <td><c>h(o, n)</c></td>
        </tr>
        <tr>
          <td><c>h(o, f, l, s)</c></td>
        </tr>
        <tr>
          <td><c>h(o, s)</c></td>
        </tr>
        <tr>
          <td><c>h(o)</c></td>
        </tr>

        <tr>
          <td rowspan="2">(3)</td>
          <td><c>h(e, n)</c></td>
          <td rowspan="2">Convertible to <c>std::optional&lt;T></c></td>
          <td rowspan="2">Evaluated when the corresponding text value is empty.</td>
        </tr>
        <tr>
          <td><c>h(e)</c></td>
        </tr>
      </table>
    </section>

    <section id="xlate.builtin.exceptions">
      <name>Exception classes for text value translation error</name>

      <section id="text_value_translation_error">
        <name>Class <c>text_value_translation_error</c></name>

        <codeblock>
namespace commata {
  class text_value_translation_error : public text_error {
  public:
    using text_error::text_error;
  };
}
        </codeblock>

        <p>The class <c>text_value_translation_error</c> defines the type of the objects thrown by default text value translators of Commata library.</p>
      </section>

      <section id="text_value_invalid_format">
        <name>Class <c>text_value_invalid_format</c></name>

        <codeblock>
namespace commata {
  class text_value_invalid_format : public text_value_translation_error {
  public:
    using text_value_translation_error::text_value_translation_error;
  };
}
        </codeblock>

        <p>The class <c>text_value_invalid_format</c> defines the type of the objects thrown by default text value translators of Commata library to report text value format errors.</p>
      </section>

      <section id="text_value_empty">
        <name>Class <c>text_value_empty</c></name>

        <codeblock>
namespace commata {
  class text_value_empty : public text_value_invalid_format {
  public:
    using text_value_invalid_format::text_value_invalid_format;
  };
}
        </codeblock>

        <p>The class <c>text_value_empty</c> defines the type of the objects thrown by default text value translators of Commata library to report an empty text value.</p>
      </section>

      <section id="text_value_out_of_range">
        <name>Class <c>text_value_out_of_range</c></name>

        <codeblock>
namespace commata {
  class text_value_out_of_range : public text_value_translation_error {
  public:
    using text_value_translation_error::text_value_translation_error;
  };
}
        </codeblock>

        <p>The class <c>text_value_out_of_range</c> defines the type of the objects thrown by default text value translators of Commata library to report they found a translated text value out of its domain.</p>
      </section>
    </section>

    <section id="xlate.builtin.conversion_error_handlers">
      <name>Default conversion error handler classes</name>

      <section id="xlate.builtin.conversion_error_handlers.general">
        <name>General</name>

        <p>This subclause describes struct <c>fail_if_conversion_failed</c> (<xref id="fail_if_conversion_failed"/>), struct <c>ignore_if_conversion_failed</c> (<xref id="ignore_if_conversion_failed"/>), and class template <c>replace_if_conversion_failed</c> (<xref id="replace_if_conversion_failed"/>),
           which gives the default conversion error handler (<xref id="conversion_error_handler.requirements"/>) types of Commata.</p>
        <p>When the implementations of these throw an exception whose type is <c>text_error</c> or one of its derived classes, the message retrieved with a call to <c>what</c> member function on the exception object may be an NTMBS converted from an wide character string with <c>std::wcrtomb</c> or <c>std::wcsrtombs</c>, that is, with the C library locale.</p>
      </section>

      <section id="fail_if_conversion_failed">
        <name>Struct <c>fail_if_conversion_failed</c></name>

        <codeblock>
namespace commata {
  struct fail_if_conversion_failed {
    explicit fail_if_conversion_failed(replacement_fail_t = replacement_fail) {}

    template &lt;class T, class Ch>
      [[noreturn]] T operator()(invalid_format_t, const Ch*, const Ch*, T* = nullptr) const;
    template &lt;class T, class Ch>
      [[noreturn]] T operator()(out_of_range_t, const Ch*, const Ch*, int, T* = nullptr) const;
    template &lt;class T>
      [[noreturn]] T operator()(empty_t, T* = nullptr) const;
  };
}
        </codeblock>

        <p>The struct <c>fail_if_conversion_failed</c> is a type that meets the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>) for any target types.
           An object of it makes the text value translation process fail on any conversion errors.</p>

        <code-item>
          <code>
template &lt;class T, class Ch>
  [[noreturn]] T operator()(invalid_format_t, const Ch*, const Ch*, T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>text_value_invalid_format</c> (<xref id="text_value_invalid_format"/>).</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class T, class Ch>
  [[noreturn]] T operator()(out_of_range_t, const Ch*, const Ch*, int, T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>text_value_out_of_range</c> (<xref id="text_value_out_of_range"/>).</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class T>
  [[noreturn]] T operator()(empty_t, T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>text_value_empty</c> (<xref id="text_value_empty"/>).</effects>
        </code-item>
      </section>

      <section id="ignore_if_conversion_failed">
        <name>Struct <c>ignore_if_conversion_failed</c></name>

        <codeblock>
namespace commata {
  struct ignore_if_conversion_failed {
    explicit ignore_if_conversion_failed(replacement_ignore_t = replacement_ignore) {}

    std::nullopt_t operator()(invalid_format_t) const;
    std::nullopt_t operator()(out_of_range_t) const;
    std::nullopt_t operator()(empty_t) const;
  };
}
        </codeblock>

        <p>The struct <c>ignore_if_conversion_failed</c> is a type that meets the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>) for any target types.
           An object of it makes the text value translation process ignore all conversion errors without producing any target type values.</p>

        <code-item>
          <code>
std::nullopt_t operator()(invalid_format_t) const;
std::nullopt_t operator()(out_of_range_t) const;
std::nullopt_t operator()(empty_t) const;
          </code>
          <returns><c>std::nullopt</c>.</returns>
        </code-item>
      </section>

      <section id="replace_if_conversion_failed">
        <name>Class template <c>replace_if_conversion_failed</c></name>

        <codeblock>
namespace commata {
  template &lt;class T> class replace_if_conversion_failed {
  public:
    <c>// <n><xref id="replace_if_conversion_failed.props"/>, properties:</n></c>
    using value_type = T;
    static constexpr std::size_t size = <nc>see below</nc>;

    <c>// <n><xref id="replace_if_conversion_failed.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class All = T>
      explicit replace_if_conversion_failed(const All&amp; for_all = All()) noexcept(<nc>see below</nc>);
    template &lt;class Empty, class AllButEmpty>
      replace_if_conversion_failed(Empty&amp;&amp;            on_empty,
                                   const AllButEmpty&amp; for_all_but_empty) noexcept(<nc>see below</nc>);
    template &lt;class Empty, class InvalidFormat, class AllOutOfRanges>
      replace_if_conversion_failed(Empty&amp;&amp;               on_empty,
                                   InvalidFormat&amp;&amp;       on_invalid_format,
                                   const AllOutOfRanges&amp; for_all_out_of_ranges) noexcept(<nc>see below</nc>);
    template &lt;class Empty, class InvalidFormat, class AboveUpperLimit>
      replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                                   InvalidFormat&amp;&amp;   on_invalid_format,
                                   AboveUpperLimit&amp;&amp; on_above_upper_limit) noexcept(<nc>see below</nc>);
    template &lt;class Empty, class InvalidFormat, class AboveUpperLimit, class BelowLowerLimit>
      replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                                   InvalidFormat&amp;&amp;   on_invalid_format,
                                   AboveUpperLimit&amp;&amp; on_above_upper_limit,
                                   BelowLowerLimit&amp;&amp; on_below_lower_limit) noexcept(<nc>see below</nc>);
    template &lt;class Empty, class InvalidFormat, class AboveUpperLimit, class BelowLowerLimit,
              class Underflow>
      replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                                   InvalidFormat&amp;&amp;   on_invalid_format,
                                   AboveUpperLimit&amp;&amp; on_above_upper_limit,
                                   BelowLowerLimit&amp;&amp; on_below_lower_limit,
                                   Underflow&amp;&amp;       on_underflow) noexcept(<nc>see below</nc>);
    replace_if_conversion_failed(const replace_if_conversion_failed&amp;  other) noexcept(<nc>see below</nc>);
    replace_if_conversion_failed(      replace_if_conversion_failed&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~replace_if_conversion_failed();
    replace_if_conversion_failed&amp; operator=(const replace_if_conversion_failed&amp;  other)
      noexcept(<nc>see below</nc>);
    replace_if_conversion_failed&amp; operator=(      replace_if_conversion_failed&amp;&amp; other)
      noexcept(<nc>see below</nc>);

    <c>// <n><xref id="replace_if_conversion_failed.inv"/>, invocation:</n></c>
    template &lt;class Ch, class U = T>
      std::optional&lt;U> operator()(invalid_format_t, const Ch*, const Ch*, U* = nullptr) const;
    template &lt;class Ch, class U = T>
      std::optional&lt;U> operator()(out_of_range_t, const Ch*, const Ch*, int sign, U* = nullptr) const;
    template &lt;class Ch, class U = T>
      std::optional&lt;U> operator()(empty_t, U* = nullptr) const;

    <c>// <n><xref id="replace_if_conversion_failed.modifiers"/>, modifiers:</n></c>
    void swap(replace_if_conversion_failed&amp; other) noexcept(<nc>see below</nc>);
  };

  template &lt;class... Ts>
    replace_if_conversion_failed(Ts...) -> replace_if_conversion_failed&lt;<nc>see below</nc>>;

  <c>// <n><xref id="replace_if_conversion_failed.special"/>, specialized algorithms:</n></c>
  template &lt;class T>
    void swap(replace_if_conversion_failed&lt;T>&amp; left,
              replace_if_conversion_failed&lt;T>&amp; right) noexcept(noexcept(left.swap(right)));
}
        </codeblock>

        <p>The class template <c>replace_if_conversion_failed</c> offers types that meet the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>) whose target type is the template parameter <c>T</c>.
           On a conversion error, an object of them can make the text value translation process fail, ignore it, or offer a substitution of the field value, depending on the category of the error.</p>
        <p><c>T</c> shall meet the <c>CopyConstructible</c> requirements and the <c>Destructible</c> requirements.
           <c>T</c> shall not be equal to possibly cv-qualified types <c>replacement_fail_t</c> or <c>replacement_ignore_t</c>.</p>
        <p><c>replace_if_conversion_failed&lt;T></c> shall be a trivially copyable type if <c>std::is_trivially_copyable_v&lt;T></c> is <c>true</c>.</p>
        <p>An object of an instance of <c>replace_if_conversion_failed</c> is configured with five replacement actions (<xref id="replacement_action"/>): <c>action_on_empty</c>, <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c>, and <c>action_on_underflow</c>.
           Each of these replacement actions is configured to be either of the three types illustrated in <xref id="table.replacement_action"/> independently for one object of <c>replace_if_conversion_failed</c>.</p>
        <p>In this subclause, a replacement action <c>r</c> of an object of <c>replace_if_conversion_failed</c> is called <n>unconfigurable</n> if:</p>
        <ul>
          <li><c>r</c> is <c>action_on_below_lower_limit</c> or <c>action_on_underflow</c> when <c>T</c> is an unsigned integer type, or</li>
          <li><c>r</c> is <c>action_on_underflow</c> when <c>T</c> is an signed integer type.</li>
        </ul>
        <p>Similarly, a replacement action of an object of <c>replace_if_conversion_failed</c> is called <n>configurable</n> if it is not unconfigurable.</p>
        <p>Each unconfigurable replacement action of an object of <c>replace_if_conversion_failed</c> is fixed to be <c>fail</c>.</p>
        <p><span class="note">For types <c>T</c> and <c>U</c> that satisfy <c>std::is_convertible_v&lt;const T&amp;, U></c> is <c>true</c>, <c>replace_if_conversion_failed&lt;T></c> meets the <c>ConversionErrorHandler</c> requirements for not only <c>T</c> but also <c>U</c> as its target type.</span></p>

        <section id="replace_if_conversion_failed.props">
          <name><c>replace_if_conversion_failed</c> properties</name>

          <code-item>
            <code>
static constexpr std::size_t size = <nc>see below</nc>;
            </code>
            <remark><p>The expression in the right of <c>=</c> in the initializer shall be the number of configurable replacement actions, thus shall be:</p>
                    <ul>
                      <li><c>3</c> if <c>T</c> is an unsigned integer type,</li>
                      <li><c>4</c> if <c>T</c> is a signed integer type,</li>
                      <li><c>5</c> otherwise.</li>
                    </ul>
            </remark>
          </code-item>
        </section>

        <section id="replace_if_conversion_failed.cons">
          <name><c>replace_if_conversion_failed</c> construct/copy/destroy</name>

          <p>In this subclause, a type <c>A</c> <n>implies a fail action</n> if and only if <c>std::is_base_of_v&lt;replacement_fail_t, std::decay_t&lt;A>></c> is <c>true</c>.
             Similarly, a type <c>A</c> <n>implies an ignore action</n> if and only if <c>std::is_base_of_v&lt;replacement_ignore_t, std::decay_t&lt;A>></c> is <c>true</c>.
             In addition, let <c><nc>IS_ACCEPTABLE</nc>&lt;A></c> be a <c>bool</c> value that is <c>true</c> if and only if:</p>
          <ul>
            <li><c>A</c> implies a fail action,</li>
            <li><c>A</c> implies an ignore action,</li>
            <li><c>std::is_contructible_v&lt;T, A&amp;&amp;></c> is <c>true</c>.</li>
          </ul>
          <p>And let <c><nc>IS_NOTHROW_ACCEPTABLE</nc>&lt;A></c> be a <c>bool</c> value that is <c>true</c> if and only if:</p>
          <ul>
            <li><c>A</c> implies a fail action,</li>
            <li><c>A</c> implies an ignore action,</li>
            <li><c>std::is_nothrow_contructible_v&lt;T, A&amp;&amp;></c> is <c>true</c>.</li>
          </ul>
          <p>To <n>arrage</n> a replacement action from an expression <c>a</c> means:</p>
          <ul>
            <li>if <c>decltype(a)</c> implies a fail action, the replace action is configured to be <c>fail</c>,</li>
            <li>if <c>decltype(a)</c> implies a ignore action, the replace action is configured to be <c>ignore</c>,</li>
            <li>otherwise, the replace action is configured to be <c>copy</c> with an object of <c>T</c> constructed from <c>a</c>.</li>
          </ul>
          <p>To <n>move-arrage</n> a replacement action from an lvalue <c>a</c> means to arrange a replacement action from <c>std::move(a)</c>.</p>

          <code-item>
            <code>
template &lt;class All = T>
  explicit replace_if_conversion_failed(const All&amp; for_all = All()) noexcept(<nc>see below</nc>);
            </code>
            <effects>Arranges all configurable replacement actions from <c>for_all</c>.</effects>
            <remark>This overload shall not participate in overload resolution unless <c><nc>IS_ACCEPTABLE</nc>&lt;const All&amp;></c> is <c>true</c>.
                    The expression inside <c>noexcept</c> is equvalent to <c><nc>IS_NOTHROW_ACCEPTABLE</nc>&lt;T, const All&amp;></c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Empty, class AllButEmpty>
  replace_if_conversion_failed(Empty&amp;&amp;            on_empty,
                               const AllButEmpty&amp; for_all_but_empty) noexcept(<nc>see below</nc>);
            </code>
            <effects>Move-arranges <c>action_on_empty</c> from <c>on_empty</c>.
                     Arranges all other configurable replacement actions from <c>for_all_but_empty</c>.</effects>
            <remark>This overload shall not participate in overload resolution if any of <c><nc>IS_ACCEPTABLE</nc>&lt;U></c> is <c>false</c> for each type <c>U</c> in <c>Empty&amp;&amp;</c> and <c>const AllButEmpty&amp;</c>.
                    The expression inside <c>noexcept</c> is <c>true</c> if and only if none of <c><nc>IS_NOTHROW_ACCEPTABLE</nc>&lt;U></c> is <c>false</c> for each type <c>U</c> in <c>Empty&amp;&amp;</c> and <c>const AllButEmpty&amp;</c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Empty, class InvalidFormat, class AllOutOfRanges>
  replace_if_conversion_failed(Empty&amp;&amp;               on_empty,
                               InvalidFormat&amp;&amp;       on_invalid_format,
                               const AllOutOfRanges&amp; for_all_out_of_ranges) noexcept(<nc>see below</nc>);
            </code>
            <effects>Move-arranges <c>action_on_empty</c> and <c>action_on_invalid_format</c> from <c>on_empty</c> and <c>on_invalid_format</c> respectively.
                     Arranges all other configurable replacement actions from <c>for_all_out_of_ranges</c>.</effects>
            <remark>This overload shall not be declared if <c>T</c> is an unsigned integer type.
                    It shall not participate in overload resolution if any of <c><nc>IS_ACCEPTABLE</nc>&lt;U></c> is <c>false</c> for each type <c>U</c> in <c>Empty&amp;&amp;</c>, <c>InvalidFormat&amp;&amp;</c> and <c>const AllOutOfRanges&amp;</c>.
                    The expression inside <c>noexcept</c> is <c>true</c> if and only if none of <c><nc>IS_NOTHROW_ACCEPTABLE</nc>&lt;U></c> is <c>false</c> for each type <c>U</c> in <c>Empty&amp;&amp;</c>, <c>InvalidFormat&amp;&amp;</c> and <c>const AllOutOfRanges&amp;</c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Empty, class InvalidFormat, class AboveUpperLimit>
  replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                               InvalidFormat&amp;&amp;   on_invalid_format,
                               AboveUpperLimit&amp;&amp; on_above_upper_limit) noexcept(<nc>see below</nc>);
            </code>
            <effects>Move-arranges <c>action_on_empty</c>, <c>action_on_invalid_format</c> and <c>action_on_above_upper_limit</c> from <c>on_empty</c>, <c>on_invalid_format</c> and <c>on_above_upper_limit</c> respectively.
                     Configures <c>action_on_below_lower_limit</c> and <c>action_on_underflow</c> to be <c>fail</c>.</effects>
            <remark>This overload shall not be declared unless <c>T</c> is an unsigned integer type.
                    It shall not participate in overload resolution if any of <c><nc>IS_ACCEPTABLE</nc>&lt;U&amp;&amp;></c> is <c>false</c> for each type <c>U</c> in <c>Empty</c>, <c>InvalidFormat</c> and <c>AboveUpperLimit</c>.
                    The expression inside <c>noexcept</c> is <c>true</c> if and only if none of <c><nc>IS_NOTHROW_ACCEPTABLE</nc>&lt;U&amp;&amp;></c> is <c>false</c> for each type <c>U</c> in <c>Empty</c>, <c>InvalidFormat</c> and <c>AboveUpperLimit</c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Empty, class InvalidFormat, class AboveUpperLimit, class BelowLowerLimit>
  replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                               InvalidFormat&amp;&amp;   on_invalid_format,
                               AboveUpperLimit&amp;&amp; on_above_upper_limit,
                               BelowLowerLimit&amp;&amp; on_below_lower_limit) noexcept(<nc>see below</nc>);
            </code>
            <effects>Move-arranges <c>action_on_empty</c>, <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c> and <c>action_on_below_lower_limit</c> from <c>on_empty</c>, <c>on_invalid_format</c>, <c>on_above_upper_limit</c> and <c>on_below_lower_limit</c> respectively.
                     Configures <c>action_on_underflow</c> to be <c>fail</c>.</effects>
            <remark>This overload shall not be declared unless <c>T</c> is an signed integer type.
                    It shall not participate in overload resolution if any of <c><nc>IS_ACCEPTABLE</nc>&lt;U&amp;&amp;></c> is <c>false</c> for each type <c>U</c> in <c>Empty</c>, <c>InvalidFormat</c>, <c>AboveUpperLimit</c> and <c>BelowLowerLimit</c>.
                    The expression inside <c>noexcept</c> is <c>true</c> if and only if none of <c><nc>IS_NOTHROW_ACCEPTABLE</nc>&lt;U&amp;&amp;></c> is <c>false</c> for each type <c>U</c> in <c>Empty</c>, <c>InvalidFormat</c>, <c>AboveUpperLimit</c> and <c>BelowLowerLimit</c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Empty, class InvalidFormat, class AboveUpperLimit, class BelowLowerLimit,
          class Underflow>
  replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                               InvalidFormat&amp;&amp;   on_invalid_format,
                               AboveUpperLimit&amp;&amp; on_above_upper_limit,
                               BelowLowerLimit&amp;&amp; on_below_lower_limit,
                               Underflow&amp;&amp;       on_underflow) noexcept(<nc>see below</nc>);
            </code>
            <effects>Move-arranges <c>action_on_empty</c>, <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c> and <c>action_on_underflow</c> from <c>on_empty</c>, <c>on_invalid_format</c>, <c>on_above_upper_limit</c>, <c>on_below_lower_limit</c> and <c>on_below_lower_limit</c> respectively.</effects>
            <remark>This overload shall not be declared if <c>T</c> is an integer type.
                    It shall not participate in overload resolution if any of <c><nc>IS_ACCEPTABLE</nc>&lt;U&amp;&amp;></c> is <c>false</c> for each type <c>U</c> in <c>Empty</c>, <c>InvalidFormat</c>, <c>AboveUpperLimit</c>, <c>BelowLowerLimit</c> and <c>Underflow</c>.
                    The expression inside <c>noexcept</c> is <c>true</c> if and only if none of <c><nc>IS_NOTHROW_ACCEPTABLE</nc>&lt;U&amp;&amp;></c> is <c>false</c> for each type <c>U</c> in <c>Empty</c>, <c>InvalidFormat</c>, <c>AboveUpperLimit</c>, <c>BelowLowerLimit</c> and <c>Underflow</c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_conversion_failed(const replace_if_conversion_failed&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures all the replacement actions to be the same as <c>other</c>&#x2019;s.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;T></c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_conversion_failed(replace_if_conversion_failed&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures all the replacement actions to be what <c>other</c> had as its replacement actions before the call.</effects>
            <remark>If exits via an exception, <c>other</c> will be left in a valid but unspecified state.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;T></c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class... Ts>
  replace_if_conversion_failed(Ts...) -> replace_if_conversion_failed&lt;<nc>see below</nc>>;
            </code>
            <remark>This deduction guide participates in overload resolution if and only if <c>std::common_type_t&lt;Us...></c> is defined where <c>Us</c> denotes types in <c>Ts...</c> excluding types which imply neither a fail action nor a ignore action.
                    In that case, the deduced type is <c>std::common_type_t&lt;Us...></c> above.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_conversion_failed&amp; operator=(const replace_if_conversion_failed&amp; other)
  noexcept(<nc>see below</nc>);
            </code>
            <requires><c>T</c> shall be <c>CopyAssignable</c>.</requires>
            <effects>Configures all the replacement actions to be the same as <c>other</c>&#x2019;s.</effects>
            <returns><c>*this</c>.</returns>
            <remark>If exits via an exception, <c>*this</c> will be left in a valid but unspecified state.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;T> &amp;&amp; std::is_nothrow_copy_assignable_v&lt;T></c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_conversion_failed&amp; operator=(replace_if_conversion_failed&amp;&amp; other)
  noexcept(<nc>see below</nc>);
            </code>
            <requires><c>T</c> shall be <c>MoveAssignable</c>.</requires>
            <effects>Configures all the replacement actions to be what <c>other</c> had as its replacement actions before the call.</effects>
            <returns><c>*this</c>.</returns>
            <remark>If exits via an exception, <c>*this</c> and <c>other</c> will be left in a valid but unspecified state.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;T> &amp;&amp; std::is_nothrow_move_assignable_v&lt;T></c>.</remark>
          </code-item>
        </section>

        <section id="replace_if_conversion_failed.inv">
          <name><c>replace_if_conversion_failed</c> invocation</name>

          <code-item>
            <code>
template &lt;class Ch, class U = T>
  std::optional&lt;U> operator()(invalid_format_t, const Ch*, const Ch*, U* = nullptr) const;
            </code>
            <effects>Does as illustrated in <xref id="table.replace_if_conversion_failed.invalid_format"/> in reference to the <c>action_on_invalid_format</c> of <c>*this</c>.</effects>
            <remark>This overload shall not participate in overload resolution unless <c>std::is_convertible_v&lt;const T&amp;, U></c> is <c>true</c>.</remark>

            <table id="table.replace_if_conversion_failed.invalid_format">
              <caption>Effects of invocation with <c>invalid_format_t</c></caption>
              <col width="5"/><col width="8"/><col width="5"/><col width="18"/>

              <tr>
                <th>#</th>
                <th>Referenced action</th>
                <th>Type of the action</th>
                <th>Effects</th>
              </tr>

              <tr>
                <td>(1)</td>
                <td rowspan="3"><c>action_on_invalid_format</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>std::optional&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(2)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>std::none</c>.</td>
              </tr>

              <tr>
                <td>(3)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>text_value_invalid_format</c> (<xref id="text_value_invalid_format"/>).</td>
              </tr>
            </table>
          </code-item>

          <code-item>
            <code>
template &lt;class Ch, class U = T>
  std::optional&lt;U> operator()(out_of_range_t, const Ch*, const Ch*, int sign, U* = nullptr) const;
            </code>
            <effects>Does as illustrated in <xref id="table.replace_if_conversion_failed.out_of_range"/> in reference to <c>sign</c> and the <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c> and <c>action_on_underflow</c> of <c>*this</c>.</effects>
            <remark>This overload shall not participate in overload resolution unless <c>std::is_convertible_v&lt;const T&amp;, U></c> is <c>true</c>.</remark>

            <table id="table.replace_if_conversion_failed.out_of_range">
              <caption>Effects of invocation with <c>out_of_range_t</c></caption>
              <col width="2"/><col width="3"/><col width="8"/><col width="5"/><col width="18"/>

              <tr>
                <th>#</th>
                <th><c>sign</c></th>
                <th>Referenced action</th>
                <th>Type of the action</th>
                <th>Effects</th>
              </tr>

              <tr>
                <td>(1)</td>
                <td rowspan="3">positive</td>
                <td rowspan="3"><c>action_on_above_upper_limit</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>std::optional&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(2)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>std::none</c>.</td>
              </tr>

              <tr>
                <td>(3)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>text_value_out_of_range</c> (<xref id="text_value_out_of_range"/>).</td>
              </tr>

              <tr>
                <td>(4)</td>
                <td rowspan="3">negative</td>
                <td rowspan="3"><c>action_on_below_lower_limit</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>std::optional&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(5)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>std::none</c>.</td>
              </tr>

              <tr>
                <td>(6)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>text_value_out_of_range</c> (<xref id="text_value_out_of_range"/>).</td>
              </tr>

              <tr>
                <td>(7)</td>
                <td rowspan="3"><c>0</c></td>
                <td rowspan="3"><c>action_on_underflow</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>std::optional&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(8)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>std::none</c>.</td>
              </tr>

              <tr>
                <td>(9)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>text_value_out_of_range</c> (<xref id="text_value_out_of_range"/>).</td>
              </tr>
            </table>
          </code-item>

          <code-item>
            <code>
template &lt;class Ch, class U = T>
  std::optional&lt;U> operator()(empty_t, U* = nullptr) const;
            </code>
            <effects>Does as illustrated in <xref id="table.replace_if_conversion_failed.empty"/> in reference to the <c>action_on_empty</c> of <c>*this</c>.</effects>
            <remark>This overload shall not participate in overload resolution unless <c>std::is_convertible_v&lt;const T&amp;, U></c> is <c>true</c>.</remark>

            <table id="table.replace_if_conversion_failed.empty">
              <caption>Effects of invocation with <c>empty_t</c></caption>
              <col width="5"/><col width="8"/><col width="5"/><col width="18"/>

              <tr>
                <th>#</th>
                <th>Referenced action</th>
                <th>Type of the action</th>
                <th>Effects</th>
              </tr>

              <tr>
                <td>(1)</td>
                <td rowspan="3"><c>action_on_empty</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>std::optional&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(2)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>std::none</c>.</td>
              </tr>

              <tr>
                <td>(3)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>text_value_empty</c> (<xref id="text_value_empty"/>).</td>
              </tr>
            </table>
          </code-item>
        </section>

        <section id="replace_if_conversion_failed.modifiers">
          <name><c>replace_if_conversion_failed</c> modifiers</name>

          <code-item>
            <code>
void swap(replace_if_conversion_failed&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires>For each of at most five replacement actions (<c>action_on_empty</c>, <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c> and <c>action_on_underflow</c>),
                      if both of the replacement action of <c>*this</c> and <c>other</c> are of the type <c>copy</c>, two lvalues of the object of type <c>T</c> installed with the replacement action shall be swappable with each other.</requires>
            <effects>Exchanges all the replacement actions between <c>*this</c> and <c>other</c>.</effects>
            <remark>If exits via an exception, <c>*this</c> and <c>other</c> will be left in a valid but unspecified state.
                    The expression inside <c>noexcept</c> is equivalent to the value of <c>std::is_nothrow_move_constructible_v&lt;T> &amp;&amp; noexcept(swap(std::declval&lt;T&amp;>(), std::declval&lt;T&amp;>()))</c> evaluated in a context where <c>std::swap</c> participates in the overload resolution.</remark>
          </code-item>
        </section>

        <section id="replace_if_conversion_failed.special">
          <name><c>replace_if_conversion_failed</c> specialized algorithms</name>

          <code-item>
            <code>
template &lt;class T>
  void swap(replace_if_conversion_failed&lt;T>&amp; left,
            replace_if_conversion_failed&lt;T>&amp; right) noexcept(noexcept(left.swap(right)));
            </code>
            <effects>Equivalent to: <c>left.swap(right);</c></effects>
            <remark>This overload shall not participate in overload resolution unless <c>std::is_swappable_v&lt;T></c> is <c>true</c>.</remark>
          </code-item>
        </section>
      </section>
    </section>

    <section id="xlate.arithmetic">
      <name>Arithmetic conversion</name>

      <p>This subclause describes the text value translation (<xref id="xlate.general"/>) facilities built-in to Commata implemented in terms of string conversion functions declared in <c>&lt;cstdlib></c>.</p>
      <p>The type of a translated text value by these facilities is either of <c>char</c>, <c>signed char</c>, <c>unsigned char</c>, <c>short</c>, <c>unsigned short</c>, <c>int</c>, <c>unsigned</c>, <c>long</c>, <c>unsigned long</c>, <c>long long</c>, <c>unsigned long long</c>, <c>float</c>, <c>double</c>, or <c>long double</c>.
         These arithmetic types are referred as <n>default translatable arithmeric types</n>.</p>

      <section id="arithmetic_convertible.requirements">
        <name><c>ArithmeticConvertible</c> requirements</name>

        <p>A type <c>T</c> meets the <c>ArithmeticConvertible</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
        <ul>
          <li>each object of <c>T</c> has its text value, which is (possibly reference to) a sequence of objects of <c>Ch</c> whose highest-addressed element with defined content has a value zero, and</li>
          <li>the expressions shown in <xref id="table.arithmetic_convertible.requirements"/> are valid and have the indicated semantics.</li>
        </ul>

        <p><xref id="table.arithmetic_convertible.requirements"/> shows two expressions per row.
           It is required that at least one of these two expression qualifies, that is, it is not needed that both of two do.</p>

        <p>In <xref id="table.arithmetic_convertible.requirements"/>, <c>ct</c> is an lvalue of <c>const T</c>.</p>

        <table id="table.arithmetic_convertible.requirements">
          <caption><c>ArithmeticConvertible</c> requirements</caption>
          <col width="2"/><col width="9"/><col width="24"/><col width="22"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remarks</th>
          </tr>

          <tr>
            <td rowspan="2">(1)</td>
            <td><c>cv.c_str()</c></td>
            <td rowspan="2"><c>const Ch*</c></td>
            <td rowspan="2">Returns a pointer to the first element of the text value.</td>
          </tr>

          <tr>
            <td><c>cv->c_str()</c></td>
          </tr>

          <tr>
            <td rowspan="2">(2)</td>
            <td><c>cv.size()</c></td>
            <td rowspan="2">An integer type whose integer conversion rank is not greater than <c>std::ptrdiff_t</c></td>
            <td rowspan="2">Returns the number of the elements of the text value.</td>
          </tr>

          <tr>
            <td><c>cv->size()</c></td>
          </tr>
        </table>

        <p>For a type <c>T</c> that meets the <c>ArithmeticConvertible</c> requirements for <c>Ch</c>, <c>Ch</c> is called the <n>character type</n> of <c>T</c>.</p>
      </section>

      <section id="is_default_translatable_arithmetic_type">
        <name>Class template <c>is_default_translatable_arithmetic_type</c></name>

        <codeblock>
namespace commata {
  template &lt;class T> struct is_default_translatable_arithmetic_type;
  template &lt;class T> inline constexpr bool is_default_translatable_arithmetic_type_v =
    is_default_translatable_arithmetic_type&lt;T>::value;
}
        </codeblock>

        <p>Class template <c>is_default_translatable_arithmetic_type</c> is a <c>UnaryTypeTrait</c> with a base characteristic of <c>std::true_type</c> if the template type argument is a default translatable arithmetic type, otherwise <c>std::false_type</c>.
           For any given type <c>T</c>, the result of applying this template to <c>T</c> and <c><nc>cv</nc> T</c> shall yield the same result.</p>
      </section>

      <section id="to_arithmetic">
        <name>Arithmetic conversion functions</name>

          <code-item>
            <code>
template &lt;class T, class ConversionErrorHandler, class A>
  T to_arithmetic(const A&amp; a, ConversionErrorHandler&amp;&amp; handler);
            </code>
          <requires><c>T</c> shall be a default translatable arithmetic type or <c>std::optional&lt;W></c> where <c>W</c> is a default translatable arithmeric type.
                    <c>A</c> shall meet the <c>ArithmeticConvertible</c> requirements (<xref id="arithmetic_convertible.requirements"/>) for <c>char</c> or <c>wchar_t</c>.
                    <c>std::remove_reference_t&lt;ConversionErrorHandler></c> shall meet the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>)
                       for the character type of <c>V</c> with its target type being <c>T</c>
                       except that it need not meet either the <c>MoveConstructible</c> requirements or the <c>Destructible</c> requirements.</requires>
          <effects><p>Let <c>U</c> be <c>typename T::value_type</c> if <c>T</c> is an instance of <c>std::optional</c>, <c>T</c> otherwise.
                      First evaluates <c>errno = 0</c> and calls a parsing function indicated in <xref id="table.arithmetic_converter.parsing_functions"/>, optionally specifying decimal base, to get an arithmetic value <c>v</c> of the NTBS whose first element is pointed by <c>a.c_str()</c> (if it is well-formed when treated as an unevaluated operand) or <c>a->c_str()</c> (otherwise).
                      Then makes an <c>std::optional&lt;U></c> object <c>o</c> with an operation indicated in <xref id="table.arithmetic_converter.branching"/> depending on the consequence of the call of the parsing function and <c>errno</c>.
                      Finally returns <c>o</c> if <c>T</c> is an instance of <c>std::optional</c>, <c>o.value()</c> otherwise.
                        In <xref id="table.arithmetic_converter.parsing_functions"/> and <xref id="table.arithmetic_converter.branching"/>,</p>
                      <ul>
                      <li><c>Ch</c> is the character type of <c>A</c>,</li>
                      <li><c>begin</c> denotes <c>a.c_str()</c> (if it is well-formed when treated as an unevaluated operand) or <c>a->c_str()</c> (otherwise),</li>
                      <li><c>end</c> denotes <c>begin + a.size()</c> (if <c>a.size()</c> is well-formed when treated as an unevaluated operand) or <c>begin + a->size()</c> (otherwise),</li>
                      <li><c>V</c> denotes the cv-removed type of <c>v</c>,</li>
                      <li><c>SV</c> denotes <c>std::make_signed_t&lt;V></c>,</li>
                      <li><c>x</c> denotes <c>std::numeric_limits&lt;U>::max()</c>, and</li>
                      <li>the domain of <c>U</c> denotes
                          <ul>
                          <li>the range [<c>-x</c>, <c>x</c>] in <c>SV</c> mapped by a conversion to <c>V</c> if <c>V</c> is an unsigned integer type and has a greater size than <c>U</c>,</li>
                          <li>a union of the range [<c>std::numeric_limits&lt;U>::lowest()</c>, <c>x</c>] and a set of other non-finite values (for example, positive or negative infinities and &#x2018;Not-a-Number&#x2019; values) otherwise.</li>
                          </ul>
                        </li>
                      </ul>
            </effects>

            <table id="table.arithmetic_converter.parsing_functions">
              <caption>The parsing functions used by <c>to_arithmetic</c></caption>
              <col width="6"/><col width="2"/><col width="2"/>

              <tr>
              <th><c>U</c></th>
                <th><c>Ch</c> is <c>char</c></th>
                <th><c>Ch</c> is <c>wchar_t</c></th>
              </tr>

              <tr>
                <td><c>char</c> (only if signed), <c>signed char</c>, <c>short</c>, <c>int</c>, or <c>long</c></td>
                <td><c>std::strtol</c></td>
                <td><c>std::wcstol</c></td>
              </tr>

              <tr>
                <td><c>char</c> (only if unsigned), <c>unsigned char</c>, <c>unsigned short</c>, <c>unsigned</c>, or <c>unsigned long</c></td>
                <td><c>std::strtoul</c></td>
                <td><c>std::wcstoul</c></td>
              </tr>

              <tr>
                <td><c>long long</c></td>
                <td><c>std::strtoll</c></td>
                <td><c>std::wcstoll</c></td>
              </tr>

              <tr>
                <td><c>unsigned long long</c></td>
                <td><c>std::strtoull</c></td>
                <td><c>std::wcstoull</c></td>
              </tr>

              <tr>
                <td><c>float</c></td>
                <td><c>std::strtof</c></td>
                <td><c>std::wcstof</c></td>
              </tr>

              <tr>
                <td><c>double</c></td>
                <td><c>std::strtod</c></td>
                <td><c>std::wcstod</c></td>
              </tr>

              <tr>
                <td><c>long double</c></td>
                <td><c>std::strtold</c></td>
                <td><c>std::wcstold</c></td>
              </tr>
            </table>

            <table id="table.arithmetic_converter.branching">
              <caption>The operations done by <c>to_arithmetic</c> in response to the consequence of calling the parsing function</caption>
              <col width="1"/><col width="1"/><col width="1"/><col width="1"/><col width="4"/>

              <tr>
                <th>The call consumed all characters in the text value</th>
                <th>The text value contains at least one character</th>
                <th><c>errno != ERANGE</c></th>
              <th><c>v</c> is in the domain of <c>U</c></th>
                <th>Operation</th>
              </tr>

              <tr>
                <td rowspan="4">Yes</td>
                <td rowspan="3">Yes</td>
                <td rowspan="2">Yes</td>
                <td>Yes</td>
                <td><p>First lets <c>w</c> be:</p>
                    <ul>
                    <li>if <c>U</c> is an unsigned integer type, <c>V</c> has a greater size than <c>U</c>, and <c>SV(v)</c> is a negative value, <c>U(SV(v) + x + 1)</c>,</li>
                    <li>otherwise, <c>U(v)</c>.</li>
                    </ul>
                  <p>Then makes an <c>std::optional&lt;U></c> object with <c>w</c>.</p></td>
              </tr>

              <tr>
                <td>No</td>
                <td rowspan="2"><p>First lets <c>g</c> be:</p>
                    <ul>
                    <li>if <c>U</c> is an unsigned integer type or the field value should be translated into a value above any values in the domain of <c>U</c>, a positive value of <c>int</c>,</li>
                    <li>if the field value should be translated into a value below any values in the domain of <c>U</c>, a negative value of <c>int</c>,</li>
                      <li>otherwise, a zero value of <c>int</c>.</li>
                    </ul>
                  <p>Then evaluates <c>invoke_with_range_typing_as&lt;U>(std::forward&lt;ConversionErrorHandler>(handler), out_of_range_t(), begin, end, g)</c>.</p></td>
              </tr>

              <tr>
                <td>No</td>
                <td>&#8211;</td>
              </tr>

              <tr>
                <td>No</td>
                <td>&#8211;</td>
                <td>&#8211;</td>
              <td>Evaluates <c>invoke_typing_as&lt;U>(std::forward&lt;ConversionErrorHandler>(handler), empty_t())</c>.</td>
              </tr>

              <tr>
                <td>No</td>
                <td>&#8211;</td>
                <td>&#8211;</td>
                <td>&#8211;</td>
              <td>Evaluates <c>invoke_with_range_typing_as&lt;U>(std::forward&lt;ConversionErrorHandler>(handler), invalid_format_t(), begin, end)</c>.</td>
              </tr>
            </table>
        </code-item>

        <code-item>
          <code>
template &lt;class T, class A> T to_arithmetic(const A&amp; a);
          </code>
          <preface>Let <c>H</c> be <c>ignore_if_conversion_failed</c> if <c>T</c> is an instance of <c>std::optional</c>, <c>fail_if_conversion_failed</c> otherwise.</preface>
          <effects>Equivalent to: <c>return to_arithmetic&lt;T>(a, H());</c></effects>
        </code-item>
      </section>

      <section id="numpunct_replacer_to_c">
        <name>Class <c>numpunct_replacer_to_c</c></name>

        <codeblock>
namespace commata {
  class numpunct_replacer_to_c {
    <c>// <n><xref id="numpunct_replacer_to_c.cons"/>, construct/copy/destroy:</n></c>
    explicit numpunct_replacer_to_c(const std::locale&amp; loc) noexcept;
    numpunct_replacer_to_c(const numpunct_replacer_to_c&amp; other) noexcept;
    numpunct_replacer_to_c&amp; operator=(const numpunct_replacer_to_c&amp; other) noexcept;
   ~numpunct_replacer_to_c();

    <c>// <n><xref id="numpunct_replacer_to_c.inv"/>, invocation:</n></c>
    template &lt;class ForwardIterator, class ForwardIteratorEnd>
      ForwardIterator operator()(ForwardIterator first, ForwardIteratorEnd last);
    template &lt;class InputIterator, class InputIteratorEnd, class OutputIterator>
      OutputIterator operator()(InputIterator first, InputIteratorEnd last, OutputIterator result);
  };
}
        </codeblock>

        <p>The class <c>numpunct_replacer_to_c</c> describes an function object that removes or replaces the decimal radix separator character and the digit group separator character that are different those of the C library locale from NTBSes.
           <span class="note">This is designed to preprocess NTBSes before they are passed to <c>to_arithmetic</c> (<xref id="to_arithmetic"/>).</span></p>
        <p>An object of <c>numpunct_replacer_to_c</c> holds an object of <c>std::locale</c> that has information about the numeric punctuation characters to be removed or replaced.</p>
        <p>The behaviour of a program is undefined if it modifies the C library locale between the construction of an object (possibly copied-from one) of this class and the invocation of <c>operator()</c> on it.
           <span class="note">This allows and encourages the implementation to cache information about the C library locale into an object of this class.</span></p>

        <section id="numpunct_replacer_to_c.cons">
          <name><c>numpunct_replacer_to_c</c> construct/copy/destroy</name>

          <code-item>
            <code>
explicit numpunct_replacer_to_c(const std::locale&amp; loc) noexcept;
            </code>
            <effects>Copy constructs an <c>std::locale</c> object from <c>loc</c> and stores it in <c>*this</c>.</effects>
          </code-item>
        </section>

        <section id="numpunct_replacer_to_c.inv">
          <name><c>numpunct_replacer_to_c</c> invocation</name>

          <p>In this subclause, let <c>Ch</c> be the type <c>std::iterator_traits&lt;ForwardIterator>::value_type</c> or <c>std::iterator_traits&lt;InputIterator>::value_type</c>
             and <c>npf</c> be <c>std::use_facet&lt;std::numpunct&lt;Ch>>(loc)</c> where <c>loc</c> is an lvalue to the an object of <c>std::locale</c> stored in <c>*this</c>.</p>

          <code-item>
            <code>
template &lt;class ForwardIterator, class ForwardIteratorEnd>
  ForwardIterator operator()(ForwardIterator first, ForwardIteratorEnd last);
            </code>
            <requires><c>ForwardIterator</c> shall be an forward iterator type for <c>char</c> or <c>wchar_t</c>.
                      <c>ForwardIteratorEnd</c> shall meet the <c>CopyConstructible</c> requirements and <c>Destructible</c> requirements.
                      <c>std::declval&lt;const ForwardIterator&amp;>() == std::declval&lt;const ForwardIteratorEnd&amp;>()</c> shall be well-formed when treated as an unevaluated operand and shall be able to be contextually converted to <c>bool</c>.</requires>
            <effects>For each iterator <c>i</c>, whose first value is <c>first</c> and incremented until <c>i == last</c> becomes <c>true</c>,
                     eliminates <c>*i</c> in place if <c>(!npf.grouping().empty()) &amp;&amp; (*i == npf.thousands_sep())</c> is <c>true</c>,
                     and replaces <c>*i</c> in place with <c>*std::localeconv()->decimal_point</c> conditionally widen with <c>std::btowc</c> to get a value of the type <c>Ch</c> if <c>*i</c> is equal to <c>npf.decimal_point()</c>.</effects>
            <returns>The last of the resulting range.</returns>
          </code-item>

          <code-item>
            <code>
template &lt;class InputIterator, class InputIteratorEnd, class OutputIterator>
  OutputIterator operator()(InputIterator first, InputIteratorEnd last, OutputIterator result);
            </code>
            <requires><c>InputIterator</c> shall be an input iterator type for <c>char</c> or <c>wchar_t</c>.
                      <c>InputIteratorEnd</c> shall meet the <c>CopyConstructible</c> requirements and <c>Destructible</c> requirements.
                      <c>std::declval&lt;const InputIterator&amp;>() == std::declval&lt;const InputIteratorEnd&amp;>()</c> shall be well-formed when treated as an unevaluated operand and shall be able to be contextually converted to <c>bool</c>.
                      <c>OutputIterator</c> shall be an output iterator type for <c>char</c> or <c>wchar_t</c>.</requires>
            <effects>For each iterator <c>i</c>, whose first value is <c>first</c> and incremented until <c>i == last</c> becomes <c>true</c>,
                     copies <c>*i</c> if <c>npf.grouping().empty() || (*i != npf.thousands_sep())</c> is <c>true</c>,
                     replacing <c>npf.decimal_point()</c> with <c>*std::localeconv()->decimal_point</c> conditionally widen with <c>std::btowc</c> to get a value of the type <c>Ch</c>,
                     into the range that begins with <c>result</c>.</effects>
            <returns>The last of the resulting range.</returns>
            <remark><c>result</c> may be equal to <c>first</c>.</remark>
          </code-item>
        </section>
      </section>
    </section>
  </section>
</section>

<section id="parser">
  <name>Default table parsers</name>

  <section id="parser.input">
    <name>Input texts of parsing</name>

    <p>This subclause describes the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>), which is an abstraction of text inputs to be parsed, and its built-in implementations.</p>

    <section id="char_input.requirements">
      <name><c>CharInput</c> requirements</name>

      <p>A type <c>T</c> meets the <c>CharInput</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
      <ul>
        <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
        <li>the expressions shown in <xref id="table.char_input.requirements"/> are valid and have the indicated semantics.</li>
      </ul>

       <p>In <xref id="table.char_input.requirements"/>, <c>T</c> is cv-unqualified. <c>t</c> is an lvalue of <c>T</c>. <c>d</c> is an rvalue of <c>Ch*</c>. <c>n</c> is an rvalue of <c>T::size_type</c>.</p>
       <p>A requirement is optional if the last column of <xref id="table.char_input.requirements"/> is &#x2018;Yes&#x2019;.</p>

      <table id="table.char_input.requirements">
        <caption><c>CharInput</c> requirements</caption>
        <col width="3"/><col width="8"/><col width="20"/><col width="48"/><col width="6"/>

        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remarks</th>
          <th>Optional</th>
        </tr>

        <tr>
          <td>(1)</td>
          <td><c>T::char_type</c></td>
          <td/>
          <td>Shall be identical to <c>Ch</c>.</td>
          <td>No</td>
        </tr>

        <tr>
          <td>(2)</td>
          <td><c>T::traits_type</c></td>
          <td/>
          <td>Shall be a character traits type for <c>Ch</c>.</td>
          <td>No</td>
        </tr>

        <tr>
          <td>(3)</td>
          <td><c>T::size_type</c></td>
          <td/>
          <td>Shall be an unsigned integer type.</td>
          <td>No</td>
        </tr>

        <tr>
          <td>(4)</td>
          <td><c>t(d, n)</c></td>
          <td><c>T::size_type</c></td>
          <td>
            <p>Extracts characters and stores them into successive locations of an array whose first element is designated by <c>d</c>.</p>
            <p>Characters are extracted and stored until either of the following occurs:</p>
            <ul>
              <li><c>n</c> characters are stored, or</li>
              <li>end-of-file occurs on the input sequence.</li>
            </ul>
            <p>And then returns the number of characters stored.</p>
          </td>
          <td>No</td>
        </tr>

        <tr>
          <td>(5)</td>
          <td><c>t(n)</c></td>
          <td><c>std::pair&lt;const Ch*, T::size_type></c></td>
          <td><p>Let <c>rlen</c> be the smaller of <c>n</c> and the maximum number of available characters at the front of the text input represented by <c>*this</c> that are contiguously arranged.</p>
              <p>Removes the first <c>rlen</c> characters in the text input
                 and returns a pair representing the removed range whose <c>first</c> is a pointer to the first element of the range and whose <c>second</c> is the number of elements in the range.
                 The range shall not be invalidated before this ((5)) is evaluated the next time or <c>*this</c> is destroyed.</p></td>
          <td>Yes</td>
        </tr>
      </table>

      <p>(4) and (5) in <xref id="table.char_input.requirements"/> is referred as respectively an <n>indirect interface</n> and a <n>direct interface</n> of a type that meets the <c>CharInput</c> requirements.</p>
    </section>

    <section id="hpp.char_input.syn">
      <name>Header <c>"commama/char_input.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;cstddef>
#include &lt;istream>
#include &lt;streambuf>
#include &lt;string>
#include &lt;string_view>
#include &lt;type_traits>

namespace commata {
  <c>// <n><xref id="streambuf_input"/>, streambuf_input:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class streambuf_input;

  <c>// <n><xref id="owned_streambuf_input"/>, owned_streambuf_input:</n></c>
  template &lt;class Streambuf> class owned_streambuf_input;
  template &lt;class Streambuf>
    void swap(owned_streambuf_input&lt;Streambuf>&amp; left,
              owned_streambuf_input&lt;Streambuf>&amp; right) noexcept(noexcept(left.swap(right)));

  <c>// <n><xref id="istream_input"/>, istream_input:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class istream_input;

  <c>// <n><xref id="owned_istream_input"/>, owned_istream_input:</n></c>
  template &lt;class IStream> class owned_istream_input;
  template &lt;class IStream>
    void swap(owned_istream_input&lt;IStream>&amp; left,
              owned_istream_input&lt;IStream>&amp; right) noexcept(noexcept(left.swap(right)));

  <c>// <n><xref id="string_input"/>, string_input:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class string_input;

  <c>// <n><xref id="owned_string_input"/>, owned_string_input:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class owned_string_input;
  template &lt;class Ch, class Tr, class Allocator>
    void swap(owned_string_input&lt;Ch, Tr, Allocator>&amp; left,
              owned_string_input&lt;Ch, Tr, Allocator>&amp; right) noexcept(noexcept(left.swap(right)));

  <c>// <n><xref id="char_input.creation"/>, CharInput creation functions:</n></c>
  template &lt;class Ch, class Tr>
    streambuf_input&lt;Ch, Tr> make_char_input(std::basic_streambuf&lt;Ch, Tr>&amp; in) noexcept;
  template &lt;class Streambuf>
    owned_streambuf_input&lt;Streambuf> make_char_input(Streambuf&amp;&amp; in) noexcept(<nc>see below</nc>);
  template &lt;class Ch, class Tr>
    istream_input&lt;Ch, Tr> make_char_input(std::basic_istream&lt;Ch, Tr>&amp; in) noexcept;
  template &lt;class IStream>
    owned_istream_input&lt;IStream> make_char_input(IStream&amp;&amp; in) noexcept(<nc>see below</nc>);
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>>
    string_input&lt;Ch, Tr> make_char_input(const Ch* in);
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>>
    string_input&lt;Ch, Tr> make_char_input(const Ch* in, std::size_t length);
  template &lt;class Ch, class Tr, class Allocator>
    string_input&lt;Ch, Tr>
      make_char_input(const std::basic_string&lt;Ch, Tr, Allocator>&amp; in) noexcept;
  template &lt;class Ch, class Tr>
    string_input&lt;Ch, Tr> make_char_input(std::basic_string_view&lt;Ch, Tr> in) noexcept;
  template &lt;class Ch, class Tr, class Allocator>
    owned_string_input&lt;Ch, Tr, Allocator>
      make_char_input(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; in) noexcept;
}
      </codeblock>

      <p>The header <c>"commama/char_input.hpp"</c> defines some class templates whose instances meet the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>).</p>
    </section>

    <section id="streambuf_input">
      <name>Class template <c>streambuf_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class streambuf_input {
  public:
    using streambuf_type = std::basic_streambuf&lt;Ch, Tr>;
    using char_type      = Ch;
    using traits_type    = Tr;
    using size_type      = std::make_unsigned_t&lt;std::streamsize>;

    <c>// <n><xref id="streambuf_input.cons"/>, construct/copy/destroy:</n></c>
    streambuf_input() noexcept : in(nullptr) {}
    explicit streambuf_input(std::basic_streambuf&lt;Ch, Tr>&amp; sb) noexcept;
    streambuf_input(const streambuf_input&amp; other) = default;
    streambuf_input&amp; operator=(const streambuf_input&amp; other) = default;

    <c>// <n><xref id="streambuf_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);

  private:
    std::basic_streambuf&lt;Ch, Tr>* in;  <c>// <n>exposition only</n></c>
  };
}
      </codeblock>

      <p>The class template <c>streambuf_input</c> describes thin wrappers of stream buffers without any ownership of them.</p>
      <p>The template parameter <c>Ch</c> shall be a char-like type. The template parameter <c>Tr</c> shall be a character traits type for <c>Ch</c>.</p>
      <p>An instance of <c>streambuf_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Ch</c> and is a trivially copyable type.</p>

      <section id="streambuf_input.cons">
        <name><c>streambuf_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit streambuf_input(std::basic_streambuf&lt;Ch, Tr>&amp; sb) noexcept;
          </code>
          <requires><c>sb</c> shall be <c>nullptr</c> or a pointer to a valid stream buffer object.</requires>
          <effects>Initializes <c>in</c> with <c>std::addressof(sb)</c>.</effects>
        </code-item>
      </section>

      <section id="streambuf_input.inv">
        <name><c>streambuf_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <requires>[<c>out</c>, <c>out + n</c>) shall be a valid range for output.</requires>
          <effects>If <c>in</c> is not equal to <c>nullptr</c>, assigns up to <c>n</c> characters obtained from <c>*in</c> to successive elements of the array whose first element is designated by <c>out</c>.
                   Assigning stops when either <c>n</c> characters have been assigned or end-of-file would occur.</effects>
          <returns>The number of characters assigned.</returns>
        </code-item>
      </section>
    </section>

    <section id="owned_streambuf_input">
      <name>Class template <c>owned_streambuf_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class Streambuf> class owned_streambuf_input {
  public:
    using streambuf_type = Streambuf;
    using char_type      = typename Streambuf::char_type;
    using traits_type    = typename Streambuf::traits_type;
    using size_type      = std::make_unsigned_t&lt;std::streamsize>;

    <c>// <n><xref id="owned_streambuf_input.cons"/>, construct/copy/destroy:</n></c>
    owned_streambuf_input() = default;
    explicit owned_streambuf_input(Streambuf&amp;&amp; sb) noexcept(<nc>see below</nc>);
    owned_streambuf_input(owned_streambuf_input&amp;&amp; other) = default;
   ~owned_streambuf_input() = default;
    owned_streambuf_input&amp; operator=(owned_streambuf_input&amp;&amp; other) = default;

    <c>// <n><xref id="owned_streambuf_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);

    void swap(owned_streambuf_input&amp; other) noexcept(std::is_nothrow_swappable_v&lt;Streambuf>)
      { using std::swap; swap(in, other.in); }

  private:
    Streambuf in;   <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="owned_streambuf_input.special"/>, specialized algorithms:</n></c>
  template &lt;class Streambuf>
    void swap(owned_streambuf_input&lt;Streambuf>&amp; left,
              owned_streambuf_input&lt;Streambuf>&amp; right) noexcept(noexcept(left.swap(right)));
}
      </codeblock>

      <p>The class template <c>owned_streambuf_input</c> describes thin wrappers of an object of an derived type of an instance of <c>std::basic_streambuf</c> with the ownership of it.</p>
      <p>The template parameter <c>Streambuf</c> shall be the same type as, or be a derived type of, <c>std::basic_streambuf&lt;Ch, Tr></c> for a certain combination of <c>Ch</c> and <c>Tr</c>.</p>
      <p>An instance of <c>owned_streambuf_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Streambuf::char_type</c>.</p>

      <section id="owned_streambuf_input.cons">
        <name><c>owned_streambuf_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit owned_streambuf_input(Streambuf&amp;&amp; sb) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes <c>in</c> with <c>std::move(sb)</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;Streambuf></c>.</remark>
          <note>This constructor can cause a so-called slicing.</note>
        </code-item>
      </section>

      <section id="owned_streambuf_input.inv">
        <name><c>owned_streambuf_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <requires>[<c>out</c>, <c>out + n</c>) shall be a valid range for output.</requires>
          <effects>Assigns up to <c>n</c> characters obtained from <c>in</c> to successive elements of the array whose first element is designated by <c>out</c>.
                   Assigning stops when either <c>n</c> characters have been assigned or end-of-file would occur.</effects>
          <returns>The number of characters assigned.</returns>
        </code-item>
      </section>

      <section id="owned_streambuf_input.special">
        <name><c>owned_streambuf_input</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Streambuf>
  void swap(owned_streambuf_input&lt;Ch, Tr>&amp; left,
            owned_streambuf_input&lt;Ch, Tr>&amp; right) noexcept(noexcept(left.swap(right)));
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>This overload shall not participate in overload resolution unless <c>std::is_swappable_v&lt;Streambuf></c> is <c>true</c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="istream_input">
      <name>Class template <c>istream_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class istream_input {
  public:
    using istream_type = std::basic_istream&lt;Ch, Tr>;
    using char_type    = Ch;
    using traits_type  = Tr;
    using size_type    = std::make_unsigned_t&lt;std::streamsize>;

    <c>// <n><xref id="istream_input.cons"/>, construct/copy/destroy:</n></c>
    istream_input() noexcept : in(nullptr) {}
    explicit istream_input(std::basic_streambuf&lt;Ch, Tr>&amp; s) noexcept;
    istream_input(const istream_input&amp; other) = default;
    istream_input&amp; operator=(const istream_input&amp; other) = default;

    <c>// <n><xref id="istream_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);

  private:
    std::basic_istream&lt;Ch, Tr>* in;    <c>// <n>exposition only</n></c>
  };
}
      </codeblock>

      <p>The class template <c>istream_input</c> describes thin wrappers of input stream objects without any ownership of them.</p>
      <p>The template parameter <c>Ch</c> shall be a char-like type. The template parameter <c>Tr</c> shall be a character traits type for <c>Ch</c>.</p>
      <p>An instance of <c>istream_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Ch</c> and is a trivially copyable type.</p>

      <section id="istream_input.cons">
        <name><c>istream_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit istream_input(std::basic_istream&lt;Ch, Tr>&amp; s) noexcept;
          </code>
          <effects>Initializes <c>in</c> with <c>std::addressof(s)</c>.</effects>
        </code-item>
      </section>

      <section id="istream_input.inv">
        <name><c>istream_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <requires>[<c>out</c>, <c>out + n</c>) shall be a valid range for output.</requires>
          <effects>If <c>in</c> is not equal to <c>nullptr</c>, assigns up to <c>n</c> characters obtained from <c>*in</c> to successive elements of the array whose first element is designated by <c>out</c>.
                   Assigning stops when either <c>n</c> characters have been assigned or end-of-file would occur.</effects>
          <returns>The number of characters assigned.</returns>
          <remark>This member function shall obtain characters from <c>*in</c> only by means of invoking <c>std::basic_istream&lt;Ch, Tr>::read</c> on <c>*in</c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="owned_istream_input">
      <name>Class template <c>owned_istream_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class IStream> class owned_istream_input {
  public:
    using istream_type = IStream;
    using char_type    = typename IStream::char_type;
    using traits_type  = typename IStream::traits_type;
    using size_type    = std::make_unsigned_t&lt;std::streamsize>;

    <c>// <n><xref id="owned_istream_input.cons"/>, construct/copy/destroy:</n></c>
    owned_istream_input() = default;
    explicit owned_istream_input(IStream&amp;&amp; s) noexcept(<nc>see below</nc>);
    owned_istream_input(owned_istream_input&amp;&amp; other) = default;
   ~owned_istream_input() = default;
    owned_istream_input&amp; operator=(owned_istream_input&amp;&amp; other) = default;

    <c>// <n><xref id="owned_istream_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);

    void swap(owned_istream_input&amp; other) noexcept(std::is_nothrow_swappable_v&lt;IStream>)
      { using std::swap; swap(in, other.in); }

  private:
    IStream in;     <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="owned_istream_input.special"/>, specialized algorithms:</n></c>
  template &lt;class Ch, class Tr>
    void swap(owned_istream_input&lt;IStream>&amp; left,
              owned_istream_input&lt;IStream>&amp; right) noexcept(noexcept(left.swap(right)));
}
      </codeblock>

      <p>The class template <c>owned_istream_input</c> describes thin wrappers of an object of an derived type of an instance of <c>std::basic_istream</c> with the ownership of it.</p>
      <p>The template parameter <c>IStream</c> shall be the same type as, or be a derived type of, <c>std::basic_istream&lt;Ch, Tr></c> for a certain combination of <c>Ch</c> and <c>Tr</c>.</p>
      <p>An instance of <c>owned_istream_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>IStream::char_type</c>.</p>

      <section id="owned_istream_input.cons">
        <name><c>owned_istream_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit owned_istream_input(IStream&amp;&amp; s) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes <c>in</c> with <c>std::move(s)</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;IStream></c>.</remark>
          <note>This constructor can cause a so-called slicing.</note>
        </code-item>
      </section>

      <section id="owned_istream_input.inv">
        <name><c>owned_istream_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <requires>[<c>out</c>, <c>out + n</c>) shall be a valid range for output.</requires>
          <effects>Assigns up to <c>n</c> characters obtained from <c>in</c> to successive elements of the array whose first element is designated by <c>out</c>.
                   Assigning stops when either <c>n</c> characters have been assigned or end-of-file would occur.</effects>
          <returns>The number of characters assigned.</returns>
          <remark>This member function shall obtain characters from <c>*in</c> only by means of invoking <c>IStream::read</c> on <c>in</c>.</remark>
        </code-item>
      </section>

      <section id="owned_istream_input.special">
        <name><c>owned_istream_input</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Ch, class Tr>
  void swap(owned_istream_input&lt;Ch, Tr>&amp; left,
            owned_istream_input&lt;Ch, Tr>&amp; right) noexcept(noexcept(left.swap(right)));
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>This overload shall not participate in overload resolution unless <c>std::is_swappable_v&lt;IStream></c> is <c>true</c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="string_input">
      <name>Class template <c>string_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class string_input {
  public:
    using char_type   = Ch;
    using traits_type = Tr;
    using size_type   = std::size_t;

    static constexpr size_type npos = -1;

    <c>// <n><xref id="string_input.cons"/>, construct/copy/destroy:</n></c>
    string_input() noexcept {}
    explicit string_input(const Ch* str);
    template &lt;class Allocator>
      explicit string_input(const std::basic_string&lt;Ch, Tr, Allocator>&amp; str) noexcept;
    explicit string_input(std::basic_string_view&lt;Ch, Tr> str) noexcept;
    string_input(const Ch* data, std::size_t length);
    string_input(const string_input&amp; other) = default;
    string_input&amp; operator=(const string_input&amp; other) = default;

    <c>// <n><xref id="string_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);
    std::pair&lt;const Ch*, size_type> operator()(size_type n = npos) noexcept;

  private:
    std::basic_string_view&lt;Ch, Tr> v;   <c>// <n>exposition only</n></c>
  };
}
      </codeblock>

      <p>The class template <c>string_input</c> describes thin wrappers of on-memory character sequences without any ownership of them.</p>
      <p>The template parameter <c>Ch</c> shall be a char-like type. The template parameter <c>Tr</c> shall be a character traits type for <c>Ch</c>.</p>
      <p>An instance of <c>string_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Ch</c>,
         implements its optional direct interface,
         and is a trivially copyable type.</p>

      <section id="string_input.cons">
        <name><c>string_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit string_input(const Ch* str);
template &lt;class Allocator>
  explicit string_input(const std::basic_string&lt;Ch, Tr, Allocator>&amp; str) noexcept;
explicit string_input(std::basic_string_view&lt;Ch, Tr> str) noexcept;
          </code>
          <requires>In the first form, <c>str</c> shall be a valid pointer to an element in a null terminated sequence.</requires>
          <effects>Initializes <c>v</c> with <c>str</c>.</effects>
          <throws>Nothing.</throws>
        </code-item>

        <code-item>
          <code>
string_input(const Ch* data, std::size_t length);
          </code>
          <requires>[<c>data</c>, <c>data + length</c>) shall be a valid range.</requires>
          <effects>Initializes <c>v</c> with <c>data</c> and <c>length</c>.</effects>
          <throws>Nothing.</throws>
        </code-item>
      </section>

      <section id="string_input.inv">
        <name><c>string_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>size_type rlen = v.copy(out, n);
v.remove_prefix(rlen);
return rlen;</code>
          </effects>
        </code-item>

        <code-item>
          <code>
std::pair&lt;const Ch*, size_type> operator()(size_type n = npos) noexcept;
          </code>
          <effects><p>Equivalent to:</p>
                   <code>size_type rlen = std::min(n, v.size());
std::pair&lt;const Ch*, size_type> r(v.data(), rlen);
v.remove_prefix(rlen);
return r;</code>
          </effects>
        </code-item>
      </section>
    </section>

    <section id="owned_string_input">
      <name>Class template <c>owned_string_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class owned_string_input {
  public:
    using string_type = std::basic_string&lt;Ch, Tr, Allocator>;
    using char_type   = Ch;
    using traits_type = Tr;
    using size_type   = typename string_type::size_type;

    static constexpr size_type npos = -1;

    <c>// <n><xref id="owned_string_input.cons"/>, construct/copy/destroy:</n></c>
    owned_string_input() noexcept(<nc>see below</nc>);
    explicit owned_string_input(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; str) noexcept;
    owned_string_input(owned_string_input&amp;&amp; other) noexcept;
   ~owned_string_input() = default;
    owned_string_input&amp; operator=(owned_string_input&amp;&amp; other) noexcept(<nc>see below</nc>);

    <c>// <n><xref id="owned_string_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);
    std::pair&lt;const Ch*, size_type> operator()(size_type n = npos) noexcept;

    <c>// <n><xref id="owned_string_input.modifiers"/>, modifiers:</n></c>
    void swap(owned_string_input&amp; other) noexcept(<nc>see below</nc>);

  private:
    std::basic_string&lt;Ch, Tr, Allocator> s;     <c>// <n>exposition only</n></c>
    size_type head;                             <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="owned_string_input.special"/>, specialized algorithms:</n></c>
  template &lt;class Ch, class Tr, class Allocator>
    void swap(owned_string_input&lt;Ch, Tr, Allocator>&amp; left,
              owned_string_input&lt;Ch, Tr, Allocator>&amp; right) noexcept(noexcept(left.swap(right)));
}
      </codeblock>

      <p>The class template <c>owned_string_input</c> describes thin wrappers of an object of an instance of <c>std::basic_string</c> with the ownership of it.</p>
      <p>The template parameter <c>Ch</c> shall be a char-like type. The template parameter <c>Tr</c> shall be a character traits type for <c>Ch</c>.</p>
      <p>An instance of <c>owned_string_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Ch</c>
         and implements its optional direct interface.</p>

      <section id="owned_string_input.cons">
        <name><c>owned_string_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
owned_string_input() noexcept(<nc>see below</nc>);
          </code>
          <effects>Value-initializes <c>s</c> and initializes <c>head</c> with <c>0</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_default_constructible_v&lt;std::basic_string&lt;Ch, Tr, Allocator>></c>.</remark>
        </code-item>

        <code-item>
          <code>
explicit owned_string_input(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; str) noexcept;
          </code>
          <effects>Initializes <c>s</c> with <c>std::move(str)</c> and <c>head</c> with <c>0</c>.</effects>
        </code-item>

        <code-item>
          <code>
owned_string_input(owned_string_input&amp;&amp; other) noexcept;
          </code>
          <effects>Initializes <c>s</c> with <c>std::move(other.s)</c> and <c>head</c> with <c>other.head</c>, and then assigns <c>other.size()</c> to <c>other.head</c>.</effects>
        </code-item>

        <code-item>
          <code>
owned_string_input&amp; operator=(owned_string_input&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Assigns <c>std::move(other.s)</c> to <c>s</c> and <c>other.head</c> to <c>head</c>, and then assigns <c>other.size()</c> to <c>other.head</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_assignable_v&lt;std::basic_string&lt;Ch, Tr, Allocator>></c>.</remark>
        </code-item>
      </section>

      <section id="owned_string_input.inv">
        <name><c>owned_string_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>size_type rlen = s.copy(out, n, head);
head += rlen;
return rlen;</code>
          </effects>
        </code-item>

        <code-item>
          <code>
std::pair&lt;const Ch*, size_type> operator()(size_type n = npos) noexcept;
          </code>
          <effects><p>Equivalent to:</p>
                   <code>size_type rlen = std::min(n, s.size() - head);
std::pair&lt;const Ch*, size_type> r(s.data() + head, rlen);
head += rlen;
return r;</code>
          </effects>
        </code-item>
      </section>

      <section id="owned_string_input.modifiers">
        <name><c>owned_string_input</c> modifiers</name>

        <code-item>
          <code>
void swap(owned_string_input&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Exchanges <c>s</c> and <c>other.s</c>, and, <c>head</c> and <c>other.head</c>, respectively.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_swappable_v&lt;std::basic_string&lt;Ch, Tr, Allocator>></c>.</remark>
        </code-item>
      </section>

      <section id="owned_string_input.special">
        <name><c>owned_string_input</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Ch, class Tr, class Allocator>
  void swap(owned_string_input&lt;Ch, Tr, Allocator>&amp; left,
            owned_string_input&lt;Ch, Tr, Allocator>&amp; right) noexcept(noexcept(left.swap(right)));
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
        </code-item>
      </section>
    </section>

    <section id="char_input.creation">
      <name><c>CharInput</c> creation functions</name>

      <code-item>
        <code>
template &lt;class Ch, class Tr>
  streambuf_input&lt;Ch, Tr> make_char_input(std::basic_streambuf&lt;Ch, Tr>&amp; in) noexcept;
        </code>
        <returns><c>streambuf_input&lt;Ch, Tr>(in)</c>.</returns>
      </code-item>

      <code-item>
        <code>
template &lt;class Streambuf>
  owned_streambuf_input&lt;Streambuf> make_char_input(Streambuf&amp;&amp; in) noexcept(<nc>see below</nc>);
        </code>
        <returns><c>owned_streambuf_input&lt;Streambuf>(std::move(in))</c>.</returns>
        <remark>This overload shall not participate in overload resolution unless the template parameter <c>Streambuf</c> is not an lvalue reference and is the same type as, or is a derived type of, <c>std::basic_streambuf&lt;Ch, Tr></c> for a certain combination of <c>Ch</c> and <c>Tr</c>.
                The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;Streambuf></c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr>
  istream_input&lt;Ch, Tr> make_char_input(std::basic_istream&lt;Ch, Tr>&amp; in) noexcept;
        </code>
        <returns><c>istream_input&lt;Ch, Tr>(in)</c>.</returns>
      </code-item>

      <code-item>
        <code>
template &lt;class IStream>
  owned_istream_input&lt;IStream> make_char_input(IStream&amp;&amp; in) noexcept(<nc>see below</nc>);
        </code>
        <returns><c>owned_istream_input&lt;IStream>(std::move(in))</c>.</returns>
        <remark>This overload shall not participate in overload resolution unless the template parameter <c>IStream</c> is not an lvalue reference and is the same type as, or is a derived type of, <c>std::basic_istream&lt;Ch, Tr></c> for a certain combination of <c>Ch</c> and <c>Tr</c>.
                The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;IStream></c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr = std::char_traits&lt;Ch>>
  string_input&lt;Ch, Tr> make_char_input(const Ch* in);
template &lt;class Ch, class Tr = std::char_traits&lt;Ch>>
  string_input&lt;Ch, Tr> make_char_input(const Ch* in, std::size_t length);
template &lt;class Ch, class Tr, class Allocator>
  string_input&lt;Ch, Tr>
    make_char_input(const std::basic_string&lt;Ch, Tr, Allocator>&amp; in) noexcept;
template &lt;class Ch, class Tr>
  string_input&lt;Ch, Tr> make_char_input(std::basic_string_view&lt;Ch, Tr> in) noexcept;
        </code>
        <requires>In the first form, <c>in</c> shall be a valid pointer to an element in a null terminated sequence.
                  In the second form, [<c>in</c>, <c>in + length</c>) shall be a valid range.</requires>
        <returns><c>string_input&lt;Ch, Tr>(in)</c> or <c>string_input&lt;Ch, Tr>(in, length)</c>.</returns>
        <throws>Nothing.</throws>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr, class Allocator>
  owned_string_input&lt;Ch, Tr, Allocator>
    make_char_input(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; in) noexcept;
        </code>
        <returns><c>owned_string_input&lt;Ch, Tr, Allocator>(std::move(in))</c>.</returns>
      </code-item>
    </section>
  </section>

  <section id="parser.csv">
    <name>Parsing CSV format texts</name>

    <p>This subclause describes facilities to create or utilize the table parser (<xref id="concepts"/>) of the CSV text format (<xref id="definitions.csv_text"/>).</p>

    <section id="definitions.csv_text">
      <name>CSV texts</name>

      <p>The CSV parser of Commata conforms the <n>CSV text</n> model following:</p>
      <ul>
        <li>A CSV text is a representation of a text table (<xref id="definitions.text_table"/>) as a sequence of objects whose type is the char type of the text table.</li>
        <li>Each CSV text has its <n>char type</n> that is equal to the char type of the text table.</li>
        <li>Each text field of a text table represented as a CSV text is either of a <n>quoted field</n> or a <n>unquoted field</n>.</li>
        <li>A quoted field is represented as a sequence of the char type objects that starts with a double quote and ends with a double quote.
            Its representation cannot contain odd number of contiguous double quotes after the the starting double quote and before the ending double quote.</li>
        <li>An unquoted field is represented as a sequence of the char type objects that does not contain any double quotes, commas and <n>line breaks</n>.</li>
        <li>The text value of a quoted field is defined as follows:
            <ul>
              <li>first make a copy of the sequence of characters of the range [the next character of the starting double quote, the previous character of the ending double quote],</li>
              <li>then replace every occurrence of two contiguous double quotes in it into one double quote.</li>
            </ul>
        </li>
        <li>The text value of an unquoted field is the representation as a sequence of the char type objects itself.</li>
        <li>In a CSV text, each text record is represented as a comma-delimited sequence of representations of its text fields.
            The representation of the final text field in a text record is not followed by a comma.</li>
        <li>In a CSV text, the representations of its text records are delimited by a line break.
            The representation of the final record is or is not followed by a line break.</li>
        <li>Each line break is either of CR, LF, or CRsLF where CR is a carrage return character, LF is a line feed (or new-line) character, and CRsLF is a character sequence of one or more CR(s) and an LF in order.</li>
      </ul>
    </section>

    <section id="hpp.parse_csv.syn">
      <name>Header <c>"commama/parse_csv.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;cstddef>
#include &lt;functional>
#include &lt;memory>

#include "parse_error.hpp"
#include "char_input.hpp"
#include "wrapper_handler.hpp"

namespace commata {
  <c>// <n><xref id="csv_source"/>, csv_source:</n></c>
  template &lt;class CharInput> class csv_source;
  template &lt;class CharInput>
    void swap(csv_source&lt;CharInput>&amp; left,
              csv_source&lt;CharInput>&amp; right) noexcept(noexcept(left.swap(right)));
  template &lt;class... Args>   auto make_csv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>)
    -> csv_source&lt;decltype(make_char_input(std::forward&lt;Args>(args)...))>;
  template &lt;class CharInputR> auto make_csv_source(CharInputR&amp;&amp; in) noexcept(<nc>see below</nc>)
    -> csv_source&lt;std::decay_t&lt;CharInputR>>;

  <c>// <n><xref id="parse_csv"/>, functions that utilize the CSV parser:</n></c>
  template &lt;class CharInput, class... OtherArgs>
    bool parse_csv(const csv_source&lt;CharInput>&amp;  src, OtherArgs&amp;&amp;... other_args);
  template &lt;class CharInput, class... OtherArgs>
    bool parse_csv(      csv_source&lt;CharInput>&amp;&amp; src, OtherArgs&amp;&amp;... other_args);
  template &lt;class Arg1, class Arg2, class... OtherArgs>
    bool parse_csv(Arg1&amp;&amp; arg1, Arg2&amp;&amp; arg2, OtherArgs&amp;&amp;... other_args);
}
      </codeblock>
    </section>

    <section id="csv_source">
      <name>Class template <c>csv_source</c></name>

      <codeblock>
namespace commata {
  template &lt;class CharInput> class csv_source {
  public:
    <c>// <n><xref id="csv_source.types"/>, member types:</n></c>
    using input_type = CharInput;
    using char_type = typename CharInput::char_type;
    using traits_type = typename CharInput::traits_type;
    template &lt;class Handler, class Allocator = void> using parser_type = <nc>see below</nc>;
  
    <c>// <n><xref id="csv_source.cons"/>, construct/copy/destroy:</n></c>
    explicit csv_source(const CharInput&amp;&amp; input) noexcept(<nc>see below</nc>);
    explicit csv_source(CharInput&amp;&amp; input) noexcept(<nc>see below</nc>);
    csv_source(const csv_source&amp; other) = default;
    csv_source(csv_source&amp;&amp; other) = default;
   ~csv_source() = default;
    csv_source&amp; operator=(const csv_source&amp; other) = default;
    csv_source&amp; operator=(csv_source&amp;&amp; other) = default;

    <c>// <n><xref id="csv_source.inv"/>, invocation:</n></c>
    template &lt;class HandlerR>
      parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler) const&amp; noexcept(<nc>see below</nc>);
    template &lt;class HandlerR>
      parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler)     &amp;&amp; noexcept(<nc>see below</nc>);
    template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
      parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
        operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
                   const Allocator&amp; alloc = Allocator()) const&amp; noexcept(<nc>see below</nc>);
    template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
      parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
        operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
                   const Allocator&amp; alloc = Allocator())     &amp;&amp; noexcept(<nc>see below</nc>);
    template &lt;class Handler, class... Args>
      <nc>see below</nc> operator()(std::reference_wrapper&lt;Handler> handler,
                           Args&amp;&amp;... args) const&amp; noexcept(<nc>see below</nc>);
    template &lt;class Handler, class... Args>
      <nc>see below</nc> operator()(std::reference_wrapper&lt;Handler> handler,
                           Args&amp;&amp;... args)     &amp;&amp; noexcept(<nc>see below</nc>);

    void swap(csv_source&amp; other) noexcept(std::is_nothrow_swappable_v&lt;CharInput>)
      { using std::swap; swap(in, other.in); }

  private:
    CharInput in;   <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="csv_source.special"/>, specialized algorithms:</n></c>
  template &lt;class CharInput>
    void swap(csv_source&lt;CharInput>&amp; left,
              csv_source&lt;CharInput>&amp; right) noexcept(noexcept(left.swap(right)));

  <c>// <n><xref id="csv_source.creation"/>, creation functions:</n></c>
  template &lt;class... Args> auto make_csv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>)
    -> csv_source&lt;decltype(make_char_input(std::forward&lt;Args>(args)...))>;
  template &lt;class CharInputR> auto make_csv_source(CharInputR&amp;&amp; in) noexcept(<nc>see below</nc>)
    -> csv_source&lt;std::decay_t&lt;CharInputR>>;
}
      </codeblock>

      <p>The class template <c>csv_source</c> describes thin wrappers of sequences of characters that work as factories of <c>TableParser</c> objects (<xref id="table_parser.requirements"/>) of the CSV text format (<xref id="definitions.csv_text"/>).</p>
      <p>The template parameter <c>CharInput</c> shall meet the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for a certain char-like type.</p>
      <p><c>csv_source&lt;CharInput></c> shall meet the <c>TableSource</c> requirements (<xref id="table_source.requirements"/>) for the type <c>CharInput::char_type</c> with their optional operations for <c>TableHandler</c> types that are deemed to have no buffer control.
         It shall be direct if and only if <c>CharInput</c> has the direct interface.</p>
      <p><c>csv_source&lt;CharInput></c> shall be a trivially copyable type if <c>std::is_trivially_copyable_v&lt;CharInput></c> is <c>true</c>.</p>

      <section id="csv_source.types">
        <name><c>csv_source</c> member types</name>

        <code-item>
          <code>
template &lt;class Handler, class Allocator = void> using parser_type = <nc>see below</nc>;
          </code>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>char_type</c>.
                    If <c>Handler</c> is deemed to have buffer control, <c>Allocator</c> shall be <c>void</c>.
                    Otherwise, <c>Allocator</c> shall be <c>void</c> or meet the <c>Allocator</c> requirements for <c>char_type</c>.</requires>
          <alias-template>An unspecified type (hereinafter called <c>P</c>) which meets the <c>TableParser</c> requirements (<xref id="table_parser.requirements"/>) for <c>char_type</c>.
                          <c>P</c> implements the optional <c>TableParser</c> operation <c>get_physical_position</c> (<xref id="table_parser.requirements"/>) with <c>noexcept(true)</c> exception specification.
                          <c>std::nothrow_move_constructible_v&lt;P></c> shall be <c>true</c> if <c>std::nothrow_move_constructible_v&lt;CharInput> &amp;&amp; std::nothrow_move_constructible_v&lt;Handler> &amp;&amp; (std::is_void_v&lt;Allocator> || std::nothrow_move_constructible_v&lt;Allocator>)</c> is <c>true</c>.
                          An object of <c>P</c> holds an object of <c>CharInput</c> as its tied character input and an object of <c>Handler</c> as its tied table handler.
                          If <c>Handler</c> is deemed to have no buffer control, an object of <c>P</c> also holds an allocator object of <c>Allocator</c> (if not <c>void</c>) or <c>std::allocator&lt;char_type></c> (otherwise), and allocates and deallocates character buffers with it when it requires them.
                          Invocation of <c>operator()</c> on an object of <c>P</c> might throw <c>parse_error</c> (<xref id="parse_error"/>), <c>std::bad_alloc</c> or any exception thrown by its tied character input object, its tied table handler object, and the allocator object held by it if any.</alias-template>
          <remark>If <c>Handler</c> is deemed to have no buffer control, <c>std::is_same_v&lt;parser_type&lt;Handler>, parser_type&lt;Handler, std::allocator&lt;char_type>>></c> shall be <c>true</c>.</remark>
        </code-item>
      </section>

      <section id="csv_source.cons">
        <name><c>csv_source</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit csv_source(const CharInput&amp; input) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_copy_constructible_v&lt;CharInput></c> shall be <c>true</c>.</requires>
          <effects>Initializes <c>in</c> with <c>input</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;CharInput></c>.</remark>
        </code-item>

        <code-item>
          <code>
explicit csv_source(CharInput&amp;&amp; input) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes <c>in</c> with <c>std::move(input)</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;CharInput></c>.</remark>
        </code-item>
      </section>

      <section id="csv_source.inv">
        <name><c>csv_source</c> invocation</name>

        <code-item>
          <code>
template &lt;class HandlerR>
  parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler) const&amp; noexcept(<nc>see below</nc>);
template &lt;class HandlerR>
  parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler)     &amp;&amp; noexcept(<nc>see below</nc>);
          </code>
          <preface>Let <c>Handler</c> be <c>std::decay_t&lt;HandlerR></c>.</preface>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>char_type</c>.</requires>
          <returns>A table parser object <c>p</c> for the CSV text format (<xref id="definitions.csv_text"/>).
                   <c>p</c> holds an object of <c>CharInput</c> constructed with <c>in</c> (first form) or <c>std::move(in)</c> (second form) as its tied character input
                   and an object of <c>Handler</c> constructed with <c>std::forward&lt;HandlerR>(handler)</c> as its tied table handler.</returns>
          <remark>These operators shall not participate in overload resolution unless <c>Handler</c> is deemed to have buffer control.
                  The expression inside <c>noexcept</c> is equivalent to
                  <c>std::is_nothrow_constructible_v&lt;Handler, HandlerR&amp;&amp;> &amp;&amp; std::is_nothrow_copy_constructible&lt;CharInput></c> (first form) or
                  <c>std::is_nothrow_constructible_v&lt;Handler, HandlerR&amp;&amp;> &amp;&amp; std::is_nothrow_move_constructible&lt;CharInput></c> (second form).</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
  parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
    operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
               const Allocator&amp; alloc = Allocator()) const&amp; noexcept(<nc>see below</nc>);
template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
  parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
    operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
               const Allocator&amp; alloc = Allocator())     &amp;&amp; noexcept(<nc>see below</nc>);
          </code>
          <preface>Let <c>Handler</c> be <c>std::decay_t&lt;HandlerR></c>.</preface>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>char_type</c>.
                    <c>Allocator</c> shall meet the <c>Allocator</c> requirements for <c>char_type</c>.</requires>
          <returns>A table parser object <c>p</c> for the CSV text format (<xref id="definitions.csv_text"/>).
                   <c>p</c> holds an object of <c>CharInput</c> constructed with <c>in</c> (first form) or <c>std::move(in)</c> (second form) as its tied character input,
                   an object of <c>Handler</c> constructed with <c>std::forward&lt;HandlerR>(handler)</c> as its tied table handler, and a copy of <c>alloc</c> to allocate and deallocate the character buffer.
                   The length of the buffer allocated by <c>p</c> is unspecified, but <c>buffer_size</c> serves as a hint. <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.</returns>
          <remark>These operators shall not participate in overload resolution unless <c>Handler</c> is not an instance of <c>std::reference_wrapper</c> and is deemed to have no buffer control.
                  The expression inside <c>noexcept</c> is equivalent to
                  <c>std::is_nothrow_constructible_v&lt;Handler, HandlerR&amp;&amp;> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;CharInput> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;Allocator></c> (first form) or
                  <c>std::is_nothrow_constructible_v&lt;Handler, HandlerR&amp;&amp;> &amp;&amp; std::is_nothrow_move_constructible_v&lt;CharInput> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;Allocator></c> (second form).</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Handler, class... Args>
  <nc>see below</nc> operator()(std::reference_wrapper&lt;Handler> handler,
                       Args&amp;&amp;... args) const&amp; noexcept(<nc>see below</nc>);
          </code>
          <effects>Equivalent to: <c>return (*this)(wrap_ref(handler), std::forward&lt;Args>(args)...);</c></effects>
          <remark>This operator shall not participate in overload resolution unless <c>std::is_invocable_v&lt;const csv_source&amp;, reference_handler&lt;Handler>&amp;&amp;, Args&amp;&amp;...></c> is <c>true</c>.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_invocable_v&lt;const csv_source&amp;, reference_handler&lt;Handler>, Args...></c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Handler, class... Args>
  <nc>see below</nc> operator()(std::reference_wrapper&lt;Handler> handler,
                       Args&amp;&amp;... args)     &amp;&amp; noexcept(<nc>see below</nc>);
          </code>
          <effects>Equivalent to: <c>return std::move(*this)(wrap_ref(handler), std::forward&lt;Args>(args)...);</c></effects>
          <remark>This operator shall not participate in overload resolution unless <c>std::is_invocable_v&lt;csv_source&amp;&amp;, reference_handler&lt;Handler>&amp;&amp;, Args&amp;&amp;...></c> is <c>true</c>.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_invocable_v&lt;csv_source, reference_handler&lt;Handler>, Args...></c>.</remark>
        </code-item>
      </section>

      <section id="csv_source.special">
        <name><c>csv_source</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class CharInput>
  void swap(csv_source&lt;CharInput>&amp; left,
            csv_source&lt;CharInput>&amp; right) noexcept(noexcept(left.swap(right)));
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>This overload shall not participate in overload resolution unless <c>std::is_swappable_v&lt;CharInput></c> is <c>true</c>.</remark>
        </code-item>
      </section>

      <section id="csv_source.creation">
        <name><c>csv_source</c> creation functions</name>

        <code-item>
          <code>
template &lt;class... Args> auto make_csv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>)
  -> csv_source&lt;decltype(make_char_input(std::forward&lt;Args>(args)...))>;
          </code>
          <preface>Let <c>CharInput</c> be <c>decltype(make_char_input(std::forward&lt;Args>(args)...))</c>.</preface>
          <effects>Equivalent to: <c>return csv_source&lt;CharInput>(make_char_input(std::forward&lt;Args>(args)...));</c></effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible_v&lt;CharInput, Args&amp;&amp;...></c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class CharInputR> auto make_csv_source(CharInputR&amp;&amp; in) noexcept(<nc>see below</nc>)
  -> csv_source&lt;std::decay_t&lt;CharInputR>>;
          </code>
          <preface>Let <c>CharInput</c> be <c>std::decay_t&lt;CharInputR></c>.</preface>
          <effects>Equivalent to: <c>return csv_source&lt;CharInput>(std::forward&lt;CharInputR>(in));</c></effects>
          <remark>This overload shall participate in overload resolution if and only if <c>make_char_input(std::declval&lt;CharInputR&amp;&amp;>())</c> is not well-formed when treated as an unevaluated operand
                  and <c>std::is_invocable_r_v&lt;typename CharInput::size_type, CharInput&amp;, typename CharInput::char_type*, typename CharInput::size_type></c> is <c>true</c>.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible_v&lt;CharInput, CharInputR&amp;&amp;></c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="parse_csv">
      <name>Utilizing the CSV parser</name>

      <code-item>
        <code>
template &lt;class CharInput, class... OtherArgs>
  bool parse_csv(const csv_source&lt;CharInput>&amp;  src, OtherArgs&amp;&amp;... other_args);
        </code>
        <effects>Equivalent to: <c>return src(std::forward&lt;OtherArgs>(other_args)...)();</c>.</effects>
      </code-item>

      <code-item>
        <code>
template &lt;class CharInput, class... OtherArgs>
  bool parse_csv(      csv_source&lt;CharInput>&amp;&amp; src, OtherArgs&amp;&amp;... other_args);
        </code>
        <effects>Equivalent to: <c>return std::move(src)(std::forward&lt;OtherArgs>(other_args)...)();</c>.</effects>
      </code-item>

      <code-item>
        <code>
template &lt;class Arg1, class Arg2, class... OtherArgs>
  bool parse_csv(Arg1&amp;&amp; arg1, Arg2&amp;&amp; arg2, OtherArgs&amp;&amp;... other_args);
        </code>
        <effects><p>If <c>make_csv_source(std::declval&lt;Arg1&amp;&amp;>(), std::declval&lt;Arg2&amp;&amp;>())</c> is well-formed when treated as an unevaluated operand, equivalent to:</p>
                 <code>return parse_csv(make_csv_source(std::forward&lt;Arg1>(arg1), std::forward&lt;Arg2>(arg2)),
                 std::forward&lt;OtherArgs>(other_args)...);</code>
                 <p>Otherwise, equivalent to:</p>
                 <code>return parse_csv(make_csv_source(std::forward&lt;Arg1>(arg1)),
                 std::forward&lt;Arg2>(arg2), std::forward&lt;OtherArgs>(other_args)...);</code></effects>
        <remark>This function template shall not participate in overload resolution unless <c>std::decay_t&lt;Arg1></c> is not an instance of <c>csv_source</c> and either of <c>make_csv_source(std::declval&lt;Arg1&amp;&amp;>())</c> or <c>make_csv_source(std::declval&lt;Arg1&amp;&amp;>(), std::declval&lt;Arg2&amp;&amp;>())</c> is well-formed when treated as an unevaluated operand.</remark>
      </code-item>
    </section>
  </section>

  <section id="parser.tsv">
    <name>Parsing TSV format texts</name>

    <p>This subclause describes facilities to create or utilize the table parser (<xref id="concepts"/>) of the TSV text format (<xref id="definitions.tsv_text"/>).</p>

    <section id="definitions.tsv_text">
      <name>TSV texts</name>

      <p>The TSV parser of Commata conforms the <n>TSV text</n> model following:</p>
      <ul>
        <li>A TSV text is a representation of a text table (<xref id="definitions.text_table"/>) as a sequence of objects whose type is the char type of the text table.</li>
        <li>Each TSV text has its <n>char type</n> that is equal to the char type of the text table.</li>
        <li>The text value of a field is the representation as a sequence of the char type objects itself.</li>
        <li>In a TSV text, each text record is represented as a tab-delimited sequence of representations of its text fields.
            The representation of the final text field in a text record is not followed by a tab.</li>
        <li>In a TSV text, the representations of its text records are delimited by a line break.
            The representation of the final record is or is not followed by a line break.</li>
        <li>Each line break is either of CR, LF, or CRsLF where CR is a carrage return character, LF is a line feed (or new-line) character, and CRsLF is a character sequence of one or more CR(s) and an LF in order.</li>
      </ul>
      <p><span class="note">This TSV text model forbids each text field to have tabs in its text value and does not do any special treatment to double quotes, as IANA&#x2019;s "Definition of tab-separated-values (tsv)".</span></p>
    </section>

    <section id="hpp.parse_tsv.syn">
      <name>Header <c>"commama/parse_tsv.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;cstddef>
#include &lt;functional>
#include &lt;memory>

#include "parse_error.hpp"
#include "char_input.hpp"
#include "wrapper_handler.hpp"

namespace commata {
  <c>// <n><xref id="tsv_source"/>, tsv_source:</n></c>
  template &lt;class CharInput> class tsv_source;
  template &lt;class CharInput>
    void swap(tsv_source&lt;CharInput>&amp; left,
              tsv_source&lt;CharInput>&amp; right) noexcept(noexcept(left.swap(right)));
  template &lt;class... Args>   auto make_tsv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>)
    -> tsv_source&lt;decltype(make_char_input(std::forward&lt;Args>(args)...))>;
  template &lt;class CharInputR> auto make_tsv_source(CharInputR&amp;&amp; in) noexcept(<nc>see below</nc>)
    -> tsv_source&lt;std::decay_t&lt;CharInputR>>;

  <c>// <n><xref id="parse_tsv"/>, functions that utilize the TSV parser:</n></c>
  template &lt;class CharInput, class... OtherArgs>
    bool parse_tsv(const tsv_source&lt;CharInput>&amp;  src, OtherArgs&amp;&amp;... other_args);
  template &lt;class CharInput, class... OtherArgs>
    bool parse_tsv(      tsv_source&lt;CharInput>&amp;&amp; src, OtherArgs&amp;&amp;... other_args);
  template &lt;class Arg1, class Arg2, class... OtherArgs>
    bool parse_tsv(Arg1&amp;&amp; arg1, Arg2&amp;&amp; arg2, OtherArgs&amp;&amp;... other_args);
}
      </codeblock>
    </section>

    <section id="tsv_source">
      <name>Class template <c>tsv_source</c></name>

      <codeblock>
namespace commata {
  template &lt;class CharInput> class tsv_source {
  public:
    <c>// <n><xref id="tsv_source.types"/>, member types:</n></c>
    using input_type = CharInput;
    using char_type = typename CharInput::char_type;
    using traits_type = typename CharInput::traits_type;
    template &lt;class Handler, class Allocator = void> using parser_type = <nc>see below</nc>;
  
    <c>// <n><xref id="tsv_source.cons"/>, construct/copy/destroy:</n></c>
    explicit tsv_source(const CharInput&amp;&amp; input) noexcept(<nc>see below</nc>);
    explicit tsv_source(CharInput&amp;&amp; input) noexcept(<nc>see below</nc>);
    tsv_source(const tsv_source&amp; other) = default;
    tsv_source(tsv_source&amp;&amp; other) = default;
   ~tsv_source() = default;
    tsv_source&amp; operator=(const tsv_source&amp; other) = default;
    tsv_source&amp; operator=(tsv_source&amp;&amp; other) = default;

    <c>// <n><xref id="tsv_source.inv"/>, invocation:</n></c>
    template &lt;class HandlerR>
      parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler) const&amp; noexcept(<nc>see below</nc>);
    template &lt;class HandlerR>
      parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler)     &amp;&amp; noexcept(<nc>see below</nc>);
    template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
      parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
        operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
                   const Allocator&amp; alloc = Allocator()) const&amp; noexcept(<nc>see below</nc>);
    template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
      parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
        operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
                   const Allocator&amp; alloc = Allocator())     &amp;&amp; noexcept(<nc>see below</nc>);
    template &lt;class Handler, class... Args>
      <nc>see below</nc> operator()(std::reference_wrapper&lt;Handler> handler,
                           Args&amp;&amp;... args) const&amp; noexcept(<nc>see below</nc>);
    template &lt;class Handler, class... Args>
      <nc>see below</nc> operator()(std::reference_wrapper&lt;Handler> handler,
                           Args&amp;&amp;... args)     &amp;&amp; noexcept(<nc>see below</nc>);

    void swap(tsv_source&amp; other) noexcept(std::is_nothrow_swappable_v&lt;CharInput>)
      { using std::swap; swap(in, other.in); }

  private:
    CharInput in;   <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="tsv_source.special"/>, specialized algorithms:</n></c>
  template &lt;class CharInput>
    void swap(tsv_source&lt;CharInput>&amp; left,
              tsv_source&lt;CharInput>&amp; right) noexcept(noexcept(left.swap(right)));

  <c>// <n><xref id="tsv_source.creation"/>, creation functions:</n></c>
  template &lt;class... Args> auto make_tsv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>)
    -> tsv_source&lt;decltype(make_char_input(std::forward&lt;Args>(args)...))>;
  template &lt;class CharInputR> auto make_tsv_source(CharInputR&amp;&amp; in) noexcept(<nc>see below</nc>)
    -> tsv_source&lt;std::decay_t&lt;CharInputR>>;
}
      </codeblock>

      <p>The class template <c>tsv_source</c> describes thin wrappers of sequences of characters that work as factories of <c>TableParser</c> objects (<xref id="table_parser.requirements"/>) of the TSV text format (<xref id="definitions.tsv_text"/>).</p>
      <p>The template parameter <c>CharInput</c> shall meet the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for a certain char-like type.</p>
      <p><c>tsv_source&lt;CharInput></c> shall meet the <c>TableSource</c> requirements (<xref id="table_source.requirements"/>) for the type <c>CharInput::char_type</c> with their optional operations for <c>TableHandler</c> types that are deemed to have no buffer control.
         It shall be direct if and only if <c>CharInput</c> has the direct interface.</p>
      <p><c>tsv_source&lt;CharInput></c> shall be a trivially copyable type if <c>std::is_trivially_copyable_v&lt;CharInput></c> is <c>true</c>.</p>

      <section id="tsv_source.types">
        <name><c>tsv_source</c> member types</name>

        <code-item>
          <code>
template &lt;class Handler, class Allocator = void> using parser_type = <nc>see below</nc>;
          </code>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>char_type</c>.
                    If <c>Handler</c> is deemed to have buffer control, <c>Allocator</c> shall be <c>void</c>.
                    Otherwise, <c>Allocator</c> shall be <c>void</c> or meet the <c>Allocator</c> requirements for <c>char_type</c>.</requires>
          <alias-template>An unspecified type (hereinafter called <c>P</c>) which meets the <c>TableParser</c> requirements (<xref id="table_parser.requirements"/>) for <c>char_type</c>.
                          <c>P</c> implements the optional <c>TableParser</c> operation <c>get_physical_position</c> (<xref id="table_parser.requirements"/>) with <c>noexcept(true)</c> exception specification.
                          <c>std::nothrow_move_constructible_v&lt;P></c> shall be <c>true</c> if <c>std::nothrow_move_constructible_v&lt;CharInput> &amp;&amp; std::nothrow_move_constructible_v&lt;Handler> &amp;&amp; (std::is_void_v&lt;Allocator> || std::nothrow_move_constructible_v&lt;Allocator>)</c> is <c>true</c>.
                          An object of <c>P</c> holds an object of <c>CharInput</c> as its tied character input and an object of <c>Handler</c> as its tied table handler.
                          If <c>Handler</c> is deemed to have no buffer control, an object of <c>P</c> also holds an allocator object of <c>Allocator</c> (if not <c>void</c>) or <c>std::allocator&lt;char_type></c> (otherwise), and allocates and deallocates character buffers with it when it requires them.
                          Invocation of <c>operator()</c> on an object of <c>P</c> might throw <c>parse_error</c> (<xref id="parse_error"/>), <c>std::bad_alloc</c> or any exception thrown by its tied character input object, its tied table handler object, and the allocator object held by it if any.</alias-template>
          <remark>If <c>Handler</c> is deemed to have no buffer control, <c>std::is_same_v&lt;parser_type&lt;Handler>, parser_type&lt;Handler, std::allocator&lt;char_type>>></c> shall be <c>true</c>.</remark>
        </code-item>
      </section>

      <section id="tsv_source.cons">
        <name><c>tsv_source</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit tsv_source(const CharInput&amp; input) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_copy_constructible_v&lt;CharInput></c> shall be <c>true</c>.</requires>
          <effects>Initializes <c>in</c> with <c>input</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;CharInput></c>.</remark>
        </code-item>

        <code-item>
          <code>
explicit tsv_source(CharInput&amp;&amp; input) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes <c>in</c> with <c>std::move(input)</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;CharInput></c>.</remark>
        </code-item>
      </section>

      <section id="tsv_source.inv">
        <name><c>tsv_source</c> invocation</name>

        <code-item>
          <code>
template &lt;class HandlerR>
  parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler) const&amp; noexcept(<nc>see below</nc>);
template &lt;class HandlerR>
  parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler)     &amp;&amp; noexcept(<nc>see below</nc>);
          </code>
          <preface>Let <c>Handler</c> be <c>std::decay_t&lt;HandlerR></c>.</preface>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>char_type</c>.</requires>
          <returns>A table parser object <c>p</c> for the TSV text format (<xref id="definitions.tsv_text"/>).
                   <c>p</c> holds an object of <c>CharInput</c> constructed with <c>in</c> (first form) or <c>std::move(in)</c> (second form) as its tied character input
                   and an object of <c>Handler</c> constructed with <c>std::forward&lt;HandlerR>(handler)</c> as its tied table handler.</returns>
          <remark>These operators shall not participate in overload resolution unless <c>Handler</c> is deemed to have buffer control.
                  The expression inside <c>noexcept</c> is equivalent to
                  <c>std::is_nothrow_constructible_v&lt;Handler, HandlerR&amp;&amp;> &amp;&amp; std::is_nothrow_copy_constructible&lt;CharInput></c> (first form) or
                  <c>std::is_nothrow_constructible_v&lt;Handler, HandlerR&amp;&amp;> &amp;&amp; std::is_nothrow_move_constructible&lt;CharInput></c> (second form).</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
  parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
    operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
               const Allocator&amp; alloc = Allocator()) const&amp; noexcept(<nc>see below</nc>);
template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
  parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
    operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
               const Allocator&amp; alloc = Allocator())     &amp;&amp; noexcept(<nc>see below</nc>);
          </code>
          <preface>Let <c>Handler</c> be <c>std::decay_t&lt;HandlerR></c>.</preface>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>char_type</c>.
                    <c>Allocator</c> shall meet the <c>Allocator</c> requirements for <c>char_type</c>.</requires>
          <returns>A table parser object <c>p</c> for the TSV text format (<xref id="definitions.tsv_text"/>).
                   <c>p</c> holds an object of <c>CharInput</c> constructed with <c>in</c> (first form) or <c>std::move(in)</c> (second form) as its tied character input,
                   an object of <c>Handler</c> constructed with <c>std::forward&lt;HandlerR>(handler)</c> as its tied table handler, and a copy of <c>alloc</c> to allocate and deallocate the character buffer.
                   The length of the buffer allocated by <c>p</c> is unspecified, but <c>buffer_size</c> serves as a hint. <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.</returns>
          <remark>These operators shall not participate in overload resolution unless <c>Handler</c> is not an instance of <c>std::reference_wrapper</c> and is deemed to have no buffer control.
                  The expression inside <c>noexcept</c> is equivalent to
                  <c>std::is_nothrow_constructible_v&lt;Handler, HandlerR&amp;&amp;> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;CharInput> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;Allocator></c> (first form) or
                  <c>std::is_nothrow_constructible_v&lt;Handler, HandlerR&amp;&amp;> &amp;&amp; std::is_nothrow_move_constructible_v&lt;CharInput> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;Allocator></c> (second form).</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Handler, class... Args>
  <nc>see below</nc> operator()(std::reference_wrapper&lt;Handler> handler,
                       Args&amp;&amp;... args) const&amp; noexcept(<nc>see below</nc>);
          </code>
          <effects>Equivalent to: <c>return (*this)(wrap_ref(handler), std::forward&lt;Args>(args)...);</c></effects>
          <remark>This operator shall not participate in overload resolution unless <c>std::is_invocable_v&lt;const tsv_source&amp;, reference_handler&lt;Handler>&amp;&amp;, Args&amp;&amp;...></c> is <c>true</c>.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_invocable_v&lt;const tsv_source&amp;, reference_handler&lt;Handler>, Args...></c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Handler, class... Args>
  <nc>see below</nc> operator()(std::reference_wrapper&lt;Handler> handler,
                       Args&amp;&amp;... args)     &amp;&amp; noexcept(<nc>see below</nc>);
          </code>
          <effects>Equivalent to: <c>return std::move(*this)(wrap_ref(handler), std::forward&lt;Args>(args)...);</c></effects>
          <remark>This operator shall not participate in overload resolution unless <c>std::is_invocable_v&lt;tsv_source&amp;&amp;, reference_handler&lt;Handler>&amp;&amp;, Args&amp;&amp;...></c> is <c>true</c>.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_invocable_v&lt;tsv_source, reference_handler&lt;Handler>, Args...></c>.</remark>
        </code-item>
      </section>

      <section id="tsv_source.special">
        <name><c>tsv_source</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class CharInput>
  void swap(tsv_source&lt;CharInput>&amp; left,
            tsv_source&lt;CharInput>&amp; right) noexcept(noexcept(left.swap(right)));
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>This overload shall not participate in overload resolution unless <c>std::is_swappable_v&lt;CharInput></c> is <c>true</c>.</remark>
        </code-item>
      </section>

      <section id="tsv_source.creation">
        <name><c>tsv_source</c> creation functions</name>

        <code-item>
          <code>
template &lt;class... Args> auto make_tsv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>)
  -> tsv_source&lt;decltype(make_char_input(std::forward&lt;Args>(args)...))>;
          </code>
          <preface>Let <c>CharInput</c> be <c>decltype(make_char_input(std::forward&lt;Args>(args)...))</c>.</preface>
          <effects>Equivalent to: <c>return tsv_source&lt;CharInput>(std::forward&lt;Args>(args)...);</c></effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible_v&lt;CharInput, Args&amp;&amp;...></c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class CharInputR> auto make_tsv_source(CharInputR&amp;&amp; in) noexcept(<nc>see below</nc>)
  -> tsv_source&lt;std::decay_t&lt;CharInputR>>;
          </code>
          <preface>Let <c>CharInput</c> be <c>std::decay_t&lt;CharInputR></c>.</preface>
          <effects>Equivalent to: <c>return tsv_source&lt;CharInput>(make_char_input(std::forward&lt;CharInputR>(in)));</c></effects>
          <remark>This overload shall participate in overload resolution if and only if <c>make_char_input(std::declval&lt;CharInputR&amp;&amp;>())</c> is not well-formed when treated as an unevaluated operand
                  and <c>std::is_invocable_r_v&lt;typename CharInput::size_type, CharInput&amp;, typename CharInput::char_type*, typename CharInput::size_type></c> is <c>true</c>.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible_v&lt;CharInput, CharInputR&amp;&amp;></c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="parse_tsv">
      <name>Utilizing the TSV parser</name>

      <code-item>
        <code>
template &lt;class CharInput, class... OtherArgs>
  bool parse_tsv(const tsv_source&lt;CharInput>&amp;  src, OtherArgs&amp;&amp;... other_args);
        </code>
        <effects>Equivalent to: <c>return src(std::forward&lt;OtherArgs>(other_args)...)();</c>.</effects>
      </code-item>

      <code-item>
        <code>
template &lt;class CharInput, class... OtherArgs>
  bool parse_tsv(      tsv_source&lt;CharInput>&amp;&amp; src, OtherArgs&amp;&amp;... other_args);
        </code>
        <effects>Equivalent to: <c>return std::move(src)(std::forward&lt;OtherArgs>(other_args)...)();</c>.</effects>
      </code-item>

      <code-item>
        <code>
template &lt;class Arg1, class Arg2, class... OtherArgs>
  bool parse_tsv(Arg1&amp;&amp; arg1, Arg2&amp;&amp; arg2, OtherArgs&amp;&amp;... other_args);
        </code>
        <effects><p>If <c>make_tsv_source(std::declval&lt;Arg1&amp;&amp;>(), std::declval&lt;Arg2&amp;&amp;>())</c> is well-formed when treated as an unevaluated operand, equivalent to:</p>
                 <code>return parse_tsv(make_tsv_source(std::forward&lt;Arg1>(arg1), std::forward&lt;Arg2>(arg2)),
                 std::forward&lt;OtherArgs>(other_args)...);</code>
                 <p>Otherwise, equivalent to:</p>
                 <code>return parse_tsv(make_tsv_source(std::forward&lt;Arg1>(arg1)),
                 std::forward&lt;Arg2>(arg2), std::forward&lt;OtherArgs>(other_args)...);</code></effects>
        <remark>This function template shall not participate in overload resolution unless <c>std::decay_t&lt;Arg1></c> is not an instance of <c>tsv_source</c> and either of <c>make_tsv_source(std::declval&lt;Arg1&amp;&amp;>())</c> or <c>make_tsv_source(std::declval&lt;Arg1&amp;&amp;>(), std::declval&lt;Arg2&amp;&amp;>())</c> is well-formed when treated as an unevaluated operand.</remark>
      </code-item>
    </section>
  </section>
</section>

<section id="builtin.handlers">
  <name>Default table handlers</name>

  <section id="extractor">
    <name>Extraction of records into another stream</name>

    <section id="extractor.general">
      <name>General</name>

      <p>Commata offers two class templates <c>record_extractor</c> (<xref id="record_extractor"/>) and <c>record_extractor_with_indexed_key</c> (<xref id="record_extractor_with_indexed_key"/>), whose instances meet <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>), as simple facilities to reduce text records.</p>
      <p>An object of an instance of <c>record_extractor</c> or <c>record_extractor_with_indexed_key</c> receives parsing events from a parser and forwards some qualified records into another stream.
         Whether a record is qualified to be forwarded or not is decided by the value of its field at the <n>target field index</n>.
         The target field index can be given explicitly by the program (with <c>record_extractor_with_indexed_key</c>), or can be decided in reference to the first one record (with <c>record_extractor</c>).</p>
      <p>A record that can not be decided whether it is qualified to be forwarded or not due to non-existence of the field at the target field index shall cause an exception.</p>
      <p>An object of an instance of <c>record_extractor</c> or <c>record_extractor_with_indexed_key</c> can not be reused; that is, it can receive the parsing events that the parser emits only once.</p>
    </section>

    <section id="hpp.record_extractor.syn">
      <name>Header <c>"commama/record_extractor.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;memory>
#include &lt;optional>
#include &lt;ostream>
#include &lt;streambuf>
#include &lt;string>

#include "text_error.hpp"

namespace commata {
  <c>// <n><xref id="record_extraction_error"/>, record_extraction_error:</n></c>
  class record_extraction_error;

  enum class header_forwarding : <nc>unspecified unsigned integer type</nc> {
    yes, no
  };

  constexpr std::size_t record_extractor_npos = -1;

  <c>// <n><xref id="record_extractor"/>, record_extractor:</n></c>
  template &lt;class FieldNamePred, class FieldValuePred, class Ch, class Tr, class Allocator>
    class record_extractor;

  <c>// <n><xref id="record_extractor_with_indexed_key"/>, record_extractor_with_indexed_key:</n></c>
  template &lt;class FieldValuePred, class Ch, class Tr, class Allocator>
    class record_extractor_with_indexed_key;

  <c>// <n><xref id="record_extractor.creation"/>, creation functions:</n></c>
  template &lt;class FieldNamePred, class FieldValuePred,
            class Ch, class Tr, class Allocator, class... Appendices>
    <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                    std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                    FieldNamePred&amp;&amp; field_name_pred,
                                    FieldValuePred&amp;&amp; field_value_pred,
                                    Appendices&amp;&amp;... appendices);
  template &lt;class FieldValuePred,
            class Ch, class Tr, class Allocator, class... Appendices>
    <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                    std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                    std::size_t target_field_index,
                                    FieldValuePred&amp;&amp; field_value_pred,
                                    Appendices&amp;&amp;... appendices);
  template &lt;class FieldIdentifier, class FieldValuePred, class Ch, class Tr, class... Appendices>
    <nc>see below</nc> make_record_extractor(std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                    FieldIdentifier&amp;&amp; field_id,
                                    FieldValuePred&amp;&amp; field_value_pred,
                                    Appendices&amp;&amp;... appendices);
}
      </codeblock>
    </section>

    <section id="record_extraction_error">
      <name>Class <c>record_extraction_error</c></name>

      <codeblock>
namespace commata {
  class record_extraction_error : public text_error {
  public:
    using text_error::text_error;
  };
}
      </codeblock>

      <p>The class <c>record_extraction_error</c> defines a type of the objects thrown by <c>record_extractor</c> objects and <c>record_extractor_with_indexed_key</c> objects during the parsing.</p>
    </section>

    <section id="record_extractor">
      <name>Class template <c>record_extractor</c></name>

      <codeblock>
namespace commata {
  template &lt;class FieldNamePred, class FieldValuePred, class Ch,
            class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class record_extractor {
  public:
    using char_type = Ch;
    using traits_type = Tr;
    using allocator_type = Allocator;

    <c>// <n><xref id="record_extractor.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class FieldNamePredR, class FieldValuePredR>
      record_extractor(std::basic_streambuf&lt;Ch, Tr>&amp; out,
                       FieldNamePredR&amp;&amp; field_name_pred, FieldValuePredR&amp;&amp; field_value_pred,
                       header_forwarding header = header_forwarding::yes,
                       std::size_t max_record_num = 0);
    template &lt;class FieldNamePredR, class FieldValuePredR>
      record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                       std::basic_streambuf&lt;Ch, Tr>&amp; out,
                       FieldNamePredR&amp;&amp; field_name_pred, FieldValuePredR&amp;&amp; field_value_pred,
                       header_forwarding header = header_forwarding::yes,
                       std::size_t max_record_num = 0);
    record_extractor(record_extractor&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~record_extractor();

    <c>// <n><xref id="record_extractor.accessors"/>, accessors:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n>six member functions below are declared and defined to meet the TableHandler</n>
    // <n>requirements (<xref id="table_handler.requirements"/>):</n></c>
    void start_buffer(const Ch* buffer_begin, const Ch* buffer_end);
    void end_buffer(const Ch* buffer_end);
    void start_record(const Ch* record_begin);
    bool end_record(const Ch* record_end);
    void update(const Ch* first, const Ch* last);
    void finalize(const Ch* first, const Ch* last);

    <c>// <n><xref id="record_extractor.processing_state"/>, processing state:</n></c>
    bool is_in_header() const noexcept;
  };

  template &lt;class FieldNamePred, class FieldValuePred, class Ch, class Tr, class... Args>
    record_extractor(std::basic_streambuf&lt;Ch, Tr>&amp;, FieldNamePred, FieldValuePred, Args...)
      -> record_extractor&lt;FieldNamePred, FieldValuePred, Ch, Tr, std::allocator&lt;Ch>>;
  template &lt;class FieldNamePred, class FieldValuePred, class Ch, class Tr,class Allocator,
            class... Args>
    record_extractor(std::allocator_arg_t, Allocator, std::basic_streambuf&lt;Ch, Tr>&amp;,
                     FieldNamePred, FieldValuePred, Args...)
      -> record_extractor&lt;FieldNamePred, FieldValuePred, Ch, Tr, Allocator>;
}
      </codeblock>

      <p>An instance of <c>record_extractor</c> is a type that meets <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for the template parameter <c>Ch</c>.</p>
      <p>An object of it first scans the first record (hereinafter called the <n>header record</n>) to decide the target field index,
         and then scan the all non-header records to decide whether the record is forwarded to the stream in terms of their values of the field at the target field index.</p>
      <p>When the target field index is left undecided after the scanning of <c>record_extractor_npos - 1</c> text fields in the header record finished, an exception shall be thrown.</p>
      <p><c>FieldNamePred</c> and <c>FieldValuePred</c> shall be unary predicate types for a <c>std::basic_string_view&lt;Ch, Tr></c> parameter and returns a <c>bool</c> value.
         <c>Ch</c> shall be a char-like type.
         <c>Tr</c> shall be a character traits type of <c>std::remove_const_t&lt;Ch></c>.
         <c>Allocator</c> shall meet the <c>Allocator</c> requirements.</p>
      <p>When the implementations of this class template throw an exception whose type is <c>text_error</c> or one of its derived classes, the message retrieved with a call to <c>what</c> member function on the exception object may be an NTMBS converted from an wide character string with <c>std::wcrtomb</c> or <c>std::wcsrtombs</c>, that is, with the C library locale.</p>

      <section id="record_extractor.cons">
        <name><c>record_extractor</c> constructors and assignment operators</name>

        <code-item>
          <code>
template &lt;class FieldNamePredR, class FieldValuePredR>
  record_extractor(std::basic_streambuf&lt;Ch, Tr>&amp; out,
                   FieldNamePredR&amp;&amp; field_name_pred, FieldValuePredR&amp;&amp; field_value_pred,
                   header_forwarding header = header_forwarding::yes,
                   std::size_t max_record_num = 0);
template &lt;class FieldNamePredR, class FieldValuePredR>
  record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                   std::basic_streambuf&lt;Ch, Tr>&amp; out,
                   FieldNamePredR&amp;&amp; field_name_pred, FieldValuePredR&amp;&amp; field_value_pred,
                   header_forwarding header = header_forwarding::yes,
                   std::size_t max_record_num = 0);
          </code>
          <requires>For the first form, <c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <effects>Constructs an object <c>record_extractor</c>. The parameters work as <xref id="table.record_extractor.cons"/> shows.
                   An object constructed by the first form uses a default constructed <c>Allocator</c> object to allocate memory.
                   One constructed by the second form uses an <c>Allocator</c> object copy constructed from <c>alloc</c>.</effects>
          <remark>These constructors shall not participate in overload resolution unless <c>std::is_constructible_v&lt;FieldNamePred, FieldNamePredR&amp;&amp;> &amp;&amp; std::is_constructible_v&lt;FieldValuePred, FieldValuePredR&amp;&amp;></c> is <c>true</c>.</remark>

          <table id="table.record_extractor.cons">
            <caption>Principal parameters of the constructors of <c>record_extractor</c> and the behaviour of the constructed object</caption>
            <col width="2"/><col width="12"/>
            <tr>
              <th>Parameter</th>
              <th>Remarks</th>
            </tr>
            <tr>
              <td><c>out</c></td>
              <td>References a stream buffer object that receives the extracted records.</td>
            </tr>
            <tr>
              <td><c>field_name_pred</c></td>
              <td>Forwarded as an argument to a constructor of <c>FieldNamePred</c> to make a predicate object called for every field in the header record.
                  The call parameters is the field value.
                  If returns a non-<c>false</c> value, then the field index becomes the target field index.</td>
            </tr>
            <tr>
              <td><c>field_value_pred</c></td>
              <td>Forwarded as an argument to a constructor of <c>FieldNamePred</c> to make a predicate object called for every field at the target field index of non-header records.
                  The call parameters is the field value.
                  If returns a non-<c>false</c> value, then the record is qualified to be forwarded to <c>out</c>.</td>
            </tr>
            <tr>
              <td><c>header</c></td>
              <td>If equal to <c>header_forwarding::yes</c>, the header record will always be forwarded to <c>out</c>.
                  Otherwise, if equal to <c>header_forwarding::no</c>, it will never be forwarded to <c>out</c>.
                  Otherwise, the behaviour is undefined.</td>
            </tr>
            <tr>
              <td><c>max_record_num</c></td>
              <td>If not equal to <c>0</c>, at most <c>max_record_num</c> non-header records are forwarded to <c>out</c>, and parsing will be aborted after <c>max_record_num</c> are forwarded.</td>
            </tr>
          </table>
        </code-item>

        <code-item>
          <code>
record_extractor(record_extractor&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Move constructs from an rvalue <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;FieldNamePred> &amp;&amp; std::is_nothrow_move_constructible_v&lt;FieldValuePred></c>.
                  If exits via an exception, <c>other</c> will be left in a valid but unspecified state.</remark>
        </code-item>
      </section>

      <section id="record_extractor.accessors">
        <name><c>record_extractor</c> accessors</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object used to allocate memory by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="record_extractor.processing_state">
        <name><c>record_extractor</c> processing state</name>
        <code-item>
          <code>
bool is_in_header() const noexcept;
          </code>
          <requires>Shall be invoked within a call of <c>parse_csv</c> (<xref id="parse_csv"/>).</requires>
          <returns><c>true</c> if <c>end_record</c> has not be called for the header record; <c>false</c> otherwise.</returns>
          <note>This member may be useful to implement a table handler class whose object wraps a <c>record_extractor</c> object.</note>
        </code-item>
      </section>
    </section>

    <section id="record_extractor_with_indexed_key">
      <name>Class template <c>record_extractor_with_indexed_key</c></name>

      <codeblock>
namespace commata {
  template &lt;class FieldValuePred, class Ch,
            class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class record_extractor_with_indexed_key {
  public:
    using char_type = Ch;
    using traits_type = Tr;
    using allocator_type = Allocator;

    <c>// <n><xref id="record_extractor_with_indexed_key.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class FieldValuePredR>
      record_extractor_with_indexed_key(std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                        std::size_t target_field_index,
                                        FieldValuePredR&amp;&amp; field_value_pred,
                                        std::optional&lt;header_forwarding> header
                                          = header_forwarding::yes,
                                        std::size_t max_record_num = 0);
    template &lt;class FieldValuePredR>
      record_extractor_with_indexed_key(std::allocator_arg_t, const Allocator&amp; alloc,
                                        std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                        std::size_t target_field_index,
                                        FieldValuePredR&amp;&amp; field_value_pred,
                                        std::optional&lt;header_forwarding> header
                                          = header_forwarding::yes,
                                        std::size_t max_record_num = 0);
    record_extractor_with_indexed_key(record_extractor_with_indexed_key&amp;&amp; other)
                                      noexcept(<nc>see below</nc>);
   ~record_extractor_with_indexed_key();

    <c>// <n><xref id="record_extractor_with_indexed_key.accessors"/>, accessors:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n>six member functions below are declared and defined to meet the TableHandler</n>
    // <n>requirements (<xref id="table_handler.requirements"/>):</n></c>
    void start_buffer(const Ch* buffer_begin, const Ch* buffer_end);
    void end_buffer(const Ch* buffer_end);
    void start_record(const Ch* record_begin);
    bool end_record(const Ch* record_end);
    void update(const Ch* first, const Ch* last);
    void finalize(const Ch* first, const Ch* last);

    <c>// <n><xref id="record_extractor_with_indexed_key.processing_state"/>, processing state:</n></c>
    bool is_in_header() const noexcept;
  };

  template &lt;class FieldValuePred, class Ch, class Tr, class... Args>
    record_extractor_with_indexed_key(std::basic_streambuf&lt;Ch, Tr>&amp;, std::size_t, FieldValuePred,
                                      Args...)
      -> record_extractor_with_indexed_key&lt;FieldValuePred, Ch, Tr, std::allocator&lt;Ch>>;
  template &lt;class FieldValuePred, class Ch, class Tr,class Allocator, class... Args>
    record_extractor_with_indexed_key(std::allocator_arg_t, Allocator,
                                      std::basic_streambuf&lt;Ch, Tr>&amp;, std::size_t, FieldValuePred,
                                      Args...)
      -> record_extractor_with_indexed_key&lt;FieldValuePred, Ch, Tr, Allocator>;
}
      </codeblock>

      <p>An instance of <c>record_extractor_with_indexed_key</c> is a type that meets <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for the template parameter <c>Ch</c>.</p>
      <p>It regards the first at most one record as the <n>header record</n>.
         It scans the all non-header records to decide whether the record is forwarded to the stream in terms of their values of the field at the target field index instructed with a parameter of its constructor explicitly.</p>
      <p><c>FieldValuePred</c> shall be a unary predicate type for a <c>std::basic_string_view&lt;Ch, Tr></c> parameter and returns a <c>bool</c> value.
         <c>Ch</c> shall be a char-like type.
         <c>Tr</c> shall be a character traits type of <c>std::remove_const_t&lt;Ch></c>.
         <c>Allocator</c> shall meet the <c>Allocator</c> requirements.</p>

      <section id="record_extractor_with_indexed_key.cons">
        <name><c>record_extractor_with_indexed_key</c> constructors and assignment operators</name>

        <code-item>
          <code>
template &lt;class FieldValuePredR>
  record_extractor_with_indexed_key(std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                    std::size_t target_field_index,
                                    FieldValuePredR&amp;&amp; field_value_pred,
                                    std::optional&lt;header_forwarding> header
                                      = header_forwarding::yes,
                                    std::size_t max_record_num = 0);
template &lt;class FieldValuePredR>
  record_extractor_with_indexed_key(std::allocator_arg_t, const Allocator&amp; alloc,
                                    std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                    std::size_t target_field_index,
                                    FieldValuePredR&amp;&amp; field_value_pred,
                                    std::optional&lt;header_forwarding> header
                                      = header_forwarding::yes,
                                    std::size_t max_record_num = 0);
          </code>
          <requires>For the first form, <c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <effects>Constructs an object <c>record_extractor_with_indexed_key</c>. The parameters work as <xref id="table.record_extractor_with_indexed_key.cons"/> shows.
                   An object constructed by the first form uses a default constructed <c>Allocator</c> object to allocate memory.
                   One constructed by the second form uses an <c>Allocator</c> object copy constructed from <c>alloc</c>.</effects>
          <remark>These constructors shall not participate in overload resolution unless <c>std::is_constructible_v&lt;FieldValuePred, FieldValuePredR&amp;&amp;></c> is <c>true</c>.</remark>

          <table id="table.record_extractor_with_indexed_key.cons">
            <caption>Principal parameters of the constructors of <c>record_extractor_with_indexed_key</c> and the behaviour of the constructed object</caption>
            <col width="2"/><col width="12"/>
            <tr>
              <th>Parameter</th>
              <th>Remarks</th>
            </tr>
            <tr>
              <td><c>out</c></td>
              <td>References a stream buffer object that receives the extracted records.</td>
            </tr>
            <tr>
              <td><c>target_field_index</c></td>
              <td>Tells the zero-based target field index, which <c>field_value_pred</c> is applied. If equal to <c>record_extractor_npos</c>, this constructor exits with <c>std::out_of_range</c>.</td>
            </tr>
            <tr>
              <td><c>field_value_pred</c></td>
              <td>Forwarded as an argument to a constructor of <c>FieldNamePred</c> to make a predicate object called for every field at the target field index of non-header records.
                  The call parameters is the field value.
                  If returns a non-<c>false</c> value, then the record is qualified to be forwarded to <c>out</c>.</td>
            </tr>
            <tr>
              <td><c>header</c></td>
              <td>If does not have value, the first record of the text table will not be regarded as a header record, that is, it will be treated similarly to other records.
                  Otherwise, if the value is <c>header_forwarding::yes</c>, it will be regarded as a header record and will always be forwarded to <c>out</c>.
                  Otherwise, if the value is <c>header_forwarding::no</c>, it will be regarded as a header record and will never be forwarded to <c>out</c>.
                  Otherwise, the behaviour is undefined.</td>
            </tr>
            <tr>
              <td><c>max_record_num</c></td>
              <td>If not equal to <c>0</c>, at most <c>max_record_num</c> non-header records are forwarded to <c>out</c>, and parsing will be aborted after <c>max_record_num</c> are forwarded.</td>
            </tr>
          </table>
        </code-item>
        <code-item>
          <code>
record_extractor_with_indexed_key(record_extractor_with_indexed_key&amp;&amp; other)
                                  noexcept(<nc>see below</nc>);
          </code>
          <effects>Move constructs from an rvalue <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;FieldValuePred></c>.</remark>
        </code-item>
      </section>

      <section id="record_extractor_with_indexed_key.accessors">
        <name><c>record_extractor_with_indexed_key</c> accessors</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object used to allocate memory by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="record_extractor_with_indexed_key.processing_state">
        <name><c>record_extractor_with_indexed_key</c> processing state</name>
        <code-item>
          <code>
bool is_in_header() const noexcept;
          </code>
          <requires>Shall be invoked within a call of <c>parse_csv</c> (<xref id="parse_csv"/>).</requires>
          <returns><c>true</c> if <c>*this</c> is configured to regard the first records as the header record and
                   <c>end_record</c> has not be called for the header record; <c>false</c> otherwise.</returns>
          <note>This member may be useful to implement a table handler class whose object wraps a <c>record_extractor_with_indexed_key</c> object.</note>
        </code-item>
      </section>
    </section>

    <section id="record_extractor.creation">
      <name><c>record_extractor</c> and <c>record_extractor_with_indexed_key</c> creation functions</name>

      <p>In this subclause, for a certain expression <c>t</c> whose type is <c>T</c>, an expression <c><nc>STRING_PRED</nc>&lt;Ch, Tr>(t)</c> is defined as following:</p>
      <ul>
        <li>if <c>std::is_convertible_v&lt;T&amp;, const Ch*></c> (if <c>t</c> is an lvalue) or <c>std::is_convertible_v&lt;T, const Ch*></c> (otherwise) is <c>true</c>,
            a prvalue of a unary predicate object taking an <c>std::basic_string_view&lt;Ch, Tr></c> parameter and returning <c>bool</c>:
            <ul>
              <li>that holds an <c>std::basic_string_view&lt;Ch, Tr></c> object (hereinafter called <c>v</c>) initialized with a value of <c>const Ch*</c> converted from an lvaue (if <c>t</c> is an lvalue) or an xvalue (otherwise) of <c>t</c>,</li>
              <li>that tells if a string view object is equal to <c>v</c>, and</li>
              <li>whose type <c>S</c> is unspecified and satisfies <c>std::is_nothrow_move_constructible_v&lt;S> == true</c>,</li>
            </ul>
        </li>
        <li>otherwise, if <c>t</c> is an lvalue and <c>T</c> meets the <c>ForwardAccessibleRange</c> requirements for <c>Ch</c> (<xref id="accessible_range.requirements"/>),
            a prvalue of a unary predicate object taking an <c>std::basic_string_view&lt;Ch, Tr></c> parameter and returning <c>bool</c>:
            <ul>
              <li>that holds the return value of <c>std::addressof(t)</c> (hereinafter called <c>p</c>),</li>
              <li>that tells if a string view object is equal to the range formed by <c>*p</c> (<xref id="form_accessible_range"/>) in terms of <c>Tr::eq</c>, and</li>
              <li>whose type <c>S</c> is unspecified and satisfies <c>std::is_nothrow_move_constructible_v&lt;S> == true</c>,</li>
            </ul>
        </li>
        <li>otherwise, if <c>T</c> meets the <c>ForwardAccessibleRange</c> requirements for <c>Ch</c> (<xref id="accessible_range.requirements"/>),
            a prvalue of a unary predicate object taking an <c>std::basic_string_view&lt;Ch, Tr></c> parameter and returning <c>bool</c>:
            <ul>
              <li>that holds a copy of <c>t</c> (hereinafter called <c>u</c>) constructed with an xvalue of <c>t</c>,</li>
              <li>that tells if a string view object is equal to the range formed by <c>u</c> (<xref id="form_accessible_range"/>) in terms of <c>Tr::eq</c>, and</li>
              <li>whose type <c>S</c> is unspecified and satisfies <c>std::is_nothrow_move_constructible_v&lt;S> == std::is_nothrow_move_constructible_v&lt;T></c>,</li>
            </ul>
        </li>
        <li>otherwise, an lvalue (if <c>t</c> is an lvalue) or an xvalue (otherwise) of <c>t</c>.</li>
      </ul>

      <code-item>
        <code>
template &lt;class FieldNamePred, class FieldValuePred,
          class Ch, class Tr, class Allocator, class... Appendices>
  <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                  std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                  FieldNamePred&amp;&amp; field_name_pred,
                                  FieldValuePred&amp;&amp; field_value_pred,
                                  Appendices&amp;&amp;... appendices);
        </code>
        <effects><p>Equivalent to:</p>
                 <code>auto fnp = <n>STRING_PRED</n>&lt;Ch, Tr>(std::forward&lt;FieldNamePred>(field_name_pred));
auto fvp = <n>STRING_PRED</n>&lt;Ch, Tr>(std::forward&lt;FieldValuePred>(field_value_pred));
return record_extractor&lt;decltype(fnp), decltype(fvp), Ch, Tr, Allocator>(
         std::allocator_arg, alloc,
         out, std::move(fnp), std::move(fvp), std::forward&lt;Appendices>(appendices)...);</code>
        </effects>
        <remark>This overload shall not participate in overload resolution unless both of <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;FieldNamePred>())</c> and
                <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;FieldValuePred>())</c> are well-formed when treated as unevaluated operands, and
                for each type (hereinafter called <c>T</c>) of their types, <c>std::declval&lt;bool&amp;>() = std::declval&lt;T&amp;>()(std::declval&lt;std::basic_string_view&lt;Ch, Tr>&amp;>()</c> is well-formed when treated as an unevaluated operand.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class FieldValuePred,
          class Ch, class Tr, class Allocator, class... Appendices>
  <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                  std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                  std::size_t target_field_index,
                                  FieldValuePred&amp;&amp; field_value_pred,
                                  Appendices&amp;&amp;... appendices);
        </code>
        <effects><p>Equivalent to:</p>
                 <code>auto fvp = <n>STRING_PRED</n>&lt;Ch, Tr>(std::forward&lt;FieldValuePred>(field_value_pred));
return record_extractor_with_indexed_key&lt;decltype(fvp), Ch, Tr, Allocator>(
         std::allocator_arg, alloc,
         out, target_field_index, std::move(fvp), std::forward&lt;Appendices>(appendices)...);</code>
        </effects>
        <remark>This overload shall not participate in overload resolution unless <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;FieldValuePred>())</c> is well-formed when treated as an unevaluated operand, and
                for its type <c>T</c>, <c>std::declval&lt;bool&amp;>() = std::declval&lt;T&amp;>()(std::declval&lt;std::basic_string_view&lt;Ch, Tr>&amp;>()</c> is well-formed when treated as an unevaluated operand.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr, class... Appendices>
  <nc>see below</nc> make_record_extractor(std::basic_streambuf&lt;Ch, Tr>&amp; out,
                                  Appendices&amp;&amp;... appendices);
        </code>
        <effects><p>Equivalent to:</p>
                 <code>return make_record_extractor(std::allocator_arg, std::allocator&lt;Ch>(),
                             out, std::forward&lt;Appendices>(appendices)...);</code>
        </effects>
        <remark>This overload shall not participate in overload resolution unless <c>make_record_extractor(std::declval&lt;std::allocator_arg_t>(), std::declval&lt;std::allocator&lt;Ch>>(), std::declval&lt;std::basic_streambuf&lt;Ch, Tr>&amp;>(), std::declval&lt;Appendices>()...)</c> is well-formed when treated as an unevaluated operand.</remark>
      </code-item>
    </section>
  </section>

  <section id="stored">
    <name>Creation of a whole table image in memory</name>

    <section id="stored.general">
      <name>General</name>

      <p>Commata offers class template <c>basic_stored_table</c> (<xref id="basic_stored_table"/>), which is an implementation of a in-memory text table (<xref id="definitions.text_table"/>).
         The text values of text fields contained by an object of an instance of it are represented by class template <c>basic_stored_value</c> (<xref id="basic_stored_value"/>),
         whose instance is a type whose object is actually a contiguous and null-terminated range of char type objects of the text table.</p>
      <p>A text table is built by an object of an instance of <c>stored_table_builder</c> (<xref id="stored_table_builder"/>), whose instances meet <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>).</p>
    </section>

    <section id="hpp.stored_table.syn">
      <name>Header <c>"commama/stored_table.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;deque>
#include &lt;functional>
#include &lt;iterator>
#include &lt;memory>
#include &lt;ostream>
#include &lt;string>
#include &lt;string_view>
#include &lt;type_traits>
#include &lt;vector>

namespace commata {
  <c>// <n><xref id="basic_stored_value"/>, basic_stored_value:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;std::remove_const_t&lt;Ch>>>
    class basic_stored_value;

  template &lt;class ChL, class ChR, class Tr>
    bool operator==(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator==(const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator==(const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator!=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator!=(const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt; (const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt; (const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator> (const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator> (const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator> (const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt;=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt;=(const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator>=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator>=(const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);

  template &lt;class ChC, class Tr>
    std::basic_ostream&lt;std::remove_const_t&lt;ChC>, Tr>&amp; operator&lt;&lt;(
      std::basic_ostream&lt;ChC, Tr>&amp; os, const basic_stored_value&lt;ChC, Tr>&amp; o);

  template &lt;class Ch, class Tr>
    std::basic_string&lt;std::remove_const_t&lt;Ch>, std::char_traits&lt;std::remove_const_t&lt;Ch>>>
      to_string_view(basic_stored_value&lt;Ch, Tr>&amp; o) noexcept;
  template &lt;class Ch, class Tr, class Allocator = std::allocator&lt;std::remove_const_t&lt;Ch>>>
    std::basic_string&lt;std::remove_const_t&lt;Ch>, std::char_traits&lt;std::remove_const_t&lt;Ch>>, Allocator>
      to_string(basic_stored_value&lt;Ch, Tr>&amp; o, const Allocator&amp; alloc = Allocator());

  using stored_value   = basic_stored_value&lt;char>;
  using wstored_value  = basic_stored_value&lt;wchar_t>;
  using cstored_value  = basic_stored_value&lt;const char>;
  using cwstored_value = basic_stored_value&lt;const wchar_t>;

  <c>// <n><xref id="basic_stored_table"/>, basic_stored_table:</n></c>
  template &lt;class Content, class Allocator = std::allocator&lt;Content>> class basic_stored_table;

  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);

  template &lt;class Content, class Allocator>
    void swap(basic_stored_table&lt;Content, Allocator>&amp; left,
              basic_stored_table&lt;Content, Allocator>&amp; right)
      noexcept(noexcept(left.swap(right)));

  using stored_table   = basic_stored_table&lt;std::deque&lt;std::vector&lt;stored_value>>>;
  using wstored_table  = basic_stored_table&lt;std::deque&lt;std::vector&lt;wstored_value>>>;
  using cstored_table  = basic_stored_table&lt;std::deque&lt;std::vector&lt;cstored_value>>>;
  using cwstored_table = basic_stored_table&lt;std::deque&lt;std::vector&lt;cwstored_value>>>;

  <c>// <n><xref id="stored_table_builder_option"/>, stored_table_builder_option:</n></c>
  enum class stored_table_builder_option : <nc>see below</nc>;

  constexpr stored_table_builder_option operator|(
    stored_table_builder_option left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option&amp; operator|=(
    stored_table_builder_option&amp; left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option operator&amp;(
    stored_table_builder_option left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option&amp; operator&amp;=(
    stored_table_builder_option&amp; left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option operator^(
    stored_table_builder_option left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option&amp; operator^=(
    stored_table_builder_option&amp; left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option operator~(stored_table_builder_option handle) noexcept;

  <c>// <n><xref id="stored_table_builder"/>, stored_table_builder:</n></c>
  template &lt;class Content, class Allocator,
            stored_table_builder_option Options = stored_table_builder_option::none>
    class stored_table_builder;

  template &lt;stored_table_builder_option Options = stored_table_builder_option::none,
            class Content, class Allocator, class... Args>
    stored_table_builder&lt;Content, Allocator, Options> make_stored_table_builder(
      basic_stored_table&lt;Content, Allocator>&amp; table, Args&amp;&amp;... args);
}

namespace std {
  <c>// <n><xref id="basic_stored_value.hash"/>, basic_stored_value hash support:</n></c>
  template &lt;class Ch, class Tr> struct hash&lt;commata::basic_stored_value&lt;Ch, Tr>>;
}
      </codeblock>
    </section>

    <section id="basic_stored_value">
      <name>Class template <c>basic_stored_value</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;std::remove_const_t&lt;Ch>>>
    class basic_stored_value {
  public:
    using value_type      = std::remove_const_t&lt;Ch>;
    using reference       = Ch&amp;;
    using const_reference = const Ch&amp;;
    using pointer         = Ch*;
    using const_pointer   = const Ch*;
    using iterator        = <nc>unspecified</nc>;
    using const_iterator  = <nc>unspecified</nc>;
    using difference_type = std::ptrdiff_t;
    using size_type       = std::size_t;
    using traits_type     = Tr;

    using reverse_iterator       = std::reverse_iterator&lt;iterator>;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator>;

    static constexpr size_type npos = -1;

    <c>// <n><xref id="basic_stored_value.cons"/>, construct/copy/destroy:</n></c>
    basic_stored_value() noexcept;
    basic_stored_value(Ch* begin, Ch* end);
    basic_stored_value(const basic_stored_value&amp; other) noexcept = default;
    template &lt;class OtherCh>
      basic_stored_value(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;
    basic_stored_value&amp; operator=(const basic_stored_value&amp; other) noexcept = default;
    template &lt;class OtherCh>
      basic_stored_value&amp; operator=(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;

    <c>// <n><xref id="basic_stored_value.iterators"/>, iterators:</n></c>
    iterator       begin()        noexcept;
    const_iterator begin()  const noexcept;
    const_iterator cbegin() const noexcept;

    iterator       end()        noexcept;
    const_iterator end()  const noexcept;
    const_iterator cend() const noexcept;

    reverse_iterator       rbegin()        noexcept;
    const_reverse_iterator rbegin()  const noexcept;
    const_reverse_iterator crbegin() const noexcept;

    reverse_iterator       rend()        noexcept;
    const_reverse_iterator rend()  const noexcept;
    const_reverse_iterator crend() const noexcept;

    <c>// <n><xref id="basic_stored_value.capacity"/>, capacity:</n></c>
    size_type size()   const noexcept;
    size_type length() const noexcept;
    size_type max_size() const noexcept;
    void clear() noexcept;
    bool empty() const noexcept;

    <c>// <n><xref id="basic_stored_value.access"/>, element access:</n></c>
    reference       operator[](size_type pos);
    const_reference operator[](size_type pos) const;
    reference       at(size_type pos);
    const_reference at(size_type pos) const;

    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back()  const;

    pointer       c_str()       noexcept;
    const_pointer c_str() const noexcept;
    pointer       data()        noexcept;
    const_pointer data()  const noexcept;

    template &lt;class OtherTr = std::char_traits&lt;std::remove_const_t&lt;Ch>>>
      operator std::basic_string_view&lt;std::remove_const_t&lt;Ch>, OtherTr>() const noexcept;
    template &lt;class OtherTr = std::char_traits&lt;std::remove_const_t&lt;Ch>>,
              class Allocator = std::allocator&lt;std::remove_const_t&lt;Ch>>>
      explicit operator std::basic_string&lt;std::remove_const_t&lt;Ch>, OtherTr, Allocator>() const;

    <c>// <n><xref id="basic_stored_value.modifiers"/>, modifiers:</n></c>
    iterator erase(const_iterator first, const_iterator last);
    iterator erase(const_iterator position);
    basic_stored_value&amp; erase(size_type pos = 0, size_type n = npos);

    void pop_front();
    void pop_back();

  private:
    Ch* b;    <c>// <n>exposition only</n></c>
    Ch* e;    <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="basic_stored_value.comparison"/>, comparison functions:</n></c>
  template &lt;class ChL, class ChR, class Tr>
    bool operator==(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator==(const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator==(const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator!=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator!=(const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt; (const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt; (const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator> (const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator> (const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator> (const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt;=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt;=(const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator>=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator>=(const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);

  <c>// <n><xref id="basic_stored_value.inserter"/>, inserters:</n></c>
  template &lt;class ChC, class Tr>
    std::basic_ostream&lt;std::remove_const_t&lt;ChC>, Tr>&amp; operator&lt;&lt;(
      std::basic_ostream&lt;ChC, Tr>&amp; os, const basic_stored_value&lt;ChC, Tr>&amp; o);

  <c>// <n><xref id="basic_stored_value.conversion"/>, conversion:</n></c>
  template &lt;class Ch, class Tr>
    std::basic_string_view&lt;std::remove_const_t&lt;Ch>, std::char_traits&lt;std::remove_const_t&lt;Ch>>>
      to_string_view(basic_stored_value&lt;Ch, Tr>&amp; o) noexcept;

  template &lt;class Ch, class Tr, class Allocator = std::allocator&lt;std::remove_const_t&lt;Ch>>>
    std::basic_string&lt;std::remove_const_t&lt;Ch>, std::char_traits&lt;std::remove_const_t&lt;Ch>>, Allocator>
      to_string(basic_stored_value&lt;Ch, Tr>&amp; o, const Allocator&amp; alloc = Allocator());
}
      </codeblock>

      <p>The class template <c>basic_stored_value</c> describes an object that references the text value of a text field in a text table (<xref id="definitions.text_table"/>) represented by an object of an instance of <c>basic_stored_table</c> (<xref id="basic_stored_table"/>).</p>
      <p><c>Ch</c> shall be a possibly const-qualified char-like type. <c>Tr</c> shall be a character traits type for <c>std::remove_const_t&lt;Ch></c>.</p>
      <p>The text value is represented by the range [<c>b</c>, <c>e</c>). <c>*e</c> is always equal to <c>0</c>.
         Programs can read from the range [<c>b</c>, <c>e</c>], and write to the range [<c>b</c>, <c>e</c>) if <c>Ch</c> is not const-qualified.
         To modify the size (that is, <c>e - b</c>), programs can use the store-accessing facilities (<xref id="basic_stored_table.rewrite"/>) of the <c>basic_stored_table</c> object concerned.</p>
      <p>An instance of <c>basic_stored_value</c> is a trivially copyable type and meets the <c>ArithmeticConvertible</c> requirements (<xref id="arithmetic_convertible.requirements"/>) for <c>value_type</c>.</p>
      <p>On the types <c>basic_stored_value&lt;Ch, Tr>::iterator</c> and <c>basic_stored_value&lt;Ch, Tr>::const_iterator</c>, it shall be satisfied that:</p>
      <ul>
        <li>they shall meet the requirements of a random access iterator and a contiguous iterator,</li>
        <li><c>basic_stored_value&lt;Ch, Tr>::iterator</c> shall be convertible to <c>basic_stored_value&lt;Ch, Tr>::const_iterator</c>, and</li>
        <li>each instance of <c>std::iterator_traits</c> on them shall have a set of member typedefs indicated in <xref id="table.basic_stored_value.iterator.typedefs"/>.</li>
      </ul>

      <table id="table.basic_stored_value.iterator.typedefs">
        <caption>Member typedefs of each instance of <c>std::iterator_traits&lt;T></c> where <c>T</c> is either of <c>iterator</c> or <c>const_iterator</c> of <c>basic_stored_value&lt;Ch, Tr></c></caption>
        <col width="3"/><col width="5"/><col width="5"/>

        <tr>
          <th>Member typedef</th>
          <th><c>T</c> is <c>iterator</c></th>
          <th><c>T</c> is <c>const_iterator</c></th>
        </tr>

        <tr>
          <td><c>difference_type</c></td>
          <td colspan="2"><c>std::ptrdiff_t</c></td>
        </tr>

        <tr>
          <td><c>value_type</c></td>
          <td colspan="2"><c>std::remove_const_t&lt;Ch></c></td>
        </tr>

        <tr>
          <td><c>pointer</c></td>
          <td><c>Ch*</c></td>
          <td><c>const Ch*</c></td>
        </tr>

        <tr>
          <td><c>reference</c></td>
          <td><c>Ch&amp;</c></td>
          <td><c>const Ch&amp;</c></td>
        </tr>

        <tr>
          <td><c>iterator_category</c></td>
          <td colspan="2"><c>std::random_access_iterator_tag</c> or its derived type</td>
        </tr>
      </table>

      <section id="basic_stored_value.cons">
        <name><c>basic_stored_value</c> constructors and assignment operators</name>

        <code-item>
          <code>
basic_stored_value() noexcept;
          </code>
          <effects>Constructs an empty object of <c>basic_stored_value</c>.</effects>
          <postcondition><c>b == e</c> and <c>*e</c> is equal to <c>0</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_value(Ch* begin, Ch* end);
          </code>
          <requires>[<c>begin</c>, <c>end</c>] shall be a valid range. <c>*end</c> shall be equal to <c>0</c>.</requires>
          <throws>Nothing.</throws>
          <effects>Initializes <c>b</c> with <c>begin</c> and <c>e</c> with <c>end</c>.</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherCh>
  basic_stored_value(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;
          </code>
          <effects>Initializes <c>b</c> with <c>other.begin()</c> and <c>e</c> with <c>other.end()</c>.</effects>
          <remark>This overload shall not participate in overload resolution unless <c>Ch</c> and <c>const OtherCh</c> are the same type.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherCh>
  basic_stored_value&amp; operator=(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;
          </code>
          <effects>Assigns <c>b</c> from <c>other.begin()</c> and <c>e</c> from <c>other.end()</c>.</effects>
          <remark>This overload shall not participate in overload resolution unless <c>Ch</c> and <c>const OtherCh</c> are the same type.</remark>
        </code-item>
      </section>

      <section id="basic_stored_value.iterators">
        <name><c>basic_stored_value</c> iterator support</name>

        <code-item>
          <code>
iterator       begin()        noexcept;
const_iterator begin()  const noexcept;
const_iterator cbegin() const noexcept;
          </code>
          <returns><c>b</c>.</returns>
        </code-item>

        <code-item>
          <code>
iterator       end()        noexcept;
const_iterator end()  const noexcept;
const_iterator cend() const noexcept;
          </code>
          <returns><c>e</c>.</returns>
        </code-item>

        <code-item>
          <code>
reverse_iterator       rbegin()        noexcept;
const_reverse_iterator rbegin()  const noexcept;
const_reverse_iterator crbegin() const noexcept;
          </code>
          <returns><c>reverse_iterator(end())</c>.</returns>
        </code-item>

        <code-item>
          <code>
reverse_iterator       rend()        noexcept;
const_reverse_iterator rend()  const noexcept;
const_reverse_iterator crend() const noexcept;
          </code>
          <returns><c>reverse_iterator(begin())</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.capacity">
        <name><c>basic_stored_value</c> capacity</name>

        <code-item>
          <code>
size_type size()   const noexcept;
size_type length() const noexcept;
          </code>
          <returns><c>end() - begin()</c>.</returns>
        </code-item>

        <code-item>
          <code>
size_type max_size() const noexcept;
          </code>
          <returns>The largest possible number that the member function <c>size</c> returns.</returns>
        </code-item>

        <code-item>
          <code>
void clear() noexcept;
          </code>
          <effects><c>erase(begin(), end())</c>.</effects>
        </code-item>

        <code-item>
          <code>
bool empty() const noexcept;
          </code>
          <returns><c>size() == 0</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.access">
        <name><c>basic_stored_value</c> element access</name>

        <code-item>
          <code>
reference       operator[](size_type pos);
const_reference operator[](size_type pos) const;
          </code>
          <requires><c>pos &lt;= size()</c>.</requires>
          <throws>Nothing.</throws>
          <returns><c>begin()[pos]</c>.</returns>
          <remark>if <c>pos == size()</c>, the returned reference is read-only.</remark>
        </code-item>

        <code-item>
          <code>
reference       at(size_type pos);
const_reference at(size_type pos) const;
          </code>
          <throws><c>std::out_of_range</c> if <c>pos >= size()</c>.</throws>
          <returns><c>(*this)[pos]</c>.</returns>
        </code-item>

        <code-item>
          <code>
reference       front();
const_reference front() const;
          </code>
          <requires><c>!empty()</c>.</requires>
          <throws>Nothing.</throws>
          <returns><c>(*this)[0]</c>.</returns>
        </code-item>

        <code-item>
          <code>
reference       back();
const_reference back() const;
          </code>
          <requires><c>!empty()</c>.</requires>
          <throws>Nothing.</throws>
          <returns><c>(*this)[size() - 1]</c>.</returns>
        </code-item>

        <code-item>
          <code>
pointer       c_str()       noexcept;
const_pointer c_str() const noexcept;
pointer       data()        noexcept;
const_pointer data()  const noexcept;
          </code>
          <returns><c>b</c>.</returns>
          <remark>The range [<c>r</c>, <c>r + size()</c>] is readable and the range [<c>r</c>, <c>r + size()</c>) is writable where <c>r</c> is the returned value.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherTr = std::char_traits&lt;std::remove_const_t&lt;Ch>>>
  operator std::basic_string_view&lt;std::remove_const_t&lt;Ch>, OtherTr>() const noexcept;
          </code>
          <returns><c>std::basic_string_view&lt;std::remove_const_t&lt;Ch>, OtherTr>(data(), size())</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherTr = std::char_traits&lt;std::remove_const_t&lt;Ch>>,
          class Allocator = std::allocator&lt;std::remove_const_t&lt;Ch>>>
  explicit operator std::basic_string&lt;std::remove_const_t&lt;Ch>, OtherTr, Allocator>() const;
          </code>
          <returns><c>std::basic_string&lt;std::remove_const_t&lt;Ch>, OtherTr, Allocator>(cbegin(), cend())</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.modifiers">
        <name><c>basic_stored_value</c> modifiers</name>

        <code-item>
          <code>
iterator erase(const_iterator first, const_iterator last);
          </code>
          <requires><c>first</c> shall point an element in [<c>cbegin()</c>, <c>cend()</c>].
                    <c>last</c> shall point an element in [<c>first</c>, <c>cend()</c>].</requires>
          <throws>Nothing.</throws>
          <postcondition>Suppose that <c>prefix</c> is the string of [<c>cbegin()</c>, <c>first</c>) and <c>postfix</c> is of [<c>last</c>, <c>cend()</c>) before the call.
                         Then the string of [<c>b</c>, <c>e</c>) shall be equal to <c>prefix</c> and <c>postfix</c> concatenated.
                         <c>*e</c> shall be <c>0</c>.</postcondition>
          <returns><c>begin() + off</c> where <c>off</c> is the value of <c>first - cbegin()</c> before the call.</returns>
          <remark>Calling this function invalidates all references, pointers, and iterators to the objects in the before-call range [<c>begin()</c>, <c>end()</c>].</remark>
        </code-item>

        <code-item>
          <code>
iterator erase(const_iterator position);
          </code>
          <effects>Equivalent to: <c>return erase(position, position + 1);</c></effects>
        </code-item>

        <code-item>
          <code>
basic_stored_value&amp; erase(size_type pos = 0, size_type n = npos);
          </code>
          <throws><c>std::out_of_range</c> if <c>pos > size()</c>.</throws>
          <effects>Call <c>erase(cbegin() + pos, cbegin() + pos + xlen)</c> where <c>xlen</c> is the smaller of <c>n</c> and <c>size() - pos</c>.</effects>
          <returns><c>*this</c>.</returns>
        </code-item>

        <code-item>
          <code>
void pop_front();
          </code>
          <effects>Equivalent to: <c>erase(cbegin());</c></effects>
        </code-item>

        <code-item>
          <code>
void pop_back();
          </code>
          <effects>Equivalent to: <c>erase(cend() - 1);</c></effects>
        </code-item>
      </section>

      <section id="basic_stored_value.comparison">
        <name><c>basic_stored_value</c> comparison functions</name>

        <p>Function templates described in this subclause that take template parameters <c>ChL</c> and <c>ChR</c> shall not participate in overload resolution unless <c>std::remove_const_t&lt;ChL></c> and <c>std::remove_const_t&lt;ChR></c> are the same type.</p>
        <p>Function templates described in this subclause that take template parameters <c>ChC</c> and <c>Other</c> shall not participate in overload resolution unless <c>std::is_convertible_v&lt;Other, std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr></c> is not <c>false</c>.</p>

        <section id="basic_stored_value.opeq">
          <name><c>operator==</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator==(const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
            </code>
            <returns><c>std::basic_string_view&lt;std::remove_const_t&lt;ChL>, Tr>(l) == std::basic_string_view&lt;std::remove_const_t&lt;ChR>, Tr>(r)</c>.</returns>
          </code-item>

          <code-item>
            <code>
template &lt;class ChC, class Tr, class Other>
  bool operator==(const basic_stored_value&lt;ChC, Tr>&amp; v,
                  const Other&amp;                       o) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator==(const Other&amp;                       o,
                  const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(v) == std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o)</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> are <c>true</c> unless the expression <c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o)</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.opne">
          <name><c>operator!=</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator!=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
template &lt;class ChC, class Tr, class Other>
  bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                  const Other&amp;                       r) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator!=(const Other&amp;                       l,
                  const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>!(l == r)</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> unless the expression <c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o)</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.oplt">
          <name><c>operator&lt;</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator&lt; (const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
            </code>
            <returns><c>std::basic_string_view&lt;std::remove_const_t&lt;ChL>, Tr>(l) &lt; std::basic_string_view&lt;std::remove_const_t&lt;ChR>, Tr>(r)</c>.</returns>
          </code-item>

          <code-item>
            <code>
template &lt;class ChC, class Tr, class Other>
  bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp; v,
                  const Other&amp;                       o) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(v) &lt; std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o)</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is <c>true</c> unless the expression <c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o)</c> is potentially-throwing.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class ChC, class Tr, class Other>
  bool operator&lt; (const Other&amp;                       o,
                  const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o) &lt; std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(v)</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is <c>true</c> unless the expression <c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o)</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.opgt">
          <name><c>operator></c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator> (const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
template &lt;class ChC, class Tr, class Other>
  bool operator> (const basic_stored_value&lt;ChC, Tr>&amp; l,
                  const Other&amp;                       r) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator> (const Other&amp;                       l,
                  const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>r &lt; l</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> unless the expression <c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o)</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.ople">
          <name><c>operator&lt;=</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator&lt;=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
template &lt;class ChC, class Tr, class Other>
  bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                  const Other&amp;                       r) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator&lt;=(const Other&amp;                       l,
                  const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>!(r &lt; l)</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> unless the expression <c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o)</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.opge">
          <name><c>operator>=</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator>=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
template &lt;class ChC, class Tr, class Other>
  bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                  const Other&amp;                       r) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator>=(const Other&amp;                       l,
                  const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>!(l &lt; r)</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> unless the expression <c>std::basic_string_view&lt;std::remove_const_t&lt;ChC>, Tr>(o)</c> is potentially-throwing.</remark>
          </code-item>
        </section>
      </section>

      <section id="basic_stored_value.inserter">
        <name><c>basic_stored_value</c> inserters</name>

        <code-item>
          <code>
template &lt;class ChC, class Tr>
  std::basic_ostream&lt;std::remove_const_t&lt;ChC>, Tr>&amp; operator&lt;&lt;(
    std::basic_ostream&lt;ChC, Tr>&amp; os, const basic_stored_value&lt;ChC, Tr>&amp; o);
          </code>
          <effects>Equivalent to: <c>return os &lt;&lt; to_string_view(o);</c></effects>
        </code-item>
      </section>

      <section id="basic_stored_value.conversion">
        <name><c>basic_stored_value</c> conversion</name>

        <code-item>
          <code>
template &lt;class Ch, class Tr>
  std::basic_string_view&lt;std::remove_const_t&lt;Ch>, std::char_traits&lt;std::remove_const_t&lt;Ch>>>
    to_string_view(basic_stored_value&lt;Ch, Tr>&amp; o) noexcept;
          </code>
          <returns><c>std::basic_string_view&lt;std::remove_const_t&lt;Ch>, Tr>(o.data(), o.size())</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class Ch, class Tr, class Allocator = std::allocator&lt;std::remove_const_t&lt;Ch>>>
  std::basic_string&lt;std::remove_const_t&lt;Ch>, std::char_traits&lt;std::remove_const_t&lt;Ch>>, Allocator>
    to_string(basic_stored_value&lt;Ch, Tr>&amp; o, const Allocator&amp; alloc = Allocator());
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return std::basic_string&lt;std::remove_const_t&lt;Ch>,
                         std::char_traits&lt;std::remove_const_t&lt;Ch>>,
                         Allocator>(o.cbegin(), o.cend(), alloc);</code>
          </effects>
        </code-item>
      </section>

      <section id="basic_stored_value.hash">
        <name><c>basic_stored_value</c> hash support</name>

        <codeblock>
namespace std {
  template &lt;class Ch, class Tr> struct hash&lt;commata::basic_stored_value&lt;Ch, Tr>>;
}
        </codeblock>
        <p>This template specialization is enabled.</p>
      </section>
    </section>

    <section id="basic_stored_table">
      <name>Class template <c>basic_stored_table</c></name>

      <section id="basic_stored_table.overview">
        <name>Class template <c>basic_stored_table</c> overview</name>

        <codeblock>
namespace commata {
  template &lt;class Content, class Allocator = std::allocator&lt;Content>>
    class basic_stored_table {
  public:
    using allocator_type  = Allocator;
    using content_type    = Content;
    using record_type     = typename content_type::value_type;
    using value_type      = typename record_type::value_type;
    using char_type       = typename value_type::value_type;
    using traits_type     = typename value_type::traits_type;
    using size_type       = typename content_type::size_type;

    <c>// <n><xref id="basic_stored_table.cons"/>, construct/copy/destroy:</n></c>
    explicit basic_stored_table(std::size_t buffer_size = 0) :
      basic_stored_table(std::allocator_arg, Allocator(), buffer_size) {}
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc, std::size_t buffer_size = 0U);
    basic_stored_table(const basic_stored_table&amp;  other);
    basic_stored_table(      basic_stored_table&amp;&amp; other) noexcept;
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                       const basic_stored_table&amp;  other);
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                             basic_stored_table&amp;&amp; other)
      noexcept(std::allocator_traits&lt;Allocator>::is_always_equal::value);
   ~basic_stored_table();
    basic_stored_table&amp; operator=(const basic_stored_table&amp;  other);
    basic_stored_table&amp; operator=(      basic_stored_table&amp;&amp; other)
      noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_move_assignment::value
            || std::allocator_traits&lt;Allocator>::is_always_equal::value);

    <c>// <n><xref id="basic_stored_table.constituents"/>, access to the constituents:</n></c>
    allocator_type get_allocator() const noexcept;
    std::size_t get_buffer_size() const noexcept;
    content_type&amp;       content();
    const content_type&amp; content() const;
    record_type&amp;       operator[](size_type record_index);
    const record_type&amp; operator[](size_type record_index) const;
    size_type size() const noexcept(<nc>see below</nc>);
    [[nodiscard]] bool empty() const noexcept(<nc>see below</nc>);
    void clear() noexcept(<nc>see below</nc>);

    <c>// <n><xref id="basic_stored_table.capacity"/>, capacity:</n></c>
    void shrink_to_fit();

    <c>// <n><xref id="basic_stored_table.rewrite"/>, store operations:</n></c>
    value_type&amp; resize_value(value_type&amp; value, typename value_type::size_type n);
    value_type make_value(typename value_type::size_type n);
    template &lt;class ForwardIterator, class ForwardIteratorEnd>
      value_type&amp; rewrite_value(value_type&amp; value,
                                InputIterator new_value_begin, InputIteratorEnd new_value_end);
    template &lt;class ForwardIterator>
      value_type&amp; rewrite_value(value_type&amp; value, InputIterator new_value);
    template &lt;class OtherValue>
      value_type&amp; rewrite_value(value_type&amp; value, const OtherValue&amp; new_value);
    template &lt;class... Args> value_type import_value(Args&amp;&amp;... args);
    template &lt;class F> auto guard_rewrite(F f) -> decltype(f(*this));

    <c>// <n><xref id="basic_stored_table.primitives"/>, primitive store operations:</n></c>
    [[nodiscard]] std::pair&lt;char_type*, std::size_t> generate_buffer(std::size_t min_size);
    void consume_buffer(char_type* buffer, std::size_t size) const;
    void add_buffer(char_type* buffer, std::size_t size);
    void secure_current_upto(char_type* secured_last);

    <c>// <n><xref id="basic_stored_table.modifiers"/>, modifiers:</n></c>
    template &lt;class OtherContent, class OtherAllocator>
      basic_stored_table&amp; operator+=(
        const basic_stored_table&lt;OtherContent, OtherAllocator>&amp;  other);
    template &lt;class OtherContent, class OtherAllocator>
      basic_stored_table&amp; operator+=(
              basic_stored_table&lt;OtherContent, OtherAllocator>&amp;&amp; other);
    void swap(basic_stored_table&amp; other)
      noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_swap::value
            || std::allocator_traits&lt;Allocator>::is_always_equal::value);
  
  private:
    <c>// <nc>exposition only</nc></c>
    struct null_termination {
      template &lt;class InputIterator> friend bool operator==(InputIterator left, null_termination) {
        return traits_type::eq(*left, char_type());
      }
    };
  };

  <c>// <n><xref id="basic_stored_table.nonmember"/>, non-member functions:</n></c>
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);

  <c>// <n><xref id="basic_stored_table.special"/>, specialized algorithms:</n></c>
  template &lt;class Content, class Allocator>
    void swap(basic_stored_table&lt;Content, Allocator>&amp; left,
              basic_stored_table&lt;Content, Allocator>&amp; right)
      noexcept(noexcept(left.swap(right)));
}
        </codeblock>

        <p>The class template <c>basic_stored_table</c> describes an in-memory image of a text table (<xref id="definitions.text_table"/>), whose text values are arranged two-dimensionally.</p>

        <p>The template parameter <c>Content</c> shall be a sequence container type of a sequence container type of <c>basic_stored_value&lt;Ch, Tr></c> (<xref id="basic_stored_value"/>) for some <c>Ch</c> and <c>Tr</c>
           and shall meet the <c>DefaultInsertable</c> requirements and the <c>Erasable</c> requirements with <c>Allocator</c>.
           Note that neither <c>std::array</c> nor <c>std::forward_list</c> qualifies because they lack some essential functionalities of sequence containers.</p>
        <p>The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements for <c>Content</c>.</p>

        <section id="basic_stored_table.parts">
          <name><c>basic_stored_table</c> constituents</name>

          <p>Let <c>Ch</c> be a type denoted with <c>Content::value_type::value_type::value_type</c>.</p>
          <p>An object of <c>basic_stored_table&lt;Content, Allocator></c> consists of the four following constituents:</p>
          <ul>
            <li>a <n>content container</n>, which is an allocator-aware container of <c>Content</c> with its size being at most one (and its possible sole element is called the <n>content</n>),</li>
            <li>a <n>store</n>, which is a bundle of <n>buffers</n> and a <n>bookkeeper object</n>; each one of the the buffers is an array of <c>Ch</c> and contains memory referenced by the text values in the content and the bookkeeper object memorizes all the ranges of memory possibly reserved for the text values,</li>
            <li>an allocator, whose type is <c>Allocator</c>, which is used to allocate and construct the content, and whose rebound coplies for <c>Ch</c> are used to allocate memories required by the store, and</li>
            <li>a <n>buffer size</n>, whose type is <c>std::size_t</c> and that is used as the least amount of <c>Ch</c> in one memory allocation.</li>
          </ul>
          <p>The store of an object of <c>basic_stored_table</c> marks one buffer in it as its <n>current buffer</n> when it is not empty; that is, when it has at least one buffer.</p>
        </section>

        <section id="basic_stored_table.defs">
          <name>Definitions</name>

          <p>The <n>value type</n> of an object of an instance of <c>basic_stored_table&lt;Content, Allocator></c> denotes <c>typename Content::value_type::value_type</c>, which is an instance of <c>basic_stored_value</c>.</p>

          <p>The <n>char type</n> of an object of an instance of <c>basic_stored_table&lt;Content, Allocator></c> denotes <c>std::remove_const_t&lt;typename V::value_type></c> where <c>V</c> is the value type, which is a char-like type.</p>

          <p><n>Contained values</n> of an object <c>t</c> of an instance <c>T</c> of <c>basic_stored_table</c> denotes the objects of the value type in the content of <c>t</c>.</p>

          <p>An object <c>v</c> of a value type is called <n>backed by</n> an object <c>t</c> of an instance of <c>basic_stored_table</c> if:</p>
          <ul>
            <li><c>v.empty()</c> is not <c>false</c>, or</li>
            <li>the range [<c>v.cbegin()</c>, <c>v.cend()</c>] resides in a buffer in the store of <c>t</c>, and <c>*v.cend()</c> is equal to a value-initialized char type value.</li>
          </ul>
          <p>An object of an instance of <c>basic_stored_table</c> is called <n>complete</n> if none of its contained values is not backed by it.</p>

          <p>Two objects <c>v</c> and <c>w</c> of value types, which are hereinafter referred to as <c>V</c> and <c>W</c> respectively, are called <n>overlapping</n> if:</p>
          <ul>
            <li>at least one of <c>V::value_type</c> or <c>W::value_type</c> is not const-qualified,</li>
            <li>both of <c>v.empty()</c> and <c>w.empty()</c> are <c>false</c>, and</li>
            <li>two ranges [<c>v.cbegin()</c>, <c>v.cend()</c>], [<c>w.cbegin()</c>, <c>w.cend()</c>] have at least one common element.</li>
          </ul>
        </section>

        <section id="basic_stored_table.conds">
          <name>General requirements and postconditions</name>

          <p>All member functions of <c>basic_stored_table</c> and all instances of non-member function templates declared in this header (<xref id="hpp.stored_table.syn"/>) that take at least one parameter whose reference-removed and cv-unqualified type is an instance of <c>basic_stored_table</c> require that the following conditions meet:</p>
          <ul>
             <li>all participating <c>basic_stored_table</c> objects are complete, and</li>
             <li>no two of the contained values of the participating <c>basic_stored_table</c> objects overlap.</li>
          </ul>
          <p>And they shall meet the following postconditions:</p>
          <ul>
             <li>all participating <c>basic_stored_table</c> objects are be complete,</li>
             <li>no two of the contained values of the participating <c>basic_stored_table</c> objects overlap, and</li>
             <li>the states of the participating <c>basic_stored_table</c> objects are not changed if the call exits via an exception except when they are referenced by rvalue references passed as parameters to them.</li>
          </ul>

          <p>All non-const member functions of <c>basic_stored_table</c> and all instances of non-member function templates declared in this header (<xref id="hpp.stored_table.syn"/>) that take at least one parameter whose type is a reference to a non-const <c>basic_stored_table&lt;Ch, Tr></c> for some <c>Ch</c> and <c>Tr</c> may change the current buffer marks of the participating non-const <c>basic_stored_table</c> objects.</p>
        </section>
      </section>

      <section id="basic_stored_table.cons">
        <name><c>basic_stored_table</c> construct/copy/destroy</name>

        <p>In this subclause, <c>AT</c> denotes <c>std::allocator_traits&lt;Allocator></c>, <c>CAT</c> denotes <c>typename AT::template rebind_traits&lt;Ch></c> and <c>CA</c> denotes <c>typename CAT::allocator_type</c>.</p>
        <p>All constructors and assignment operators shall make an appropriate decision about propagation of the allocator in accordance with <c>AT::select_on_container_copy_construnction</c>, <c>AT::propagete_on_container_copy_assignment</c> and <c>AT::propagete_on_container_move_assignment</c>.</p>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc, std::size_t buffer_size = 0U);
          </code>
          <effects>Copy constructs the allocator from <c>alloc</c>.
                   If <c>buffer_size</c> is greater than <c>0</c>, initializes the buffer size to a value that is the smaller of <c>CAT::max_size(CA(a))</c> and <c>buffer_size</c> where <c>a</c> is an lvalue to the allocator.
                   Otherwise, initializes it to an unspecified value.
                   Initializes the content container to have an element as default inserted into it.</effects>
        </code-item>

        <code-item>
          <code>
basic_stored_table(const basic_stored_table&amp; other);
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(get_allocator()))</c> and <c>other.get_buffer_size()</c>.
                         If not undefined, also <c>content() == other.content()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table(basic_stored_table&amp;&amp; other) noexcept;
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(get_allocator()))</c> and the value of <c>other.get_buffer_size()</c> before this construction.
                         If not undefined, <c>content()</c> shall be equal to the value that <c>other.content()</c> had before this construction.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                   const basic_stored_table&amp; other);
          </code>
          <postcondition><c>get_allocator() == alloc</c> shall be <c>true</c> and <c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(alloc))</c> and <c>other.get_buffer_size()</c>.
                         If not undefined, <c>content() == other.content()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                   basic_stored_table&amp;&amp; other)
  noexcept(std::allocator_traits&lt;Allocator>::is_always_equal::value);
          </code>
          <postcondition><c>get_allocator() == alloc</c> shall be <c>true</c> and <c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(alloc))</c> and <c>other.get_buffer_size()</c>.
                         If not undefined, <c>content()</c> shall be equal to the value that <c>other.content()</c> had before this construction.</postcondition>
          <throws>Nothing if <c>other.get_allocator() == alloc</c> is not <c>false</c>.</throws>
          <remark>The states of <c>other</c> shall not be changed if the call exits via an exception.</remark>
        </code-item>

        <code-item>
          <code>
~basic_stored_table();
          </code>
          <effects>Destroys the content container, deallocates all buffers in the store, and destroys the allocator.</effects>
        </code-item>

        <code-item>
          <code>
basic_stored_table&amp; operator=(const basic_stored_table&amp; other);
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(get_allocator()))</c> and <c>other.get_buffer_size()</c>.
                         If not undefined, <c>content() == other.content()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table&amp; operator=(basic_stored_table&amp;&amp; other)
  noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_move_assignment::value
        || std::allocator_traits&lt;Allocator>::is_always_equal::value);
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(get_allocator()))</c> and the value of <c>other.get_buffer_size()</c> before this assignment.
                         If not undefined, <c>content()</c> shall be equal to the value that <c>other.content()</c> had before this assignment.</postcondition>
          <throws>Nothing unless both of <c>other.get_allocator() == alloc</c> and <c>AT::propagate_on_container_move_assignment</c> are <c>false</c>.</throws>
          <remark>The states of <c>other</c> shall not be changed if the call exits via an exception.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.constituents">
        <name><c>basic_stored_table</c> constituent access</name>

        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>The allocator.</returns>
        </code-item>

        <code-item>
          <code>
std::size_t get_buffer_size() const noexcept;
          </code>
          <returns>The buffer size.</returns>
        </code-item>

        <code-item>
          <code>
content_type&amp;       content();
const content_type&amp; content() const;
          </code>
          <requires>The content container of <c>*this</c> shall not be empty.</requires>
          <returns>A reference to the content, which is the sole element of the content container.</returns>
          <throws>Nothing.</throws>
        </code-item>

        <code-item>
          <code>
record_type&amp;       operator[](size_type record_index);
const record_type&amp; operator[](size_type record_index) const;
          </code>
          <effects>Equivalent to: <c>content()[record_index]</c>.</effects>
        </code-item>

        <code-item>
          <code>
size_type size() const noexcept(<nc>see below</nc>);
          </code>
          <returns><c>0</c> if the content container is empty; <c>content().size()</c> otherwise.</returns>
          <remark>The expression inside <c>noexcept</c> is <c>false</c> if and only if <c>Content::size</c> with no parameters is not marked as <c>noexcept</c>.</remark>
        </code-item>

        <code-item>
          <code>
[[nodiscard]] bool empty() const noexcept(<nc>see below</nc>);
          </code>
          <returns><c>true</c> if the content container is empty; <c>content().empty()</c> otherwise.</returns>
          <remark>The expression inside <c>noexcept</c> is <c>false</c> if and only if <c>Content::empty</c> with no parameters is not marked as <c>noexcept</c>.</remark>
        </code-item>

        <code-item>
          <code>
void clear() noexcept(<nc>see below</nc>);
          </code>
          <effects>Calls <c>content().clear()</c> if and only if the content container of <c>*this</c> is not empty. Then makes the bookkeeper object of the store recognize no memory in the buffers of the store are reserved for any text values.</effects>
          <remark>The expression inside <c>noexcept</c> is <c>false</c> if and only if <c>Content::clear</c> with no parameters is not marked as <c>noexcept</c>.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.capacity">
        <name><c>basic_stored_table</c> capacity</name>
        <code-item>
          <code>
void shrink_to_fit();
          </code>
          <postcondition>The values of <c>content()</c> (if not undefined), <c>get_allocator()</c> and <c>get_buffer_size()</c> shall be equal to the values that those had before this call.</postcondition>
          <remark>This is a non-binding request to reduce memory use.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.rewrite">
        <name><c>basic_stored_table</c> store operations</name>

        <code-item>
          <code>
value_type&amp; resize_value(value_type&amp; value, typename value_type::size_type n);
          </code>
          <requires><c>value</c> shall be backed by <c>*this</c>.</requires>
          <postcondition>Let <c>m</c> be <c>value.size()</c> before the call and <c>rlen</c> be the smaller of <c>m</c> and <c>n</c>.
                         <c>value</c> shall be unchangedly backed by <c>*this</c>.
                         <c>value.size()</c> shall be equal to <c>n</c>.
                         The values in the range [<c>value.data()</c>, <c>value.data() + rlen</c>) shall be the same as before the call.
                         For each <c>i</c> in the range [<c>m</c>, <c>n</c>], <c>v[i]</c> shall be equal to <c>char_type()</c>.</postcondition>
          <returns><c>value</c>.</returns>
        </code-item>

        <code-item>
          <code>
value_type make_value(typename value_type::size_type n);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>value_type value;
resize_value(value, n);
return value;</code>
          </effects>
        </code-item>

        <code-item>
          <code>
template &lt;class InputIterator, class InputIteratorEnd>
  value_type&amp; rewrite_value(value_type&amp; value,
                            InputIterator new_value_begin, InputIteratorEnd new_value_end);
          </code>
          <requires><c>InputIterator</c> shall be a input iterator type whose value type <c>T</c> satisfies that <c>std::is_convertible_v&lt;T, char_type></c> is <c>true</c>.
                    <c>InputIteratorEnd</c> shall meet the <c>IteratorEnd</c> requirements for <c>InputIterator</c> (<xref id="iterator_end.requirements"/>).
                    <c>value</c> shall be backed by <c>*this</c>.</requires>
          <postcondition><c>value</c> shall be unchangedly backed by <c>*this</c>.
                         <c>value</c> shall be equal to the range [<c>new_value_begin</c>, <c>new_value_end</c>) (<xref id="form_accessible_range"/>) before the call in terms of <c>traits_type::eq</c>.</postcondition>
          <returns><c>value</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class InputIterator>
  value_type&amp; rewrite_value(value_type&amp; value, InputIterator new_value);
          </code>
          <effects>Equivalent to: <c>return rewrite_value(value, new_value, null_termination());</c></effects>
          <remark>This overload shall not participate in overload resolution unless <c>InputIterator</c> is an input iterator type.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherValue>
  value_type&amp; rewrite_value(value_type&amp; value, const OtherValue&amp; new_value);
          </code>
          <effects>Equivalent to: <c>return rewrite_value(value, std::begin(new_value), std::end(new_value));</c></effects>
          <remark>This overload shall not participate in overload resolution unless <c>OtherValue</c> meets the <c>AccessibleRange</c> requirements (<xref id="accessible_range.requirements"/>) for <c>char_type</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class... Args> value_type import_value(Args&amp;&amp;... args);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>value_type value;
rewrite_value(value, std::forward&lt;Args>(args)...);
return value;</code>
          </effects>
        </code-item>

        <code-item>
          <code>
template &lt;class F> auto guard_rewrite(F f) -> decltype(f(*this));
          </code>
          <requires><c>std::declval&lt;F&amp;>()(std::declval&lt;basic_stored_table&amp;>())</c> shall be well-formed when treated as an unevaluated operand.
                    Evaluating <c>f(t)</c> shall not change the state of the value of <c>t</c> except that it can call <c>resize_value</c>, <c>make_value</c>, <c>rewrite_value</c>, <c>import_value</c>, <c>generate_buffer</c>, <c>consume_buffer</c>, <c>add_buffer</c> and <c>secure_current_upto</c> on the value of <c>t</c> where <c>t</c> is an lvalue of <c>basic_stored_table</c>.</requires>
          <effects>First makes a copy of the bookkeeper object of the store. Then calls <c>f(*this)</c>.
                   If an exception is thrown by the call of <c>f(*this)</c>, all objects returned by the calls of <c>resize_value</c> and <c>rewrite_value</c>, and therefore also <c>make_value</c> and <c>import_value</c> during the call are invalidated,
                   the current buffer mark and its reservation marks (<xref id="basic_stored_table.primitives"/>) are restored referencing the copied bookkeeper object,
                   and the exception is rethrown.
                   The copied bookkeeper object is destroyed before leaving this function no matter wheter an exception is thrown or not.</effects>
          <returns>The return value of the call above.</returns>
        </code-item>
      </section>

      <section id="basic_stored_table.primitives">
        <name><c>basic_stored_table</c> primitive store operations</name>

        <code-item>
          <code>
[[nodiscard]] std::pair&lt;char_type*, std::size_t> generate_buffer(std::size_t min_size);
          </code>
          <effects>Optionally finds a buffer in the store whose length is not less than <c>min_size</c> and whose absence does not have any effects on the completeness of the table.
                   If a suitable buffer is found, then makes the store release the ownership of it.
                   Otherwise, makes a rebound copy of a return value of <c>get_allocator()</c> to <c>char_type</c> and allocates a buffer for <c>min_size</c> <c>char_type</c> objects with it.</effects>
          <returns>A pair object of a pointer to the first element of a buffer and its length, which is the value passed to the allocator to obtain the memory.</returns>
          <remark>This function does not change the current buffer mark.</remark>
        </code-item>

        <code-item>
          <code>
void consume_buffer(char_type* buffer, std::size_t size);
          </code>
          <requires><c>buffer</c> shall point the first element of a buffer allocated by a rebound copy of a return value of <c>get_allocator()</c> to <c>char_type</c>.
                    <c>size</c> shall match the value passed to the allocator to obtain this memory.
                    The range [<c>buffer</c>, <c>buffer + size</c>) shall not overlap with any buffers in the store of <c>*this</c>.</requires>
          <effects>Makes the store take over the ownership of the buffer whose first element is pointed by <c>buffer</c> and whose length is <c>size</c>.
                   Then optionally makes a rebound copy of <c>get_allocator</c> to <c>char_type</c> and deallocates the buffer with it.</effects>
          <throws>Nothing.</throws>
          <remark>This function does not change the current buffer mark.</remark>
        </code-item>

        <code-item>
          <code>
void add_buffer(char_type* buffer, std::size_t size);
          </code>
          <requires><c>buffer</c> shall point the first element of a buffer allocated by a rebound copy of a return value of <c>get_allocator()</c> to <c>char_type</c>.
                    <c>size</c> shall match the value passed to the allocator to obtain this memory.
                    The range [<c>buffer</c>, <c>buffer + size</c>) shall not overlap with any buffers in the store of <c>*this</c>.</requires>
          <effects>Makes the store take over the ownership of the buffer whose first element is pointed by <c>buffer</c> and whose length is <c>size</c>.
                   Then marks it as the current buffer.</effects>
          <remark>If an exception is thrown, the buffer is deallocated and the current buffer mark is not changed.</remark>
        </code-item>

        <code-item>
          <code>
void secure_current_upto(char_type* secured_last);
          </code>
          <requires><c>secured_last</c> shall point an element in the current buffer or be the past-the-end pointer of the current buffer.</requires>
          <effects>Marks the range [<c>cb</c>, <c>secured_last</c>) as reserved against <c>resize_value</c> and <c>rewrite_value</c>, and therefore also <c>make_value</c> and <c>import_value</c> (<xref id="basic_stored_table.rewrite"/>), where <c>cb</c> is a pointer to the first element of the current buffer.</effects>
          <throws>Nothing.</throws>
          <remark>This function does not change the current buffer mark. The reservation marks can not be revoked except by <c>guard_rewrite</c>.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.modifiers">
        <name><c>basic_stored_table</c> modifiers</name>

        <p>To achieve clarity, in this subclause <c>operator[]</c> are used on an object <c>t</c> of an instance of <c>basic_stored_table</c> that does not necessarily have them well-defined. In these cases, the semaintics of <c>t[n]</c> is the same as that of <c>*std::next(t.content().cbegin(), n)</c>.</p>

        <code-item>
          <code>
template &lt;class OtherContent, class OtherAllocator>
  basic_stored_table&amp; operator+=(
    const basic_stored_table&lt;OtherContent, OtherAllocator>&amp; other);
          </code>
          <requires><p>If the content container of <c>*this</c> is not empty, then:</p>
                    <ul>
                      <li>if an exception is thrown by a call of <c>emplace</c> or <c>insert</c> of <c>this->content()</c> at the end, there shall be no effects on the before-end elements, and</li>
                      <li>any calls of <c>erase</c> of <c>this->content()</c> at the end shall not exit via an exception.</li>
                    </ul></requires>
          <postcondition>Let <c>lsize</c> be the value that <c>size()</c> returned before the call.
                         <c>size() == lsize + other.size()</c> shall be <c>true</c>.
                         For each <c>i</c> in the range [<c>0</c>, <c>lsize</c>), the value of <c>(*this)[i]</c> shall be equal to the value that it had before call.
                         For each <c>i</c> in the range [<c>0</c>, <c>other.size()</c>), <c>(*this)[lsize + i] == record_type(other[i].cbegin(), other[i].cend())</c> shall hold <c>true</c>.</postcondition>
          <remark><p>This overload shall not participate in overload resolution unless:</p>
            <ul>
              <li><c>basic_stored_table&lt;OtherContent, OtherAllocator>::char_type</c> is an identical type to <c>char_type</c> and</li>
              <li><c>basic_stored_table&lt;OtherContent, OtherAllocator>::traits_type</c> is an identical type to <c>traits_type</c>.</li>
            </ul>
          </remark>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherContent, class OtherAllocator>
  basic_stored_table&amp; operator+=(
    basic_stored_table&lt;OtherContent, OtherAllocator>&amp;&amp; other);
          </code>
          <requires><p>If the content container of <c>other</c> is not empty, then any calls of <c>clear</c> of <c>other.content()</c> shall not exit via an exception.
                       If the content container of <c>*this</c> is not empty, then:</p>
                    <ul>
                       <li>if an exception is thrown by a call of <c>emplace</c> or <c>insert</c> of <c>this->content()</c> at the end, there shall be no effects on the before-end elements, and</li>
                       <li>any calls of <c>erase</c> of <c>this->content()</c> at the end shall not exit via an exception.</li>
                    </ul></requires>
          <postcondition>Let <c>lsize</c> be the value that <c>size()</c> returned before the call.
                         <c>size() == lsize + other.size()</c> shall be <c>true</c>.
                         For each <c>i</c> in the range [<c>0</c>, <c>lsize</c>), the value of <c>(*this)[i]</c> shall be equal to the value that it had before call.
                         For each <c>i</c> in the range [<c>0</c>, <c>other.size()</c>), the value of <c>(*this)[lsize + i]</c> shall be equal to the value that <c>record_type(other[i].cbegin(), other[i].cend())</c> had before the call.</postcondition>
          <remark><p>This overload shall not participate in overload resolution unless:</p>
            <ul>
              <li><c>basic_stored_table&lt;OtherContent, OtherAllocator>::char_type</c> is an identical type to <c>char_type</c> and</li>
              <li><c>basic_stored_table&lt;OtherContent, OtherAllocator>::traits_type</c> is an identical type to <c>traits_type</c>.</li>
            </ul>
          </remark>
        </code-item>

        <code-item>
          <code>
void swap(basic_stored_table&amp; other)
  noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_swap::value
        || std::allocator_traits&lt;Allocator>::is_always_equal::value);
          </code>
          <requires>If <c>std::allocator_traits&lt;allocator_type>::propagate_on_container_swap::value</c> is <c>false</c>, <c>get_allocator() == other.get_allocator()</c> shall be <c>true</c>.</requires>
          <effects>Exchanges the contents of <c>*this</c> and <c>other</c>.</effects>
          <remark>The allocators are exchanged if and only if <c>std::allocator_traits&lt;allocator_type>::propagate_on_container_swap::value</c> is not <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.nonmember">
        <name><c>basic_stored_table</c> non-member functions</name>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp; left,
              const basic_stored_table&lt;ContentR, AllocatorR>&amp; right);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>basic_stored_table&lt;ContentL, AllocatorL> t(left);
t += right;
return t;</code>
          </effects>
        </code-item>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                    basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>basic_stored_table&lt;ContentL, AllocatorL> t(left);
t += std::move(right);
return t;</code>
          </effects>
        </code-item>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
              const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return std::move(left += right);</code>
          </effects>
        </code-item>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
              basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return std::move(left += std::move(right));</code>
          </effects>
        </code-item>
      </section>

      <section id="basic_stored_table.special">
        <name><c>basic_stored_table</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Content, class Allocator>
  void swap(basic_stored_table&lt;Content, Allocator>&amp; left,
            basic_stored_table&lt;Content, Allocator>&amp; right)
    noexcept(noexcept(left.swap(right)));
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
        </code-item>
      </section>
    </section>

    <section id="stored_table_builder_option">
      <name>Type <c>stored_table_builder_option</c></name>

      <codeblock>
namespace commata {
  enum class stored_table_builder_option : <nc>see below</nc> {
    none = 0,
    transpose = 1
  };

  <c>// <n><xref id="stored_table_builder_option.ops"/>, operations:</n></c>
  constexpr stored_table_builder_option operator|(
    stored_table_builder_option left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option&amp; operator|=(
    stored_table_builder_option&amp; left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option operator&amp;(
    stored_table_builder_option left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option&amp; operator&amp;=(
    stored_table_builder_option&amp; left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option operator^(
    stored_table_builder_option left, stored_table_builder_option right) noexcept;
  constexpr stored_table_builder_option&amp; operator^=(
    stored_table_builder_option&amp; left, stored_table_builder_option right);
  constexpr stored_table_builder_option operator~(stored_table_builder_option handle) noexcept;
}
      </codeblock>

      <p>The enumarated type <c>stored_table_builder_option</c> defines several integral values with single one bit and with all one bit, which is used to configure the <c>stored_table_builder</c> objects (<xref id="stored_table_builder"/>).
         Its underlying type is an unspecified unsigned integer type.</p>

      <section id="stored_table_builder_option.ops">
        <name><c>stored_table_builder_option</c> operations</name>
        <p>In this subclause, <c>U</c> denotes <c>std::underlying_type_t&lt;stored_table_builder_option></c>.</p>
        <code-item>
          <code>
constexpr stored_table_builder_option operator|(
  stored_table_builder_option left, stored_table_builder_option right) noexcept;
          </code>
          <effects>Equivalent to: <c>return stored_table_builder_option(static_cast&lt;U>(left) | static_cast&lt;U>(right));</c></effects>
        </code-item>
        <code-item>
          <code>
constexpr stored_table_builder_option&amp; operator|=(
  stored_table_builder_option&amp; left, stored_table_builder_option right) noexcept;
          </code>
          <effects>Equivalent to: <c>return left = left | right;</c></effects>
        </code-item>
        <code-item>
          <code>
constexpr stored_table_builder_option operator&amp;(
  stored_table_builder_option left, stored_table_builder_option right) noexcept;
          </code>
          <effects>Equivalent to: <c>return stored_table_builder_option(static_cast&lt;U>(left) &amp; static_cast&lt;U>(right));</c></effects>
        </code-item>
        <code-item>
          <code>
constexpr stored_table_builder_option&amp; operator&amp;=(
  stored_table_builder_option&amp; left, stored_table_builder_option right) noexcept;
          </code>
          <effects>Equivalent to: <c>return left = left &amp; right;</c></effects>
        </code-item>
        <code-item>
          <code>
constexpr stored_table_builder_option operator^(
  stored_table_builder_option left, stored_table_builder_option right) noexcept;
          </code>
          <effects>Equivalent to: <c>return stored_table_builder_option(static_cast&lt;U>(left) ^ static_cast&lt;U>(right));</c></effects>
        </code-item>
        <code-item>
          <code>
constexpr stored_table_builder_option&amp; operator^=(
  stored_table_builder_option&amp; left, stored_table_builder_option right) noexcept;
          </code>
          <effects>Equivalent to: <c>return left = left ^ right;</c></effects>
        </code-item>
        <code-item>
          <code>
constexpr stored_table_builder_option operator~(stored_table_builder_option handle) noexcept;
          </code>
          <effects>Equivalent to: <c>return stored_table_builder_option(~static_cast&lt;U>(handle));</c></effects>
        </code-item>
      </section>
    </section>

    <section id="stored_table_builder">
      <name>Class template <c>stored_table_builder</c></name>

      <codeblock>
namespace commata {
  template &lt;class Content, class Allocator,
            stored_table_builder_option Options = stored_table_builder_option::none>
    class stored_table_builder {
  public:
    using table_type = basic_stored_table&lt;Content, Allocator>;
    using char_type = typename table_type::char_type;

    <c>// <n><xref id="stored_table_builder.cons"/>, construct/copy/destroy:</n></c>
    explicit stored_table_builder(table_type&amp; table, std::size_t max_record_num = 0);
    template &lt;class F> stored_table_builder(table_type&amp; table, F&amp;&amp; f);
    stored_table_builder(stored_table_builder&amp;&amp; other) noexcept;
   ~stored_table_builder();

    <c>// <n>six member functions below are declared and defined to meet the TableHandler</n>
    // <n>requirements (<xref id="table_handler.requirements"/>):</n></c>
    [[nodiscard]] std::pair&lt;char_type*, std::size_t> get_buffer();
    void release_buffer(char_type* buffer) noexcept;
    void start_record(char_type* record_begin);
    bool end_record(char_type* record_end);
    void update(char_type* first, char_type* last);
    void finalize(char_type* first, char_type* last);
  };

  <c>// <n><xref id="stored_table_builder.creation"/>, creation functions:</n></c>
  template &lt;stored_table_builder_option Options = stored_table_builder_option::none,
            class Content, class Allocator, class... Args>
    stored_table_builder&lt;Content, Allocator, Options> make_stored_table_builder(
      basic_stored_table&lt;Content, Allocator>&amp; table, Args&amp;&amp;... args);
}
      </codeblock>

      <p>The class template <c>stored_table_builder</c> is a tool to create an image of a text table (<xref id="definitions.text_table"/>) into a <c>basic_stored_table</c> (<xref id="basic_stored_table"/>) object, which is called the <n>targeted object</n>.
         An instantiation of it satisfies the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for its <c>char_type</c>.
         An object of an instantiation of it can not be reused; that is, it can receive the parsing events that the parser emits only once.</p>

      <p>The template parameters <c>Content</c> and <c>Allocator</c> shall be types that make <c>basic_stored_table&lt;Content, Allocator></c> a valid type.</p>

      <p>The template parameter <c>Options</c> is a bitmask to control the behaviour of the builder.
         Its effects are described in <xref id="table.stored_table_builder.options"/>.
         In it, <c>c</c> denotes an lvalue reference to <c>content()</c> of the targeted object and <c>s</c> does the value that <c>c.size()</c> had before the parsing.
         Indices <c>i</c> and <c>j</c> are zero-based.
         In addition, <c>operator[]</c> and <c>operator+</c> are used on types that do not necessarily have them well-defined.
         In these cases, the semantics of <c>d[n]</c> and <c>p + n</c> are the same as those of <c>*std::next(d.begin(), n)</c> and <c>std::next(p, n)</c> respectively.</p>

      <table id="table.stored_table_builder.options">
        <caption><c>stored_table_builder</c> options</caption>
        <col width="1"/><col width="2"/>

        <tr>
          <th>Condition</th>
          <th>Effects</th>
        </tr>

        <tr>
          <td><c>(Options &amp; stored_table_builder_option::transpose) == stored_table_builder_option(0)</c></td>
          <td>The value of the <c>j</c>-th field of the <c>i</c>-th record of the text shall be arranged into <c>c[s + i][j]</c>.</td>
        </tr>

        <tr>
          <td><c>(Options &amp; stored_table_builder_option::transpose) != stored_table_builder_option(0)</c></td>
          <td>The value of the <c>j</c>-th field of the <c>i</c>-th record of the text shall be arranged into <c>c[j][s + i]</c>.
              On each arrangement, the range [<c>c[j].begin() + e</c>, <c>c[j].begin() + (s + i)</c>) shall be filled by empty values where <c>e</c> is the value that <c>c[j].size()</c> had before the arrangement.</td>
        </tr>
      </table>

      <p>After parsing, even when it has exited via an exception, the targeted object shall be complete (<xref id="basic_stored_table.defs"/>) and have its content container not empty.</p>

      <section id="stored_table_builder.cons">
        <name><c>stored_table_builder</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit stored_table_builder(table_type&amp; table, std::size_t max_record_num = 0);
          </code>
          <requires><c>table</c> shall have its content container not empty.</requires>
          <effects>Initializes an object of <c>stored_table_builder&lt;Content, Allocator, Options></c> that holds a reference to the targeted object <c>table</c>.
                   If <c>max_record_num</c> is not <c>0</c>, the returned object make the parser abort the processing after the first <c>max_record_num</c> records are processed.</effects>
          <remark><c>table.empty()</c> may be <c>false</c>. This constructor does nothing on the targeted object.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class F> stored_table_builder(table_type&amp; table, F&amp;&amp; f);
          </code>
          <preface>Let <c>G</c> be <c>std::decay_t&lt;F></c> and <c>t</c> be an lvalue of the targeted object of the constructed object whose type is cv-unqualified <c>table_type</c>.</preface>
          <requires><c>G</c> shall meet the <c>MoveConstructible</c> requirements.
                    For an expression <c>g</c> that is an lvalue of cv-unqualified <c>G</c>, <c>g()</c> or <c>g(t)</c> shall be a valid expression whose type is <c>void</c> or a type contextually convertible to <c>bool</c>, and evaluating this expression shall not make the content container of <c>t</c> empty.
                    <c>table</c> shall have its content container not empty.</requires>
          <effects>Initializes an object of <c>stored_table_builder&lt;Content, Allocator, Options></c> that holds a reference to the targeted object <c>table</c> and an object of <c>G</c>, whose lvalue on cv-unqualified <c>G</c> is hereinafter called <c>g</c>, constructed with <c>std::forward&lt;F>(f)</c>.
                   The constructed object invokes, after each record of the text table is read into the targeted object, <c>h(g)</c> (if it is a valid expression) or <c>h()</c> (if it is a valid expression and <c>h(t)</c> is not);
                   and then makes the parser abort the processing if the contextually converted value to <c>bool</c> of the return value of this invocation on <c>h</c> is <c>false</c>.</effects>
          <remark>This constructor shall not participate in overload resolution unless <c>std::is_integral_v&lt;G></c> is <c>false</c>.
                  <c>table.empty()</c> may be <c>false</c>. This constructor does nothing on the targeted object.</remark>
        </code-item>

        <code-item>
          <code>
stored_table_builder(stored_table_builder&amp;&amp; other) noexcept;
          </code>
          <effects>Initializes an object of <c>stored_table_builder&lt;Content, Allocator, Options></c> that holds the same reference to the targeted object as <c>other</c>.</effects>
          <remark>This constructor does nothing on the targeted object.</remark>
        </code-item>

        <code-item>
          <code>
~stored_table_builder();
          </code>
          <remark>This destructor does nothing on the targeted object.</remark>
        </code-item>
      </section>

      <section id="stored_table_builder.creation">
        <name><c>stored_table_builder</c> creation functions</name>

        <code-item>
          <code>
template &lt;stored_table_builder_option Options = stored_table_builder_option::none,
          class Content, class Allocator, class... Args>
  stored_table_builder&lt;Content, Allocator, Options> make_stored_table_builder(
    basic_stored_table&lt;Content, Allocator>&amp; table, Args&amp;&amp;... args);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return stored_table_builder&lt;Content, Allocator, Options>(
         table, std::forward&lt;Args>(args)...);</code>
          </effects>
        </code-item>
      </section>
    </section>
  </section>

  <section id="scan">
    <name>One-pass scanning operation</name>

    <section id="scan.scanner">
      <name>The table scanner</name>

      <section id="scan.scanner.general">
        <name>General</name>

        <p>Commata offers a <n>table scanner</n> class template, whose name is <c>basic_table_scanner</c> (<xref id="basic_table_scanner"/>), whose instances meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) as a simple facility for one-pass scanning of texts.</p>
        <p>A table scanner object can hold a <n>body field scanner</n> object for each field to which it forwards the field values, and it can hold a <n>record-end scanner</n> object to which it noitifies the end-of-record events.</p>
        <p>In addition, a table scanner object can be configured to recognize some first records as &#x2018;header&#x2019; records. It can simply ignore the header records or can forward the field values in the header to a <n>header field scanner</n> object it holds optionally.</p>
        <p>Properties that the type of the body field scanners shall meet, type of the record-end scanners shall meet, and the type of the header field scanners shall meet are bundled as
           the <c>BodyFieldScanner</c>, the <c>RecordEndScanner</c> and the <c>HeaderFieldScanner</c> requirements respectively.</p>
      </section>

      <section id="body_field_scanner.requirements">
        <name><c>BodyFieldScanner</c> requirements</name>

        <p>A type <c>S</c> meets the <c>BodyFieldScanner</c> requirements for <c>Ch</c> that is a char-like type, <c>Tr</c> that is a character traits type of <c>Ch</c>, and <c>Allocator</c> that is an allocator type of <c>Ch</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expressions shown in <xref id="table.field_scanner.requirements"/> are valid and have the indicated semantics.</li>
        </ul>

        <p>In <xref id="table.field_scanner.requirements"/>, <c>s</c> is an lvalue of cv-unqualified <c>S</c>.
           <c>b</c> and <c>e</c> are rvalues of <c>Ch*</c>.
           <c>rv</c> is an rvalue of <c>std::basic_string&lt;Ch, Tr, Allocator></c>.</p>

        <p>Requirements shown as (1) and (2) in <xref id="table.field_scanner.requirements"/> are optional, but at least one of (1) and (2) shall be satisfied without falling back to the default behaviours, because they are defined in a cross-referencing manner.</p>

        <table id="table.field_scanner.requirements">
          <caption><c>BodyFieldScanner</c> requirements</caption>
          <col width="1"/><col width="3"/><col width="3"/><col width="10"/><col width="6"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remarks</th>
            <th>Default behaviour</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>s(b, e)</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has finalized a text value of the field of a body record.
                Any pointers in the range [<c>b</c>, <c>e</c>] are dereferenceable and any values stored at them are modifiable.
                Initially the range [<c>b</c>, <c>e</c>) represents the value of the field and <c>*e</c> is the terminating zero.
                The range [<c>b</c>, <c>e</c>] may be invalidated after the invocation exits.
                It is unspecified which of (1) and (2) the table scanner calls.</td>
            <td>Creates an <c>std::basic_string&lt;Ch, Tr, Allocator></c> object with the range [<c>b</c>, <c>e</c>) and the table scanner’s allocator, and then calls (2) with it.</td>
          </tr>

          <tr>
            <td>(2)</td>
            <td><c>s(rv)</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has finalized a text value of the field of a body record. The value of the field is <c>rv</c>.</td>
            <td>Calls (1) with <c>rv.data()</c> and <c>rv.data() + rv.size()</c>.</td>
          </tr>

          <tr>
            <td>(3)</td>
            <td><c>s()</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has found that the field does not appear in the body record, that is, the record has too few fields to reach the field.</td>
            <td></td>
          </tr>
        </table>
      </section>

      <section id="record_end_scanner.requirements">
        <name><c>RecordEndScanner</c> requirements</name>

        <p>A type <c>S</c> meets the <c>RecordEndScanner</c> requirements for an instance of <c>basic_table_scanner</c> (<xref id="basic_table_scanner"/>) <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expression shown in <xref id="table.record_end_scanner.requirements"/> is valid and have the indicated semantics.</li>
        </ul>

        <p><xref id="table.record_end_scanner.requirements"/> shows two expressions per row.
           It is required that at least one of these two expression qualifies, that is, it is not needed that both of two do.
           If both expressions qualify, the first one shall be evaluated by the table scanner.</p>

        <p>In <xref id="table.record_end_scanner.requirements"/>, <c>s</c> is an lvalue of cv-unqualified <c>S</c>.
           <c>t</c> denotes the table scanner object that holds the record-end scanner denoted by <c>s</c> and is an lvalue of cv-unqualified <c>T</c> .</p>

        <table id="table.record_end_scanner.requirements">
          <caption><c>RecordEndScanner</c> requirements</caption>
          <col width="1"/><col width="3"/><col width="3"/><col width="16"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remarks</th>
          </tr>

          <tr>
            <td rowspan="2">(1)</td>
            <td><c>s(t)</c></td>
            <td rowspan="2"><c>void</c> or a type contextually convertible to <c>bool</c></td>
            <td rowspan="2">Called when the table scanner has met an end of a body record.
                            If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the table scanner shall make the parser abort the parsing process.</td>
          </tr>

          <tr>
            <td><c>s()</c></td>
          </tr>
        </table>
      </section>

      <section id="header_field_scanner.requirements">
        <name><c>HeaderFieldScanner</c> requirements</name>

        <p>A type <c>S</c> meets the <c>HeaderFieldScanner</c> requirements for an instance of <c>basic_table_scanner</c> (<xref id="basic_table_scanner"/>) <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expression shown in <xref id="table.header_field_scanner.requirements"/> is valid and have the indicated semantics.</li>
        </ul>

        <p>In <xref id="table.header_field_scanner.requirements"/>, <c>s</c> is an lvalue of cv-unqualified <c>S</c>.
           The type of <c>j</c> is <c>std::size_t</c>.
           The type of <c>v</c> is <c>const std::pair&lt;T::char_type*, T::char_type*>*</c>.
           <c>t</c> denotes the table scanner object that holds the header field scanner denoted by <c>s</c> and is an lvalue of cv-unqualified <c>T</c> .</p>

        <table id="table.header_field_scanner.requirements">
          <caption><c>HeaderFieldScanner</c> requirements</caption>
          <col width="1"/><col width="3"/><col width="3"/><col width="16"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remarks</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>s(j, v, t)</c></td>
            <td>A type contextually convertible to <c>bool</c></td>
            <td>Called by the table scanner in two situations following.
                <ul>
                  <li>When the table scanner has finalized a value of the header field. <c>j</c> is the zero-based field index.
                      Any pointers in the range [<c>v->first</c>, <c>v->second</c>] are dereferenceable and any values stored at them are modifiable.
                      Initially the range [<c>v->first</c>, <c>v->second</c>) represents the value of the header field and <c>*v->second</c> is the terminating zero.
                      The range [<c>v->first</c>, <c>v->second</c>] may be invalidated after the invocation exits.</li>
                  <li>When a record in the header has ended. <c>j</c> is the number of the fields in the records. <c>v</c> is a null pointer.</li>
                </ul>
                In any of cases, when <c>!r</c> is not <c>false</c> where <c>r</c> is the return value of this, the table scanner shall uninstall this header field scanner and recognizes that the current record is the final header record, that is, the next record will be the first body record.</td>
          </tr>
        </table>
      </section>
    </section>

    <section id="hpp.table_scanner.syn">
      <name>Header <c>"commama/table_scanner.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;memory>
#include &lt;string>
#include &lt;typeinfo>

namespace commata {
  <c>// <n><xref id="basic_table_scanner"/>, basic_table_scanner:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class basic_table_scanner;

  using table_scanner = basic_table_scanner&lt;char>;
  using wtable_scanner = basic_table_scanner&lt;wchar_t>;
}
      </codeblock>
      <p>The header <c>"commama/table_scanner.hpp"</c> defines <c>basic_table_scanner</c> class template (<xref id="basic_table_scanner"/>), which describes table scanner objects.</p>
    </section>

    <section id="basic_table_scanner">
      <name>Class template <c>basic_table_scanner</c></name>

      <section id="basic_table_scanner.overview">
        <name>Class template <c>basic_table_scanner</c> overview</name>

        <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class basic_table_scanner {
  public:
    using char_type = Ch;
    using traits_type = Tr;
    using allocator_type = Allocator;
    using size_type = typename std::allocator_traits&lt;Allocator>::size_type;

    <c>// <n><xref id="basic_table_scanner.cons"/>, construction:</n></c>
    explicit basic_table_scanner(std::size_t header_record_count = 0);
    basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                        std::size_t header_record_count = 0);
    template &lt;class HeaderFieldScanner>
      explicit basic_table_scanner(HeaderFieldScanner&amp;&amp; s);
    template &lt;class HeaderFieldScanner>
      basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                          HeaderFieldScanner&amp;&amp; s);
    basic_table_scanner(basic_table_scanner&amp;&amp; other) noexcept;

   ~basic_table_scanner();

    <c>// <n><xref id="basic_table_scanner.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="basic_table_scanner.field_scanner_access"/>, body field scanner access:</n></c>
    template &lt;class T = std::nullptr_t> void set_field_scanner(std::size_t j, T&amp;&amp; s = T());
    bool has_field_scanner(std::size_t j) const noexcept;
    const std::type_info&amp; get_field_scanner_type(std::size_t j) const noexcept;
    template &lt;class T> const T* get_field_scanner(std::size_t j) const noexcept;
    template &lt;class T>       T* get_field_scanner(std::size_t j)       noexcept;

    <c>// <n><xref id="basic_table_scanner.record_end_scanner_access"/>, record-end scanner access:</n></c>
    template &lt;class T = std::nullptr_t> void set_record_end_scanner(T&amp;&amp; s = T());
    bool has_record_end_scanner() const noexcept;
    const std::type_info&amp; get_record_end_scanner_type() const noexcept;
    template &lt;class T> const T* get_record_end_scanner() const noexcept;
    template &lt;class T>       T* get_record_end_scanner()       noexcept;

    <c>// <n>six member functions below are declared and defined to meet the TableHandler</n>
    // <n>requirements (<xref id="table_handler.requirements"/>):</n></c>
    void start_buffer(Ch* buffer_begin, Ch* buffer_end);
    void end_buffer(Ch* buffer_end);
    void start_record(Ch* record_begin);
    bool end_record(Ch* record_end);
    void update(Ch* first, Ch* last);
    void finalize(Ch* first, Ch* last);

    <c>// <n><xref id="basic_table_scanner.processing_state"/>, processing state:</n></c>
    bool is_in_header() const noexcept;
  };
}
        </codeblock>

        <p>The class template <c>basic_table_scanner</c> describes the table scanner objects (<xref id="scan.scanner.general"/>).
           An instantiation of it satisfies the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for the template parameter <c>Ch</c>.
           An object of an instantiation of it can not be reused; that is, it can receive the parsing events that the parser emits only once.</p>
        <p>The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements and <c>Allocator::value_type</c> shall be a type identical to <c>Ch</c>.</p>
      </section>

      <section id="basic_table_scanner.cons">
        <name><c>basic_table_scanner</c> construction</name>

        <code-item>
          <code>
explicit basic_table_scanner(std::size_t header_record_count = 0);
basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                    std::size_t header_record_count = 0);
          </code>
          <effects>Constructs an object of <c>basic_table_scanner</c>.
                   The scanner shall ignore the first <c>header_record_count</c> records as header records.
                   The scanner shall allocate and deallocate memory with a default constructed <c>Allocator</c> object (first form) or a copy of <c>alloc</c> (second form).</effects>
          <postcondition><c>*this</c> has neither a header field scanner nor any body field scanners installed.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class HeaderFieldScanner>
  explicit basic_table_scanner(HeaderFieldScanner&amp;&amp; s);
template &lt;class HeaderFieldScanner>
  basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                      HeaderFieldScanner&amp;&amp; s);
          </code>
          <preface>Let <c>T</c> be <c>std::decay_t&lt;HeaderFieldScanner></c>.</preface>
          <requires><c>T</c> shall meet the <c>HeaderFieldScanner</c> requirements (<xref id="header_field_scanner.requirements"/>) for <c>basic_table_scanner&lt;Ch, Tr, Allocator></c>.</requires>
          <effects>Constructs an object of <c>basic_table_scanner</c> with an header field scanner object installed.
                   The scanner shall allocate and deallocate memory with a default constructed <c>Allocator</c> object (first form) or a copy of <c>alloc</c> (second form).</effects>
          <postcondition><c>*this</c> has a header field scanner object installed whose type is <c>T</c> and that is constructed with <c>std::forward&lt;HeaderFieldScanner>(s)</c>, and no body field scanners installed.</postcondition>
          <remark>These constructors shall not participate in overload resolution unless <c>std::is_integral_v&lt;T></c> is <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="basic_table_scanner.allocator">
        <name><c>basic_table_scanner</c> allocator access</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object held by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="basic_table_scanner.field_scanner_access">
        <name><c>basic_table_scanner</c> body field scanner access</name>

        <code-item>
          <code>
template &lt;class T = std::nullptr_t> void set_field_scanner(std::size_t j, T&amp;&amp; s = T());
          </code>
          <preface>Let <c>U</c> be <c>std::decay_t&lt;T></c>.</preface>
          <requires><c>U</c> shall either be <c>std::nullptr_t</c> or
                    meet the <c>BodyFieldScanner</c> requirements (<xref id="body_field_scanner.requirements"/>) for <c>Ch</c>, <c>Tr</c> and <c>Allocator</c>.</requires>
          <effects>If <c>U</c> is <c>std::nullptr_t</c>, uninstalls the body field scanner installed at zero-based field index <c>j</c> if any.
                   Otherwise, uninstalls the body field scanner installed there if any, and installs an object of <c>U</c> constructed with <c>std::forward&lt;T>(s)</c> as a body field scanner in place of it.</effects>
          <remark>If an exception is thrown by this function, this function has no effects.</remark>
        </code-item>

        <code-item>
          <code>
bool has_field_scanner(std::size_t j) const noexcept;
          </code>
          <returns>If <c>*this</c> has a body field scanner installed at zero-based field index <c>j</c>, <c>true</c>; otherwise, <c>false</c>.</returns>
        </code-item>

        <code-item>
          <code>
const std::type_info&amp; get_field_scanner_type(std::size_t j) const noexcept;
          </code>
          <returns>If <c>*this</c> has a body field scanner of type <c>T</c> installed at zero-based field index <c>j</c>, <c>typeid(T)</c>; otherwise, <c>typeid(void)</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class T> const T* get_field_scanner(std::size_t j) const noexcept;
template &lt;class T>       T* get_field_scanner(std::size_t j)       noexcept;
          </code>
          <returns>If <c>get_field_scanner_type(j) == typeid(T)</c>, a pointer to the body field scanner object installed at zero-based field index <c>j</c>; otherwise, a null pointer.</returns>
        </code-item>
      </section>

      <section id="basic_table_scanner.record_end_scanner_access">
        <name><c>basic_table_scanner</c> record-end scanner access</name>

        <code-item>
          <code>
template &lt;class T = std::nullptr_t> void set_record_end_scanner(T&amp;&amp; s = T());
          </code>
          <preface>Let <c>U</c> be <c>std::decay_t&lt;T></c>.</preface>
          <requires><c>U</c> shall either be <c>std::nullptr_t</c> or meet the <c>RecordEndScanner</c> requirements (<xref id="record_end_scanner.requirements"/>).</requires>
          <effects>If <c>U</c> is <c>std::nullptr_t</c>, uninstalls the record-end scanner installed if any.
                   Otherwise, uninstalls the record-end scanner installed if any, and installs an object of <c>U</c> constructed with <c>std::forward&lt;T>(s)</c> as the record-end scanner in place of it.</effects>
          <remark>If an exception is thrown by this function, this function has no effects.</remark>
        </code-item>

        <code-item>
          <code>
bool has_record_end_scanner() const noexcept;
          </code>
          <returns>If <c>*this</c> has a record-end scanner installed, <c>true</c>; otherwise, <c>false</c>.</returns>
        </code-item>

        <code-item>
          <code>
const std::type_info&amp; get_record_end_scanner_type() const noexcept;
          </code>
          <returns>If <c>*this</c> has a record-end scanner of type <c>T</c> installed, <c>typeid(T)</c>; otherwise, <c>typeid(void)</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class T> const T* get_record_end_scanner() const noexcept;
template &lt;class T>       T* get_record_end_scanner()       noexcept;
          </code>
          <returns>If <c>get_record_end_scanner_type() == typeid(T)</c>, a pointer to the record-end scanner object installed; otherwise, a null pointer.</returns>
        </code-item>
      </section>

      <section id="basic_table_scanner.processing_state">
        <name><c>basic_table_scanner</c> processing state</name>
        <code-item>
          <code>
bool is_in_header() const noexcept;
          </code>
          <requires>Shall be invoked within a call of <c>parse_csv</c> (<xref id="parse_csv"/>).</requires>
          <returns><c>true</c> if <c>*this</c> is configured to regard some first records as header records and
                   <c>end_record</c> has not be called for the final header record; <c>false</c> otherwise.</returns>
          <note>This member may be useful to implement a table handler class whose object wraps a <c>basic_table_scanner</c> object.</note>
        </code-item>
      </section>
    </section>

    <section id="scan.builtin.body_field_scanners.requirements">
      <name>Requirements for default body field scanners</name>

      <p>The Commata library offers four default body field scanner types that meet the <c>BodyFieldScanner</c> requirements (<xref id="body_field_scanner.requirements"/>):
         <c>arithmetic_field_translator</c> (<xref id="arithmetic_field_translator"/>), <c>locale_based_arithmetic_field_translator</c> (<xref id="locale_based_arithmetic_field_translator"/>), <c>string_field_translator</c> (<xref id="string_view_field_translator"/>) and <c>string_view_field_translator</c> (<xref id="string_view_field_translator"/>).</p>
      <p>An object of these types translates a text value of a text field (<xref id="xlate.general"/>) into a value of its <n>target type</n> and forwards it into its installed <n>sink</n>.</p>
      <p>Behaviours of these default body scanner objects can be customized through the three concepts: <c>FieldTranslatorSink</c> (<xref id="field_translator_sink.requirements"/>), <c>SkippingHandler</c> (<xref id="skipping_handler.requirements"/>) and <c>ConversionErrorHandler</c> (<xref id="conversion_error_handler.requirements"/>).</p>

      <section id="field_translator_sink.requirements">
        <name><c>FieldTranslatorSink</c> requirements</name>

        <p>A type <c>S</c> is a <c>FieldTranslatorSink</c> type for the target type <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>it is an output iterator type for the type <c>T</c> or a callable type for an argument of an rvalue of cv-unqualified <c>T</c>.</li>
        </ul>

        <p>To <n>put</n> an object expressed by an rvalue <c>rt</c> of the cv-unqualified type <c>T</c> to an object expressed by an lvalue <c>s</c> of the cv-unqualified type <c>S</c> that is a <c>FieldTranslatorSink</c> type is:</p>
        <ul>
          <li>if <c>S</c> is an output iterator type, to evaluate <c>*s = rt</c>,</li>
          <li>otherwise, to evaluate <c>s(rt)</c>.</li>
        </ul>
      </section>

      <section id="skipping_handler.requirements">
        <name><c>SkippingHandler</c> requirements</name>

        <p>A type <c>H</c> meets the <c>SkippingHandler</c> requirements for the target type <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expression shown in <xref id="table.skipping_handler.requirements"/> is valid and have the indicated semantics.</li>
        </ul>

        <p><xref id="table.skipping_handler.requirements"/> shows two expressions per row.
           It is required that at least one of these two expression qualifies; that is, it is not needed that both of two do.
           When multiple expressions in one row qualify, it shall be the first one that is selected to be evaluated.
           This selection shall be done at compile time.
             <span class="note">To evaluate these expressions as specified here, the function template <c>invoke_typing_as</c> (<xref id="invoke_typing_as"/>) can be used.</span></p>

        <p>In <xref id="table.skipping_handler.requirements"/>, <c>h</c> is an lvalue of cv-unqualified <c>H</c>.
           <c>n</c> is a null pointer whose type is <c>T*</c>.</p>

        <table id="table.skipping_handler.requirements">
          <caption><c>SkippingHandler</c> requirements</caption>
          <col width="1"/><col width="3"/><col width="3"/><col width="16"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remarks</th>
          </tr>

          <tr>
            <td rowspan="2">(1)</td>
            <td><c>h(n)</c></td>
            <td rowspan="2">Convertible to <c>std::optional&lt;T></c></td>
            <td rowspan="2">Called when the corresponding field has been skipped, that is, the record has had too few fields to reach the field.
                If <c>r.has_value()</c> is not <c>false</c> where <c>r</c> is the return value, the translated value of the field shall be constructed from <c>std::move(*r)</c>;
                otherwise, no values shall be put to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td><c>h()</c></td>
          </tr>
        </table>
      </section>
    </section>

    <section id="hpp.field_scanners.syn">
      <name>Header <c>"commama/field_scanners.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;locale>
#include &lt;memory>
#include &lt;optional>
#include &lt;string>
#include &lt;string_view>
#include &lt;type_traits>

#include "field_handling.hpp"
#include "text_error.hpp"
#include "text_value_translation.hpp"

namespace commata {
  <c>// <n><xref id="scan.builtin.exceptions"/>, exception classes:</n></c>
  class field_not_found;

  <c>// <n><xref id="fail_if_skipped"/>, fail_if_skipped:</n></c>
  struct fail_if_skipped;

  <c>// <n><xref id="ignore_if_skipped"/>, ignore_if_skipped:</n></c>
  struct ignore_if_skipped;

  <c>// <n><xref id="replace_if_skipped"/>, replace_if_skipped:</n></c>
  template &lt;class T> class replace_if_skipped;
  template &lt;class T>
    void swap(replace_if_skipped&lt;T>&amp; left,
              replace_if_skipped&lt;T>&amp; right) noexcept(noexcept(left.swap(right)));

  <c>// <n><xref id="arithmetic_field_translator"/>, arithmetic_field_translator:</n></c>
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class arithmetic_field_translator;

  <c>// <n><xref id="locale_based_arithmetic_field_translator"/>, locale_based_arithmetic_field_translator:</n></c>
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class locale_based_arithmetic_field_translator;

  <c>// <n><xref id="string_field_translator"/>, string_field_translator:</n></c>
  template &lt;class Sink, class Ch, class Tr = std::char_traits&lt;Ch>,
            class Allocator = std::allocator&lt;Ch>,
            class SkippingHandler = fail_if_skipped>
    class string_field_translator;

  <c>// <n><xref id="string_view_field_translator"/>, string_view_field_translator:</n></c>
  template &lt;class Sink, class Ch, class Tr = std::char_traits&lt;Ch>,
            class SkippingHandler = fail_if_skipped>
    class string_view_field_translator;

  <c>// <n><xref id="scan.builtin.body_field_scanners.creation"/>, creation of default field scanners:</n></c>
  template &lt;class T, class SinkR, class... Appendices>
    <nc>see below</nc> make_field_translator(SinkR&amp;&amp; sink, Appendices&amp;&amp;... appendices);
  template &lt;class T, class Allocator, class SinkR, class... Appendices>
    <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                    SinkR&amp;&amp; sink, Appendices&amp;&amp;... appendices);
  template &lt;class Container, class... Appendices>
    <nc>see below</nc> make_field_translator(Container&amp; values, Appendices&amp;&amp;... appendices);
  template &lt;class Allocator, class Container, class... Appendices>
    <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                    Container&amp; values, Appendices&amp;&amp;... appendices);
}
      </codeblock>
      <p>The header <c>"commama/field_scanners.hpp"</c> defines default body field scanners (<xref id="body_field_scanner.requirements"/>) and some accompanying facilities of them.</p>
    </section>

    <section id="scan.builtin.exceptions">
      <name>Exception classes for default body field scanners</name>

      <section id="field_not_found">
        <name>Class <c>field_not_found</c></name>

        <codeblock>
namespace commata {
  class field_not_found : public text_error {
  public:
    using text_error::text_value_error;
  };
}
        </codeblock>

        <p>The class <c>field_not_found</c> defines the type of the objects thrown by default field scanners of Commata library to report that a record that has too few fields to reach the field scanner concerned was found.</p>
      </section>
    </section>

    <section id="scan.builtin.skipping_handlers">
      <name>Default skipping handler classes</name>

      <section id="fail_if_skipped">
        <name>Struct <c>fail_if_skipped</c></name>

        <codeblock>
namespace commata {
  struct fail_if_skipped {
    explicit fail_if_skipped(replacement_fail_t = replacement_fail) {}
    template &lt;class T> [[noreturn]] T operator()(T* = nullptr) const;
  };
}
        </codeblock>

        <p>The struct <c>fail_if_skipped</c> is a type that meets the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>) for any target types.
           An object of it makes the parsing process fail when the corresponding field is not found in a record.</p>

        <code-item>
          <code>
template &lt;class T> [[noreturn]] T operator()(T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>field_not_found</c> (<xref id="field_not_found"/>).</effects>
        </code-item>
      </section>

      <section id="ignore_if_skipped">
        <name>Struct <c>ignore_if_skipped</c></name>

        <codeblock>
namespace commata {
  struct ignore_if_skipped {
    explicit ignore_if_skipped(replacement_ignore_t = replacement_ignore) {}
    std::nullopt_t operator()() const;
  };
}
        </codeblock>

        <p>The struct <c>ignore_if_skipped</c> is a type that meets the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>) for any target types.
           An object of it makes its associated <c>BodyFieldScanner</c> treat its corresponding field not found in a record as if it does not exist.</p>

        <code-item>
          <code>
std::nullopt_t operator()() const;
          </code>
          <returns><c>std::nullopt</c>.</returns>
        </code-item>
      </section>

      <section id="replace_if_skipped">
        <name>Class template <c>replace_if_skipped</c></name>

        <codeblock>
namespace commata {
  template &lt;class T> class replace_if_skipped {
  public:
    using value_type = T;

    <c>// <n><xref id="replace_if_skipped.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class U = T>
      explicit replace_if_skipped(U&amp;&amp; u = std::decay_t&lt;U>()) noexcept(<nc>see below</nc>);
    explicit replace_if_skipped(replacement_fail_t) noexcept;
    explicit replace_if_skipped(replacement_ignore_t) noexcept;
    replace_if_skipped(const replace_if_skipped&amp;  other) noexcept(<nc>see below</nc>);
    replace_if_skipped(      replace_if_skipped&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~replace_if_skipped();
    replace_if_skipped&amp; operator=(const replace_if_skipped&amp;  other) noexcept(<nc>see below</nc>);
    replace_if_skipped&amp; operator=(      replace_if_skipped&amp;&amp; other) noexcept(<nc>see below</nc>);

    <c>// <n><xref id="replace_if_skipped.inv"/>, invocation:</n></c>
    template &lt;class U = T> std::optional&lt;U> operator()(U* = nullptr) const;

    <c>// <n><xref id="replace_if_skipped.modifiers"/>, modifiers:</n></c>
    void swap(replace_if_skipped&amp; other) noexcept(<nc>see below</nc>);
  };

  template &lt;class T> replace_if_skipped(T) -> replace_if_skipped&lt;T>;

  <c>// <n><xref id="replace_if_skipped.special"/>, specialized algorithms:</n></c>
  template &lt;class T>
    void swap(replace_if_skipped&lt;T>&amp; left,
              replace_if_skipped&lt;T>&amp; right) noexcept(noexcept(left.swap(right)));
}
        </codeblock>

        <p>The class template <c>replace_if_skipped</c> offers types that meet the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>) whose target type is the template parameter <c>T</c>.
           An object of them supplements the corresponding field that is not found in a record with a fixed value.</p>
        <p><c>T</c> shall meet the <c>CopyConstructible</c> requirements and the <c>Destructible</c> requirements.
           <c>T</c> shall not be equal to possibly cv-qualified types <c>replacement_fail_t</c> or <c>replacement_ignore_t</c>.</p>
        <p>An object of an instance of <c>replace_if_skipped</c> has a replacement action (<xref id="replacement_action"/>).</p>
        <p><c>replace_if_skipped&lt;T></c> shall be a trivially copyable type if <c>std::is_trivially_copyable_v&lt;T></c> is <c>true</c>.</p>
        <p><span class="note">For types <c>T</c> and <c>U</c> that satisfy <c>std::is_convertible_v&lt;const T&amp;, U></c> is <c>true</c>, <c>replace_if_skipped&lt;T></c> meets the <c>SkippingHandler</c> requirements for not only <c>T</c> but also <c>U</c> as its target type.</span></p>

        <section id="replace_if_skipped.cons">
          <name><c>replace_if_skipped</c> construct/copy/destroy</name>

          <code-item>
            <code>
template &lt;class U = T>
  explicit replace_if_skipped(U&amp;&amp; u = std::decay_t&lt;U>()) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures the replacement action to be <c>copy</c> with an object of <c>T</c> constructed from <c>std::forward&lt;U>(u)</c>.</effects>
            <remark>This constructor shall not participate in overload resolution unless <c>std::is_constructible_v&lt;T, U></c> is <c>true</c>,
                    <c>std::is_base_of_v&lt;replace_if_skipped&lt;T>, std::decay&lt;U>></c> is <c>false</c>,
                    <c>std::is_base_of_v&lt;replacement_fail_t, std::decay&lt;U>></c> is <c>false</c>, and
                    <c>std::is_base_of_v&lt;replacement_ignore_t, std::decay&lt;U>></c> is <c>false</c>.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible_v&lt;T, U></c>.</remark>
          </code-item>

          <code-item>
            <code>
explicit replace_if_skipped(replacement_fail_t) noexcept;
            </code>
            <effects>Configures the replacement action to be <c>fail</c>.</effects>
          </code-item>

          <code-item>
            <code>
explicit replace_if_skipped(replacement_ignore_t) noexcept;
            </code>
            <effects>Configures the replacement action to be <c>ignore</c>.</effects>
          </code-item>

          <code-item>
            <code>
replace_if_skipped(const replace_if_skipped&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures the replacement action to be the same as <c>other</c>&#x2019;s.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;T></c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_skipped(replace_if_skipped&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures the replacement action to be what <c>other</c> had as its replacement action before the call.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;T></c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class T> replace_if_skipped(T) -> replace_if_skipped&lt;T>;
            </code>
            <remark>This deduction guide participates in overload resolution only if <c>T</c> is not the same type as or a derived class of <c>replacement_fail_t</c> or <c>replacement_ignore_t</c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_skipped&amp; operator=(const replace_if_skipped&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>T</c> shall be <c>CopyAssignable</c>.</requires>
            <effects>Configures the replacement action to be the same as <c>other</c>&#x2019;s.</effects>
            <returns><c>*this</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;T> &amp;&amp; std::is_nothrow_copy_assignable_v&lt;T></c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_skipped&amp; operator=(replace_if_skipped&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>T</c> shall be <c>MoveAssignable</c>.</requires>
            <effects>Configures the replacement action to be what <c>other</c> had as its replacement action before the call.</effects>
            <returns><c>*this</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;T> &amp;&amp; std::is_nothrow_move_assignable_v&lt;T></c>.</remark>
          </code-item>
        </section>

        <section id="replace_if_skipped.inv">
          <name><c>replace_if_skipped</c> invocation</name>

          <code-item>
            <code>
template &lt;class U = T> std::optional&lt;U> operator()(U* = nullptr) const;
            </code>
            <effects>Does as illustrated in <xref id="table.replace_if_skipped.skipped"/> in reference to the replacement action of <c>*this</c>.</effects>
            <remark>This overload shall not participate in overload resolution unless <c>std::is_convertible_v&lt;const T&amp;, U></c> is <c>true</c>.</remark>

            <table id="table.replace_if_skipped.skipped">
              <caption>Effects of calling of <c>operator()</c></caption>
              <col width="13"/><col width="5"/><col width="18"/>

              <tr>
                <th>#</th>
                <th>Type of the action</th>
                <th>Effects</th>
              </tr>

              <tr>
                <td>(1)</td>
                <td><c>copy</c></td>
                <td>Returns <c>std::optional&lt;U>(t)</c> where <c>t</c> is an object of <c>T</c> installed into the action.</td>
              </tr>

              <tr>
                <td>(2)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>std::nullopt</c>.</td>
              </tr>

              <tr>
                <td>(3)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>field_not_found</c> (<xref id="field_not_found"/>).</td>
              </tr>
            </table>

          </code-item>
        </section>

        <section id="replace_if_skipped.modifiers">
          <name><c>replace_if_skipped</c> modifiers</name>

          <code-item>
            <code>
void swap(replace_if_skipped&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires>If both of the replacement action of <c>*this</c> and <c>other</c> are of the type <c>copy</c>, two lvalues of the object of type <c>T</c> installed with the replacement action shall be swappable with each onther.</requires>
            <effects>Exchanges the replacement actions of <c>*this</c> and <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to the value of <c>std::is_nothrow_move_constructible_v&lt;T> &amp;&amp; noexcept(swap(std::declval&lt;T&amp;>(), std::declval&lt;T&amp;>()))</c> evaluated in a context where <c>std::swap</c> participates in the overload resolution.</remark>
          </code-item>
        </section>

        <section id="replace_if_skipped.special">
          <name><c>replace_if_skipped</c> specialized algorithms</name>

          <code-item>
            <code>
template &lt;class T> void swap(replace_if_skipped&lt;T>&amp; left,
                             replace_if_skipped&lt;T>&amp; right) noexcept(noexcept(left.swap(right)));
            </code>
            <effects>Equivalent to: <c>left.swap(right);</c></effects>
            <remark>This overload shall not participate in overload resolution unless <c>std::is_swappable_v&lt;T></c> is <c>true</c>.</remark>
          </code-item>
        </section>
      </section>
    </section>

    <section id="scan.builtin.body_field_scanners">
      <name>Default body field scanner classes</name>

      <p>This subclause describes the body field scanner classes (<xref id="body_field_scanner.requirements"/>) built-in to Commata.</p>
      <p>In this subclause, terms on the possible target types of these built-in body field scanner classes are used as follows:</p>
      <ul>
        <li>A type <c>T</c> is a <n>default translatable string type</n> if <c>T</c> is the same type as <c>std::basic_string&lt;Ch, Tr, Allocator></c> for a certain combination of <c>Ch</c>, <c>Tr</c> and <c>Allocator</c>.</li>
        <li>A type <c>T</c> is a <n>default translatable string view type</n> if <c>T</c> is the same type as <c>std::basic_string_view&lt;Ch, Tr></c> for a certain combination of <c>Ch</c> and <c>Tr</c>.</li>
        <li>A type <c>T</c> is a <n>default translatable type</n> if <c>T</c> is a default translatable arithmeric type, a default translatable string type or a default translatable string view type.</li>
      </ul>

      <section id="arithmetic_field_translator">
        <name>Class template <c>arithmetic_field_translator</c></name>

        <codeblock>
namespace commata {
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class arithmetic_field_translator {
  public:
    using value_type = T;
    using skipping_handler_type = SkippingHandler;
    using conversion_error_handler_type = ConversionErrorHandler;

    <c>// <n><xref id="arithmetic_field_translator.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class SinkR, class SkippingHandlerR = SkippingHandler,
              class ConversionErrorHandlerR = ConversionErrorHandler>
      explicit arithmetic_field_translator(
        SinkR&amp;&amp; sink, SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>(),
        ConversionErrorHandlerR&amp;&amp; handle_conversion_error =
          std::decay_t&lt;ConversionErrorHandlerR>());
    arithmetic_field_translator(const arithmetic_field_translator&amp;  other) noexcept(<nc>see below</nc>);
    arithmetic_field_translator(      arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~arithmetic_field_translator();

    <c>// <n><xref id="arithmetic_field_translator.handler"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler()       noexcept;
    const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
          ConversionErrorHandler&amp; get_conversion_error_handler()       noexcept;

    <c>// <n><xref id="arithmetic_field_translator.inv"/>, invocation:</n></c>
    template &lt;class Ch> void operator()(const Ch* begin, const Ch* end);
                        void operator()();
  };
}
        </codeblock>

        <p>The <c>arithmetic_field_translator</c> class template provides a simple implementation for arithmetic types that meets the <c>BodyFieldScanner</c> requirements (<xref id="body_field_scanner.requirements"/>) whose target type (<xref id="scan.builtin.body_field_scanners.requirements"/>) is the template parameter <c>T</c>.</p>
        <p>The template parameter <c>T</c> shall be a default translatable arithmeric type (<xref id="xlate.arithmetic"/>).
           The template parameters <c>Sink</c>, <c>SkippingHandler</c> and <c>ConversionErrorHandler</c> shall meet the <c>FieldTranslatorSink</c> requirements (<xref id="field_translator_sink.requirements"/>), the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>) and the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>) for the target type <c>T</c> respectively.</p>

        <section id="arithmetic_field_translator.cons">
          <name><c>arithmetic_field_translator</c> construct/copy/destroy</name>
          <code-item>
            <code>
template &lt;class SinkR, class SkippingHandlerR = SkippingHandler,
          class ConversionErrorHandlerR = ConversionErrorHandler>
  explicit arithmetic_field_translator(
    SinkR&amp;&amp; sink, SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>(),
    ConversionErrorHandlerR&amp;&amp; handle_conversion_error =
      std::decay_t&lt;ConversionErrorHandlerR>());
            </code>
            <requires><c>std::is_constructible_v&lt;Sink, SinkR&amp;&amp;></c>, <c>std::is_constructible_v&lt;SkippingHandler, SkippingHandlerR&amp;&amp;></c> and <c>std::is_constructible_v&lt;ConversionErrorHandler, ConversionErrorHandlerR&amp;&amp;></c> shall all be <c>true</c>.</requires>
            <effects>Initializes an object of <c>arithmetic_field_translator</c> that holds objects of <c>Sink</c>, <c>SkippingHandler</c> and <c>ConversionErrorHandler</c> initialized with <c>std::forward&lt;SinkR>(sink)</c>, <c>std::forward&lt;SkippingHandlerR>(handle_skipping)</c> and <c>std::forward&lt;ConversionErrorHandlerR>(handle_conversion_error)</c>
                     as the field translator sink object, the skipping handler object and the conversion error handler object respectively.</effects>
            <remark>This constructor shall not participate in overload resolution unless <c>std::is_base_of_v&lt;arithmetic_field_translator&lt;T, Sink, SkippingHandler, ConversionErrorHandler>, std::decay_t&lt;SinkR>></c> is <c>false</c>.</remark>
          </code-item>

          <code-item>
            <code>
arithmetic_field_translator(const arithmetic_field_translator&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>Sink</c>, <c>SkippingHandler</c> and <c>ConversionErrorHandler</c> shall be <c>CopyConstructible</c>.</requires>
            <effects>Initializes an object of <c>arithmetic_field_translator</c> that holds a field translator sink object, a skipping handler object and a conversion error handler object initialized with lvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;Sink> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;SkippingHandler> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;ConversionErrorHandler></c>.</remark>
          </code-item>

          <code-item>
            <code>
arithmetic_field_translator(arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Initializes an object of <c>arithmetic_field_translator</c> that holds a field translator sink object, a skipping handler object and a conversion error handler object initialized with xvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;Sink> &amp;&amp; std::is_nothrow_move_constructible_v&lt;SkippingHandler> &amp;&amp; std::is_nothrow_move_constructible_v&lt;ConversionErrorHandler></c>.
                    If exits via an exception, <c>other</c> will be left in a valid but unspecified state.</remark>
          </code-item>
        </section>

        <section id="arithmetic_field_translator.handler">
          <name><c>arithmetic_field_translator</c> handler access</name>
          <code-item>
            <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler()       noexcept;
            </code>
            <returns>A reference of the skipping handler held by <c>*this</c>.</returns>
          </code-item>

          <code-item>
            <code>
const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
      ConversionErrorHandler&amp; get_conversion_error_handler()       noexcept;
            </code>
            <returns>A reference of the conversion error handler held by <c>*this</c>.</returns>
          </code-item>
        </section>

        <section id="arithmetic_field_translator.inv">
          <name><c>arithmetic_field_translator</c> invocation</name>
          <code-item>
            <code>
template &lt;class Ch> void operator()(const Ch* begin, const Ch* end);
            </code>
            <requires><c>Ch</c> shall be <c>char</c> or <c>wchar_t</c>.
                      The template parameter <c>ConversionErrorHandler</c> shall meet the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>) for <c>Ch</c>.</requires>
            <effects><p>Given an exposition-only class template:</p>
              <code>
template &lt;class Ch> struct arithmetic_convertible {
  const Ch* b;
  const Ch* e;
  auto c_str() const { return b; }
  auto size() const { return e - b; }
};
              </code>
              <p>first makes an object <c>w</c> of <c>std::optional&lt;T></c> initialized with <c>to_arithmetic&lt;std::optional&lt;T>>(arithmetic_convertible&lt;Ch>{ begin, end }, get_conversion_error_handler())</c>,
                 and then puts <c>*w</c> into the field translator sink if <c>w.has_value()</c> is <c>true</c>.</p>
            </effects>
          </code-item>

          <code-item>
            <code>
void operator()();
            </code>
            <effects>Evaluates <c>invoke_typing_as&lt;T>(get_skipping_handler())</c> and puts the result into the field translator sink.</effects>
          </code-item>
        </section>
      </section>

      <section id="locale_based_arithmetic_field_translator">
        <name>Class template <c>locale_based_arithmetic_field_translator</c></name>

        <codeblock>
namespace commata {
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class locale_based_arithmetic_field_translator {
  public:
    using value_type = T;
    using skipping_handler_type = SkippingHandler;
    using conversion_error_handler_type = ConversionErrorHandler;

    <c>// <n><xref id="locale_based_arithmetic_field_translator.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class SinkR, class SkippingHandlerR = SkippingHandler,
              class ConversionErrorHandlerR = ConversionErrorHandler>
    explicit locale_based_arithmetic_field_translator(
      SinkR&amp;&amp; sink, const std::locale&amp; loc,
      SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>(),
      ConversionErrorHandlerR&amp;&amp; handle_conversion_error =
        std::decay_t&lt;ConversionErrorHandlerR>());
    locale_based_arithmetic_field_translator(
      const locale_based_arithmetic_field_translator&amp;  other) = default;
    locale_based_arithmetic_field_translator(
            locale_based_arithmetic_field_translator&amp;&amp; other) = default;
   ~locale_based_arithmetic_field_translator() = default;

    <c>// <n><xref id="locale_based_arithmetic_field_translator.handler"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler()       noexcept;
    const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
          ConversionErrorHandler&amp; get_conversion_error_handler()       noexcept;

    <c>// <n><xref id="locale_based_arithmetic_field_translator.inv"/>, invocation:</n></c>
    template &lt;class Ch> void operator()(Ch* begin, Ch* end);
                        void operator()();

private:
    arithmetic_field_translator&lt;T, Sink,
                                SkippingHandler, ConversionErrorHandler> base;  // exposition only
    numpunct_replacer_to_c replace;                                             // exposition only
  };
}
        </codeblock>

        <p>The <c>locale_based_arithmetic_field_translator</c> class template provides an implementation for arithmetic types that meets the <c>BodyFieldScanner</c> requirements (<xref id="body_field_scanner.requirements"/>) whose target type (<xref id="scan.builtin.body_field_scanners.requirements"/>) is the template parameter <c>T</c> in addition to the <c>arithmetic_field_translator</c> class template (<xref id="arithmetic_field_translator"/>).
          The difference is that an object of <c>locale_based_arithmetic_field_translator</c> can correctly handle the decimal radix separator character and the digit group separator character that differ from those of the C library locale.</p>
        <p>The template parameter <c>T</c> shall be a default translatable arithmeric type (<xref id="xlate.arithmetic"/>).
           The template parameters <c>Sink</c>, <c>SkippingHandler</c> and <c>ConversionErrorHandler</c> shall meet the <c>FieldTranslatorSink</c> requirements (<xref id="field_translator_sink.requirements"/>), the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>) and the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>) for the target type <c>T</c> respectively.</p>

        <section id="locale_based_arithmetic_field_translator.cons">
          <name><c>locale_based_arithmetic_field_translator</c> construct/copy/destroy</name>
          <code-item>
            <code>
template &lt;class SinkR, class SkippingHandlerR = SkippingHandler,
          class ConversionErrorHandlerR = ConversionErrorHandler>
explicit locale_based_arithmetic_field_translator(
  SinkR&amp;&amp; sink, const std::locale&amp; loc,
  SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>(),
  ConversionErrorHandlerR&amp;&amp; handle_conversion_error =
    std::decay_t&lt;ConversionErrorHandlerR>());
            </code>
            <requires><c>std::is_constructible_v&lt;Sink, SinkR&amp;&amp;></c>, <c>std::is_constructible_v&lt;SkippingHandler, SkippingHandlerR&amp;&amp;></c> and <c>std::is_constructible_v&lt;ConversionErrorHandler, ConversionErrorHandlerR&amp;&amp;></c> shall all be <c>true</c>.</requires>
            <effects>Initializes <c>base</c> with <c>std::forward&lt;SinkR>(sink)</c>, <c>std::forward&lt;SkippingHandlerR>(handle_skipping)</c> and <c>std::forward&lt;ConversionErrorHandlerR>(handle_conversion_error)</c>.
                     Initializes <c>replace</c> with <c>loc</c>.</effects>
            <remark>This constructor shall not participate in overload resolution unless <c>std::is_base_of_v&lt;locale_based_arithmetic_field_translator&lt;T, Sink, SkippingHandler, ConversionErrorHandler>, std::decay_t&lt;SinkR>></c> is <c>false</c>.</remark>
          </code-item>
        </section>

        <section id="locale_based_arithmetic_field_translator.handler">
          <name><c>locale_based_arithmetic_field_translator</c> handler access</name>
          <code-item>
            <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler()       noexcept;
            </code>
            <effects>Equivalent to: <c>base.get_skipping_handler()</c>.</effects>
          </code-item>

          <code-item>
            <code>
const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
      ConversionErrorHandler&amp; get_conversion_error_handler()       noexcept;
            </code>
            <effects>Equivalent to: <c>base.get_conversion_error_handler()</c>.</effects>
          </code-item>
        </section>

        <section id="locale_based_arithmetic_field_translator.inv">
          <name><c>locale_based_arithmetic_field_translator</c> invocation</name>
          <code-item>
            <code>
template &lt;class Ch> void operator()(Ch* begin, Ch* end);
            </code>
            <requires><c>Ch</c> shall be <c>char</c> or <c>wchar_t</c>.
                      The template parameter <c>ConversionErrorHandler</c> shall meet the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>) for <c>Ch</c>.</requires>
            <effects><p>Equivalent to:</p>
              <code>
Ch* const new_end = replace(begin, end);
*new_end = Ch();
base(begin, new_end);
              </code>
            </effects>
          </code-item>

          <code-item>
            <code>
void operator()();
            </code>
            <effects>Equivalent to: <c>base();</c></effects>
          </code-item>
        </section>
      </section>

      <section id="string_field_translator">
        <name>Class template <c>string_field_translator</c></name>

        <codeblock>
namespace commata {
  template &lt;class Sink, class Ch, class Tr = std::char_traits&lt;Ch>,
            class Allocator = std::allocator&lt;Ch>,
            class SkippingHandler = fail_if_skipped>
    class string_field_translator {
  public:
    using value_type = std::basic_string&lt;Ch, Tr, Allocator>;
    using allocator_type = Allocator;
    using skipping_handler_type = SkippingHandler;

    <c>// <n><xref id="string_field_translator.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class SinkR, class SkippingHandlerR = SkippingHandler>
      explicit string_field_translator(
        SinkR&amp;&amp; sink, SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>());
    template &lt;class SinkR, class SkippingHandlerR = SkippingHandler>
      string_field_translator(
        std::allocator_arg_t, const Allocator&amp; alloc, SinkR&amp;&amp; sink,
        SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>());
    string_field_translator(const string_field_translator&amp;  other) noexcept(<nc>see below</nc>);
    string_field_translator(      string_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~string_field_translator();

    <c>// <n><xref id="string_field_translator.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="string_field_translator.handler"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler()       noexcept;

    <c>// <n><xref id="string_field_translator.inv"/>, invocation:</n></c>
    void operator()(const Ch* begin, const Ch* end);
    void operator()(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; value);
    void operator()();
  };
}
        </codeblock>

        <p>The <c>string_field_translator</c> class template provides a simple implementation for the standard string type that meets the <c>BodyFieldScanner</c> requirements (<xref id="body_field_scanner.requirements"/>) whose target type (<xref id="scan.builtin.body_field_scanners.requirements"/>) is <c>std::basic_string&lt;Ch, Tr, Allocator></c>.</p>
        <p>The template parameters <c>Sink</c> and <c>SkippingHandler</c> shall meet the <c>FieldTranslatorSink</c> requirements (<xref id="field_translator_sink.requirements"/>) and the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>) for the target type <c>std::basic_string&lt;Ch, Tr, Allocator></c> respectively.</p>

        <section id="string_field_translator.cons">
          <name><c>string_field_translator</c> construct/copy/destroy</name>
          <code-item>
            <code>
template &lt;class SinkR, class SkippingHandlerR = SkippingHandler>
  explicit string_field_translator(
    SinkR&amp;&amp; sink, SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>());
            </code>
            <requires>Both of <c>std::is_constructible_v&lt;Sink, SinkR&amp;&amp;></c> and <c>std::is_constructible_v&lt;SkippingHandler, SkippingHandlerR&amp;&amp;></c> shall be <c>true</c>.
                      <c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
            <effects>Initializes an object of <c>string_field_translator</c> that holds a default constructed <c>Allocator</c> object as its allocator, and objects of <c>Sink</c> and <c>SkippingHandler</c> initialized with <c>std::forward&lt;SinkR>(sink)</c> and <c>std::forward&lt;SkippingHandlerR>(handle_skipping)</c> as the field translator sink object and the skipping handler object respectively.</effects>
            <remark>This constructor shall not participate in overload resolution unless <c>std::is_base_of_v&lt;string_field_translator&lt;Sink, Ch, Tr, Allocator, SkippingHandler>, std::decay_t&lt;SinkR>></c> is <c>false</c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class SinkR, class SkippingHandlerR = SkippingHandler>
  string_field_translator(
    std::allocator_arg_t, const Allocator&amp; alloc, SinkR&amp;&amp; sink,
    SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>());
            </code>
            <requires>Both of <c>std::is_constructible_v&lt;Sink, SinkR&amp;&amp;></c> and <c>std::is_constructible_v&lt;SkippingHandler, SkippingHandlerR&amp;&amp;></c> shall be <c>true</c>.</requires>
            <effects>Initializes an object of <c>string_field_translator</c> that holds objects of <c>Allocator</c>, <c>Sink</c> and <c>SkippingHandler</c> initialized with <c>alloc</c>, <c>std::forward&lt;SinkR>(sink)</c> and <c>std::forward&lt;SkippingHandlerR>(handle_skipping)</c> as the allocator, the field translator sink object and the skipping handler object respectively.</effects>
          </code-item>

          <code-item>
            <code>
string_field_translator(const string_field_translator&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>Sink</c> and <c>SkippingHandler</c> shall be <c>CopyConstructible</c>.</requires>
            <effects>Initializes an object of <c>string_field_translator</c> that holds an allocator object, a field translator sink object and a skipping handler object initialized with lvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;Sink> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;SkippingHandler></c>.</remark>
          </code-item>

          <code-item>
            <code>
string_field_translator(string_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Initializes an object of <c>string_field_translator</c> that holds an allocator object, a field translator sink object, and a skipping handler object initialized with xvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;Sink> &amp;&amp; std::is_nothrow_move_constructible_v&lt;SkippingHandler></c>.
                    If exits via an exception, <c>other</c> will be left in a valid but unspecified state.</remark>
          </code-item>
        </section>

        <section id="string_field_translator.allocator">
          <name><c>string_field_translator</c> allocator access</name>
          <code-item>
            <code>
allocator_type get_allocator() const noexcept;
            </code>
            <returns>A copy of the allocator object used to construct the string.</returns>
          </code-item>
        </section>

        <section id="string_field_translator.handler">
          <name><c>string_field_translator</c> handler access</name>
          <code-item>
            <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler()       noexcept;
            </code>
            <returns>A reference of the skipping handler held by <c>*this</c>.</returns>
          </code-item>
        </section>

        <section id="string_field_translator.inv">
          <name><c>string_field_translator</c> invocation</name>
          <code-item>
            <code>
void operator()(const Ch* begin, const Ch* end);
            </code>
            <effects>Puts <c>std::basic_string&lt;Ch, Tr, Allocator>(begin, end, get_allocator())</c> into the field translator sink.</effects>
          </code-item>

          <code-item>
            <code>
void operator()(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; value);
            </code>
            <effects>If <c>value.get_allocator() == get_allocator()</c>, puts <c>std::move(value)</c> into the field translator sink. Otherwise, calls <c>(*this)(value.c_str(), value.c_str() + value.size())</c>.</effects>
          </code-item>

          <code-item>
            <code>
void operator()();
            </code>
            <effects>Evaluates <c>invoke_typing_as&lt;value_type>(get_skipping_handler())</c> and puts the result into the field translator sink.</effects>
          </code-item>
        </section>
      </section>

      <section id="string_view_field_translator">
        <name>Class template <c>string_view_field_translator</c></name>

        <codeblock>
namespace commata {
  template &lt;class Sink, class Ch, class Tr = std::char_traits&lt;Ch>,
            class SkippingHandler = fail_if_skipped>
    class string_view_field_translator {
  public:
    using value_type = std::basic_string_view&lt;Ch, Tr>;
    using skipping_handler_type = SkippingHandler;

    <c>// <n><xref id="string_view_field_translator.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class SinkR, class SkippingHandlerR = SkippingHandler>
      explicit string_view_field_translator(
        SinkR&amp;&amp; sink, SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>());
    string_view_field_translator(const string_view_field_translator&amp;  other) noexcept(<nc>see below</nc>);
    string_view_field_translator(      string_view_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~string_view_field_translator();

    <c>// <n><xref id="string_view_field_translator.handler"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler()       noexcept;

    <c>// <n><xref id="string_view_field_translator.inv"/>, invocation:</n></c>
    void operator()(const Ch* begin, const Ch* end);
    void operator()();
  };
}
        </codeblock>

        <p>The <c>string_view_field_translator</c> class template provides a simple implementation for the standard string view type that meets the <c>BodyFieldScanner</c> requirements (<xref id="body_field_scanner.requirements"/>) whose target type is <c>std::basic_string_view&lt;Ch, Tr></c>.</p>
        <p><c>Sink</c> shall be a <c>FieldTranslatorSink</c> type for <c>std::basic_string_view&lt;Ch, Tr></c> (<xref id="field_translator_sink.requirements"/>).
          The template parameter <c>SkippingHandler</c> shall be a <c>SkippingHandler</c> type for the type <c>std::basic_string_view&lt;Ch, Tr></c> (<xref id="skipping_handler.requirements"/>).</p>
        <p><span class="note">A range referenced by a <c>basic_string_view</c> objects put to a <c>Sink</c> object by an object of <c>string_view_field_translator</c> will be invalidated soon after being put.
           Therefore, <c>Sink</c> objects should not store received ranges to a store that remains alive after the putting operation.</span></p>

        <section id="string_view_field_translator.cons">
          <name><c>string_view_field_translator</c> construct/copy/destroy</name>
          <code-item>
            <code>
template &lt;class SinkR, class SkippingHandlerR = SkippingHandler>
  explicit string_view_field_translator(
    SinkR&amp;&amp; sink, SkippingHandlerR&amp;&amp; handle_skipping = std::decay_t&lt;SkippingHandlerR>());
            </code>
            <requires>Both of <c>std::is_constructible_v&lt;Sink, SinkR&amp;&amp;></c> and <c>std::is_constructible_v&lt;SkippingHandler, SkippingHandlerR&amp;&amp;></c> shall be <c>true</c>.</requires>
            <effects>Initializes an object of <c>string_field_translator</c> that holds objects of <c>Sink</c> and <c>SkippingHandler</c> initialized with <c>std::forward&lt;SinkR>(sink)</c> and <c>std::forward&lt;SkippingHandlerR>(handle_skipping)</c> as the field translator sink object and the skipping handler object respectively.</effects>
            <remark>This constructor shall not participate in overload resolution unless <c>std::is_base_of_v&lt;string_view_field_translator&lt;Sink, Ch, Tr, SkippingHandler>, std::decay_t&lt;SinkR>></c> is <c>false</c>.</remark>
          </code-item>

          <code-item>
            <code>
string_view_field_translator(const string_view_field_translator;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>Sink</c> and <c>SkippingHandler</c> shall be <c>CopyConstructible</c>.</requires>
            <effects>Initializes an object of <c>string_view_field_translator</c> that holds a field translator sink object and a skipping handler object initialized with lvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible_v&lt;Sink> &amp;&amp; std::is_nothrow_copy_constructible_v&lt;SkippingHandler></c>.</remark>
          </code-item>

          <code-item>
            <code>
string_view_field_translator(string_view_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Initializes an object of <c>string_view_field_translator</c> that holds a field translator sink object and a skipping handler object initialized with xvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible_v&lt;Sink> &amp;&amp; std::is_nothrow_move_constructible_v&lt;SkippingHandler></c>.
                    If exits via an exception, <c>other</c> will be left in a valid but unspecified state.</remark>
          </code-item>
        </section>

        <section id="string_view_field_translator.handler">
          <name><c>string_view_field_translator</c> handler access</name>
          <code-item>
            <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler()       noexcept;
            </code>
            <returns>A reference of the skipping handler held by <c>*this</c>.</returns>
          </code-item>
        </section>

        <section id="string_view_field_translator.inv">
          <name><c>string_view_field_translator</c> invocation</name>
          <code-item>
            <code>
void operator()(const Ch* begin, const Ch* end);
            </code>
            <effects>Puts <c>std::basic_string_view&lt;Ch, Tr>(begin, end - begin)</c> into the field translator sink.</effects>
          </code-item>

          <code-item>
            <code>
void operator()();
            </code>
            <effects>Evaluates <c>invoke_typing_as&lt;value_type>(get_skipping_handler())</c> and puts the result into the field translator sink.</effects>
          </code-item>
        </section>
      </section>

      <section id="scan.builtin.body_field_scanners.creation">
        <name>Creation of default body field scanners</name>

        <p>In this subclause, following terms and notations are used.</p>
        <ul>
          <li>A type <c>S</c> is <n>deemed to be an acceptable sink</n> of type <c>T</c> if:
              <ul>
                <li><c>std::iterator_traits&lt;S>::iterator_category</c> is a type equal to <c>std::output_iterator_tag</c>, <c>std::forward_iterator_tag</c>, or their derived type; or</li>
                <li><c>s(t)</c> is a valid expression where <c>s</c> is an lvalue of <c>S</c> and <c>t</c> is an rvalue of <c>T</c>.</li>
              </ul></li>
          <li>A type <c><n>DEDUCED_SKIPPING_HANDLER_TYPE</n>&lt;T, U></c> for types <c>T</c> and <c>U</c> is defined as follows:
              <ul>
                <li>if <c>std::is_base_of_v&lt;replacement_fail_t, std::decay_t&lt;U>></c> is <c>true</c>, <c>fail_if_skipped</c>,</li>
                <li>otherwise, if <c>std::is_base_of_v&lt;replacement_ignore_t, std::decay_t&lt;U>></c> is <c>true</c>, <c>ignore_if_skipped</c>,</li>
                <li>otherwise, if <c>!std::is_base_of_v&lt;replace_if_skipped&lt;T>, std::decay_t&lt;U>> &amp;&amp; std::is_constructible_v&lt;replace_if_skipped&lt;T>, U></c> is <c>true</c>, <c>replace_if_skipped&lt;T></c>,</li>
                <li>otherwise, <c>std::decay_t&lt;U></c>.</li>
              </ul></li>
          <li>A type <c><n>DEDUCED_CONVERSION_ERROR_HANDLER_TYPE</n>&lt;T, U></c> for types <c>T</c> and <c>U</c> is defined as follows:
              <ul>
                <li>if <c>std::is_base_of_v&lt;replacement_fail_t, std::decay_t&lt;U>></c> is <c>true</c>, <c>fail_if_conversion_failed</c>,</li>
                <li>otherwise, if <c>std::is_base_of_v&lt;replacement_ignore_t, std::decay_t&lt;U>></c> is <c>true</c>, <c>ignore_if_conversion_failed</c>,</li>
                <li>otherwise, if <c>!std::is_base_of_v&lt;replace_if_conversion_failed&lt;T>, std::decay_t&lt;U>> &amp;&amp; std::is_constructible_v&lt;replace_if_conversion_failed&lt;T>, U></c> is <c>true</c>, <c>replace_if_conversion_failed&lt;T></c>,</li>
                <li>otherwise, <c>std::decay_t&lt;U></c>.</li>
              </ul></li>
          <li>For a template parameter pack <c>As</c>, <c>As...[i]</c> denotes the <c>i</c>-th (zero-based) of <c>As...</c>.</li>
          <li>An expression <c><n>INSERTER</n>(s)</c> for an lvalue <c>s</c> of a cv-unqualified type <c>S</c> is defined as follows:
              <ul>
                <li>if <c>s.push_back(std::declval&lt;S::value_type>())</c> is well-formed when treated as an unevaluated operand, <c>std::back_inserter(s)</c>,</li>
                <li>otherwise, if <c>s.insert(s.end(), std::declval&lt;S::value_type>())</c> is well-formed when treated as an unevaluated operand, <c>std::inserter(s, s.end())</c>,</li>
                <li>otherwise, the program is ill-formed.</li>
              </ul></li>
        </ul>

        <code-item>
          <code>
template &lt;class T, class SinkR, class... Appendices>
  <nc>see below</nc> make_field_translator(SinkR&amp;&amp; sink, Appendices&amp;&amp;... appendices);
          </code>
          <preface>Let <c>Sink</c> be <c>std::decay_t&lt;SinkR></c>.</preface>
          <effects><p>Equivalent to:</p>
                   <code>return <n>R</n>(std::forward&lt;SinkR>(sink), std::forward&lt;Appendices>(appendices)...);</code>
                   <p>where <c><n>R</n></c> is a type decided as follows:</p>
                   <ul>
                     <li>if <c>T</c> is a default translatable string type:
                       <ul>
                         <li>if <c>sizeof...(Appendices)</c> is <c>0</c>, <c>string_field_translator&lt;Sink, typename T::value_type, typename T::traits_type, typename T::allocator_type></c>,</li>
                         <li>otherwise, <c>string_field_translator&lt;Sink, typename T::value_type, typename T::traits_type, typename T::allocator_type, <nc>DEDUCED_SKIPPING_HANDLER_TYPE</nc>&lt;T, Appendices...[0]>></c>.</li>
                       </ul>
                     </li>
                     <li>otherwise, if <c>T</c> is a default translatable string view type:
                       <ul>
                         <li>if <c>sizeof...(Appendices)</c> is <c>0</c>, <c>string_view_field_translator&lt;Sink, typename T::value_type, typename T::traits_type></c>,</li>
                         <li>otherwise, <c>string_view_field_translator&lt;Sink, typename T::value_type, typename T::traits_type, <nc>DEDUCED_SKIPPING_HANDLER_TYPE</nc>&lt;T, Appendices...[0]>></c>.</li>
                       </ul>
                     </li>
                     <li>otherwise, if <c>sizeof...(Appendices)</c> is greater than <c>0</c> and <c>std::remove_reference_t&lt;Appendices...[0]></c> is possibly cv-qualified <c>std::locale</c> or its derived type:
                       <ul>
                         <li>if <c>sizeof...(Appendices)</c> is <c>1</c>, <c>locale_based_arithmetic_field_translator&lt;Sink, T></c>,</li>
                         <li>otherwise, if <c>sizeof...(Appendices)</c> is <c>2</c>, <c>locale_based_arithmetic_field_translator&lt;Sink, T, <nc>DEDUCED_SKIPPING_HANDLER_TYPE</nc>&lt;T, Appendices...[1]>></c>,</li>
                         <li>otherwise, <c>locale_based_arithmetic_field_translator&lt;Sink, T, <nc>DEDUCED_SKIPPING_HANDLER_TYPE</nc>&lt;T, Appendices...[1]>, <nc>DEDUCED_CONVERSION_ERROR_HANDLER_TYPE</nc>&lt;T, Appendices...[2]>></c>.</li>
                       </ul>
                     </li>
                     <li>otherwise:
                       <ul>
                         <li>if <c>sizeof...(Appendices)</c> is <c>0</c>, <c>arithmetic_field_translator&lt;Sink, T></c>,</li>
                         <li>otherwise, if <c>sizeof...(Appendices)</c> is <c>1</c>, <c>arithmetic_field_translator&lt;Sink, T, <nc>DEDUCED_SKIPPING_HANDLER_TYPE</nc>&lt;T, Appendices...[0]>></c>,</li>
                         <li>otherwise, <c>arithmetic_field_translator&lt;Sink, T, <nc>DEDUCED_SKIPPING_HANDLER_TYPE</nc>&lt;T, Appendices...[0]>, <nc>DEDUCED_CONVERSION_ERROR_HANDLER_TYPE</nc>&lt;T, Appendices...[1]>></c>.</li>
                       </ul>
                     </li>
                   </ul>
          </effects>
          <remark>This overload shall not participate in overload resolution unless <c>T</c> is a default translatable type and <c>Sink</c> is deemed to be an acceptable sink of <c>T</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class T, class Allocator, class SinkR, class... Appendices>
  <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                  SinkR&amp;&amp; sink, Appendices&amp;&amp;... appendices);
          </code>
          <preface>Let <c>Sink</c> be <c>std::decay_t&lt;SinkR></c>.</preface>
          <effects><p>Equivalent to:</p>
                   <code>return <n>R</n>(std::allocator_arg, alloc, std::forward&lt;SinkR>(sink), std::forward&lt;Appendices>(appendices)...);</code>
                   <p>where <c><n>R</n></c> is a type decided as follows:</p>
                   <ul>
                     <li>if <c>sizeof...(Appendices)</c> is <c>0</c>, <c>string_field_translator&lt;Sink, typename T::value_type, typename T::traits_type, typename T::allocator_type></c>,</li>
                     <li>otherwise, <c>string_field_translator&lt;Sink, typename T::value_type, typename T::traits_type, typename T::allocator_type, <nc>DEDUCED_SKIPPING_HANDLER_TYPE</nc>&lt;T, Appendices...[0]>></c>.</li>
                   </ul>
          </effects>
          <remark>This overload shall not participate in overload resolution unless <c>T</c> is a default translatable string type with its <c>allocator_type</c> member typedef naming <c>Allocator</c>, and <c>Sink</c> is deemed to be an acceptable sink of <c>T</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Container, class... Appendices>
  <nc>see below</nc> make_field_translator(Container&amp; values, Appendices&amp;&amp;... appendices);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return make_field_translator&lt;typename Container::value_type>(
         <n>INSERTER</n>(values), std::forward&lt;Appendices>(appendices)...);</code>
          </effects>
          <remark>This overload shall not participate in overload resolution unless <c>Container::value_type</c> is either of a default translatable arithmetic type or a default translatable string type, and <c><n>INSERTER</n>(values)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Allocator, class Container, class... Appendices>
  <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                  Container&amp; values, Appendices&amp;&amp;... appendices);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return make_field_translator&lt;typename Container::value_type>(
         std::allocator_arg, alloc,
         <n>INSERTER</n>(values), std::forward&lt;Appendices>(appendices)...);</code>
          </effects>
          <remark>This overload shall not participate in overload resolution unless <c>Container::value_type</c> is a default translatable string type and <c><n>INSERTER</n>(values)</c> is well-formed when treated as an unevaluated operand.</remark>
        </code-item>
      </section>
    </section>
  </section>
</section>

<section id="pull">
  <name>Pull parsing</name>

  <section id="pull.general">
    <name>General</name>

    <p>Commata offers some tools to perform <n>pull parsing</n>, in which the users can immediately access the results of parsing text tables
       with the control of the execution flow of parsing held by the users themselves and with the knowledge of where in the text table they are processing.</p>
  </section>

  <section id="hpp.table_pull.syn">
    <name>Header <c>"commama/table_pull.hpp"</c> synopsis</name>

    <codeblock>
#include &lt;memory>
#include &lt;string_view>
#include &lt;type_traits>

namespace commata {

  enum class primitive_table_pull_state : <nc>unspecified</nc> {
    before_parse        = <nc>unspecified</nc>,
    eof                 = <nc>unspecified</nc>,
    start_buffer        = <nc>unspecified</nc>,
    end_buffer          = <nc>unspecified</nc>,
    start_record        = <nc>unspecified</nc>,
    end_record          = <nc>unspecified</nc>,
    empty_physical_line = <nc>unspecified</nc>,
    update              = <nc>unspecified</nc>,
    finalize            = <nc>unspecified</nc>
  };

  <c>// <n><xref id="primitive_table_pull_handle"/>, primitive_table_pull_handle:</n></c>
  enum class primitive_table_pull_handle : <nc>see below</nc>;

  constexpr primitive_table_pull_handle operator|(
    primitive_table_pull_handle left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle&amp; operator|=(
    primitive_table_pull_handle&amp; left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle operator&amp;(
    primitive_table_pull_handle left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle&amp; operator&amp;=(
    primitive_table_pull_handle&amp; left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle operator^(
    primitive_table_pull_handle left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle&amp; operator^=(
    primitive_table_pull_handle&amp; left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle operator~(primitive_table_pull_handle handle) noexcept;

  <c>// <n><xref id="primitive_table_pull"/>, primitive_table_pull:</n></c>
  template &lt;class TableSource,
            primitive_table_pull_handle Handle = primitive_table_pull_handle::all,
            class Allocator = std::allocator&lt;typename TableSource::char_type>>
    class primitive_table_pull;

  enum class table_pull_state : <nc>unspecified</nc> {
    before_parse = <nc>unspecified</nc>,
    eof          = <nc>unspecified</nc>,
    field        = <nc>unspecified</nc>,
    record_end   = <nc>unspecified</nc>
  };

  <c>// <n><xref id="table_pull"/>, table_pull:</n></c>
  template &lt;class TableSource,
            class Allocator = std::allocator&lt;typename TableSource::char_type>>
    class table_pull;

  template &lt;class TableSource, class... Appendices>
    table_pull&lt;std::decay_t&lt;TableSource>>
      make_table_pull(TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
  template &lt;class TableSource, class Allocator, class... Appendices>
    table_pull&lt;std::decay_t&lt;TableSource>, Allocator>
      make_table_pull(std::allocator_arg_t, const Allocator&amp; alloc,
                      TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
}
    </codeblock>
  </section>

  <section id="primitive_table_pull_handle">
    <name>Type <c>primitive_table_pull_handle</c></name>

    <codeblock>
namespace commata {
  enum class primitive_table_pull_handle : <nc>see below</nc> {
    start_buffer        = <nc>unspecified</nc>,
    end_buffer          = <nc>unspecified</nc>,
    empty_physical_line = <nc>unspecified</nc>,
    start_record        = <nc>unspecified</nc>,
    end_record          = <nc>unspecified</nc>,
    update              = <nc>unspecified</nc>,
    finalize            = <nc>unspecified</nc>,
    all                 = -1   <c>// all one bit</c>
  };

  <c>// <n><xref id="primitive_table_pull_handle.ops"/>, operations:</n></c>
  constexpr primitive_table_pull_handle operator|(
    primitive_table_pull_handle left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle&amp; operator|=(
    primitive_table_pull_handle&amp; left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle operator&amp;(
    primitive_table_pull_handle left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle&amp; operator&amp;=(
    primitive_table_pull_handle&amp; left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle operator^(
    primitive_table_pull_handle left, primitive_table_pull_handle right) noexcept;
  constexpr primitive_table_pull_handle&amp; operator^=(
    primitive_table_pull_handle&amp; left, primitive_table_pull_handle right);
  constexpr primitive_table_pull_handle operator~(primitive_table_pull_handle handle) noexcept;
}
    </codeblock>

    <p>The enumarated type <c>primitive_table_pull_handle</c> defines several integral values with single one bit and with all one bit, which is used to configure the <c>primitive_table_pull</c> objects (<xref id="primitive_table_pull"/>).
       Its underlying type is an unspecified unsigned integer type.</p>

    <section id="primitive_table_pull_handle.ops">
      <name><c>primitive_table_pull_handle</c> operations</name>
      <p>In this subclause, <c>U</c> denotes <c>std::underlying_type_t&lt;primitive_table_pull_handle></c>.</p>
      <code-item>
        <code>
constexpr primitive_table_pull_handle operator|(
  primitive_table_pull_handle left, primitive_table_pull_handle right) noexcept;
        </code>
        <effects>Equivalent to: <c>return primitive_table_pull_handle(static_cast&lt;U>(left) | static_cast&lt;U>(right));</c></effects>
      </code-item>
      <code-item>
        <code>
constexpr primitive_table_pull_handle&amp; operator|=(
  primitive_table_pull_handle&amp; left, primitive_table_pull_handle right) noexcept;
        </code>
        <effects>Equivalent to: <c>return left = left | right;</c></effects>
      </code-item>
      <code-item>
        <code>
constexpr primitive_table_pull_handle operator&amp;(
  primitive_table_pull_handle left, primitive_table_pull_handle right) noexcept;
        </code>
        <effects>Equivalent to: <c>return primitive_table_pull_handle(static_cast&lt;U>(left) &amp; static_cast&lt;U>(right));</c></effects>
      </code-item>
      <code-item>
        <code>
constexpr primitive_table_pull_handle&amp; operator&amp;=(
  primitive_table_pull_handle&amp; left, primitive_table_pull_handle right) noexcept;
        </code>
        <effects>Equivalent to: <c>return left = left &amp; right;</c></effects>
      </code-item>
      <code-item>
        <code>
constexpr primitive_table_pull_handle operator^(
  primitive_table_pull_handle left, primitive_table_pull_handle right) noexcept;
        </code>
        <effects>Equivalent to: <c>return primitive_table_pull_handle(static_cast&lt;U>(left) ^ static_cast&lt;U>(right));</c></effects>
      </code-item>
      <code-item>
        <code>
constexpr primitive_table_pull_handle&amp; operator^=(
  primitive_table_pull_handle&amp; left, primitive_table_pull_handle right) noexcept;
        </code>
        <effects>Equivalent to: <c>return left = left ^ right;</c></effects>
      </code-item>
      <code-item>
        <code>
constexpr primitive_table_pull_handle operator~(primitive_table_pull_handle handle) noexcept;
        </code>
        <effects>Equivalent to: <c>return primitive_table_pull_handle(~static_cast&lt;U>(handle));</c></effects>
      </code-item>
    </section>
  </section>

  <section id="primitive_table_pull">
    <name>Class template <c>primitive_table_pull</c></name>

    <codeblock>
namespace commata {
  template &lt;class TableSource,
            primitive_table_pull_handle Handle = primitive_table_pull_handle::all,
            class Allocator = std::allocator&lt;typename TableSource::char_type>>
    class primitive_table_pull {
  public:
    using char_type      = typename TableSource::char_type;
    using allocator_type = Allocator;
    using size_type      = std::size_t;

    <c>// <n><xref id="primitive_table_pull.physical_position_available"/>, physical position availability:</n></c>
    static constexpr bool physical_position_available = <nc>see below</nc>;
    static constexpr std::size_t npos = -1;

    <c>// <n><xref id="primitive_table_pull.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class TableSourceR>
      explicit primitive_table_pull(TableSourceR&amp;&amp; in,
                                    std::size_t buffer_size = 0);
    template &lt;class TableSourceR>
      primitive_table_pull(std::allocator_arg_t, const Allocator&amp; alloc, TableSourceR&amp;&amp; in,
                           std::size_t buffer_size = 0);
    primitive_table_pull(primitive_table_pull&amp;&amp; other) noexcept;
   ~primitive_table_pull();

    <c>// <n><xref id="primitive_table_pull.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="primitive_table_pull.tweaks"/>, tweaks:</n></c>
    bool is_discarding_data() const noexcept;
    primitive_table_pull&amp; set_discarding_data(bool b = true) noexcept;

    <c>// <n><xref id="primitive_table_pull.inv"/>, invocation:</n></c>
    primitive_table_pull&amp; operator()();

    <c>// <n><xref id="primitive_table_pull.state"/>, state:</n></c>
    primitive_table_pull_state state() const noexcept;
    explicit operator bool() const noexcept;
    std::pair&lt;std::size_t, std::size_t> get_physical_position() const noexcept(<nc>see below</nc>);
    char_type*       operator[](size_type i);
    const char_type* operator[](size_type i) const;
    char_type*       at(size_type i);
    const char_type* at(size_type i) const;
    size_type data_size() const noexcept;
    size_type max_data_size() const noexcept;
  };

  template &lt;class TableSource, class... Args>
    primitive_table_pull(TableSource, Args...) -> primitive_table_pull&lt;TableSource>;
  template &lt;class TableSource, class Allocator, class... Args>
    primitive_table_pull(std::allocator_arg_t, Allocator, TableSource, Args...)
      -> primitive_table_pull&lt;TableSource, primitive_table_pull_handle::all, Allocator>;
}
    </codeblock>

    <p>The class template <c>primitive_table_pull</c> describes the low-level pull parser objects for text tables (<xref id="definitions.text_table"/>).</p>
    <p>The template parameter <c>TableSource</c> shall meet the <c>TableSource</c> requirements (<xref id="table_source.requirements"/>) for a char-like type.
       The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements for the type <c>TableSource::char_type</c>.</p>
    <p>An object of an instantiation of it holds two objects:</p>
    <ul>
      <li>a table parser object (<xref id="table_parser.requirements"/>), whose tied table handler object recognizes each invocation on its member functions
          <c>start_buffer</c>, <c>end_buffer</c>, <c>start_record</c>, <c>end_record</c>, <c>empty_physical_line</c>, <c>update</c> and <c>finalize</c> as a <n>parsing event</n>
          and enqueues it into the event queue below, and</li>
      <li>an <n>event queue</n>, which is a queue of the parsing events, and which is enqueued on the back by the tied table handler object of the table parser object and dequeued by the user on the front.</li>
    </ul>
    <p>The user of this class template can configure the table handler object to ignore some parsing event with the template parameter <c>Handle</c>.
       If <c>(Handle &amp; primitive_table_pull_handle::start_buffer) == primitive_table_pull_handle(0)</c> is <c>true</c>, it shall not recognize any invocation of <c>start_buffer</c> as a parsing event and shall not enqueue anything with the invocation.
       All other enumerators but <c>primitive_table_pull_handle::all</c> shall work similarly.
       <c>primitive_table_pull_handle::all</c> has a representation of all one bits and is intended to be used to express &#x2018;ignore none&#x2019;.</p>

    <section id="primitive_table_pull.physical_position_available">
      <name><c>primitive_table_pull</c> physical position availability</name>
      <code-item>
        <code>
static constexpr bool physical_position_available = <nc>see below</nc>;
        </code>
        <remark>The expression in the right of <c>=</c> in the initializer shall be <c>true</c>
                if the internal parser implements the optional operation <c>get_physical_position</c> (<xref id="table_parser.requirements"/>);
                <c>false</c> otherwise.</remark>
      </code-item>
    </section>

    <section id="primitive_table_pull.cons">
      <name><c>primitive_table_pull</c> construct/copy/destroy</name>
      <code-item>
        <code>
template &lt;class TableSourceR>
  explicit primitive_table_pull(TableSourceR&amp;&amp; in,
                                std::size_t buffer_size = 0);
        </code>
        <requires><c>std::is_default_constructible_v&lt;Allocator></c> shall be <c>true</c>.</requires>
        <effects>First default constructs an <c>Allocator</c> object <c>a</c>.
                 Creates the event queue that does dynamic memory allocation with <c>a</c>.
                 Creates a table handler object <c>h</c> configured to enqueue events into the event queue above and to use <c>a</c> to allocate buffers and refers <c>buffer_size</c> as a hint of the size (that is, the number of characters) to allocate buffers,
                 thus whose type is deemed to have buffer control.
                 Then constructs the table parser object with <c>std::forward&lt;TableSourceR>(in)(std::move(h))</c>.
                 <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.</effects>
        <postcondition><c>is_discarding_data()</c> shall return <c>false</c>.</postcondition>
        <remark>This constructor shall not participate in overload resolution unless <c>std::is_base_of_v&lt;TableSource, std::decay_t&lt;TableSourceR>> &amp;&amp; !std::is_base_of_v&lt;table_pull, std::decay_t&lt;TableSourceR>></c> is <c>true</c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class TableSourceR>
  primitive_table_pull(std::allocator_arg_t, const Allocator&amp; alloc, TableSourceR&amp;&amp; in,
                       std::size_t buffer_size = 0);
        </code>
        <effects>First constructs an <c>Allocator</c> object <c>a</c> with <c>alloc</c>.
                 Creates the event queue that does dynamic memory allocation with <c>a</c>.
                 Creates a table handler object <c>h</c> configured to enqueue events into the event queue above and to use <c>a</c> to allocate buffers and refers <c>buffer_size</c> as a hint of the size (that is, the number of characters) to allocate buffers,
                 thus whose type is deemed to have buffer control.
                 Then constructs the table parser object with <c>std::forward&lt;TableSourceR>(in)(std::move(h))</c>.
                 <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.</effects>
        <postcondition><c>is_discarding_data()</c> shall return <c>false</c>.</postcondition>
        <remark>This constructor shall not participate in overload resolution unless <c>std::is_base_of_v&lt;TableSource, std::decay_t&lt;TableSourceR>></c> is <c>true</c>.</remark>
      </code-item>

      <code-item>
        <code>
primitive_table_pull(primitive_table_pull&amp;&amp; other) noexcept;
        </code>
        <effects>Initializes an object of <c>primitive_table_pull</c> that takes over all the internal state of <c>other</c>.</effects>
      </code-item>
    </section>

    <section id="primitive_table_pull.allocator">
      <name><c>primitive_table_pull</c> allocator access</name>

      <code-item>
        <code>
allocator_type get_allocator() const noexcept;
        </code>
        <returns>A copy of the allocator object used by <c>*this</c>.</returns>
      </code-item>
    </section>

    <section id="primitive_table_pull.tweaks">
      <name><c>primitive_table_pull</c> tweaks</name>

      <code-item>
        <code>
bool is_discarding_data() const noexcept;
        </code>
        <returns>Whether <c>*this</c> collects data of events and makes them accessible with <c>operator[]</c> (<c>false</c>) or not (otherwise).</returns>
      </code-item>

      <code-item>
        <code>
primitive_table_pull&amp; set_discarding_data(bool b = true) noexcept;
        </code>
        <effects>Sets whether <c>*this</c> collects data of events and makes them accessible with <c>operator[]</c> (if <c>b</c> is <c>false</c>) or not (otherwise).</effects>
        <returns><c>*this</c>.</returns>
        <note>Setting this to <c>true</c> purely reduces the functionality of <c>*this</c>, but might improve performance.</note>
      </code-item>
    </section>

    <section id="primitive_table_pull.inv">
      <name><c>primitive_table_pull</c> invocation</name>

      <code-item>
        <code>
primitive_table_pull&amp; operator()();
        </code>
        <effects>If <c>state() == primitive_table_pull_state::eof</c> is <c>true</c>, returns without doing anything.
                 Otherwise, first dequeues an event from the event queue on the front if the queue is not empty.
                 Then iteratively calls <c>p()</c> to enqueue parsing events into the event queue on the back while the event queue is empty
                 where <c>p</c> is the table parser held by <c>*this</c>.</effects>
        <returns><c>*this</c>.</returns>
        <throws><c>parse_error</c> (<xref id="parse_error"/>) or any exception thrown by the table parser and the allocator.</throws>
        <remark>If exits via an exception, <c>*this</c> will be left in a valid but unspecified state.</remark>
      </code-item>
    </section>

    <section id="primitive_table_pull.state">
      <name><c>primitive_table_pull</c> state</name>

      <code-item>
        <code>
primitive_table_pull_state state() const noexcept;
        </code>
        <returns>A value of <c>primitive_table_pull_state</c> that tells the current status of <c>*this</c> as shown in <xref id="table.primitive_table_pull.state"/>.
                 In <xref id="table.primitive_table_pull.state"/>, <c>h</c> denotes the table handler object held by <c>*this</c>.
                 &#x2018;Maximum data size&#x2019; column shows the return value of <c>data_size()</c> if the current event was queued while <c>is_discarding_data()</c> was <c>false</c>.</returns>

        <table id="table.primitive_table_pull.state">
          <caption>The meanings of the values <c>state()</c> returns</caption>
          <col width="5"/><col width="19"/><col width="95"/><col width="12"/>

          <tr>
            <th>#</th>
            <th>Value</th>
            <th>The current status of <c>*this</c></th>
            <th>Maximum data size</th>
          </tr>

          <tr>
            <td><c>(1)</c></td>
            <td><c>before_parse</c></td>
            <td><c>operator()</c> has never been called yet.</td>
            <td>0</td>
          </tr>

          <tr>
            <td><c>(2)</c></td>
            <td><c>eof</c></td>
            <td>The table parser has already consumed all content of its tied table source.</td>
            <td>0</td>
          </tr>

          <tr>
            <td><c>(3)</c></td>
            <td><c>start_buffer</c></td>
            <td>The front of the event queue is the invocation of <c>start_buffer</c> on <c>h</c>.
                The arguments of the invocation are available as <c>(*this)[0]</c> and <c>(*this)[1]</c> in order
                if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
            <td>2</td>
          </tr>

          <tr>
            <td><c>(4)</c></td>
            <td><c>end_buffer</c></td>
            <td>The front of the event queue is the invocation of <c>end_buffer</c> on <c>h</c>.
                The argument of the invocation is available as <c>(*this)[0]</c>
                if and only if the event was queued while <c>is_discarding_data()</c> is <c>false</c>.
                All pointers that have been returned by <c>operator[]</c> will be invalidated with the next call of <c>operator()</c>.</td>
            <td>1</td>
          </tr>

          <tr>
            <td><c>(5)</c></td>
            <td><c>empty_physical_line</c></td>
            <td>The front of the event queue is the invocation of <c>empty_physical_line</c> on <c>h</c>.
                The argument of the invocation is available as <c>(*this)[0]</c>
                if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
            <td>1</td>
          </tr>

          <tr>
            <td><c>(6)</c></td>
            <td><c>start_record</c></td>
            <td>The front of the event queue is the invocation of <c>start_record</c> on <c>h</c>.
                The argument of the invocation is available as <c>(*this)[0]</c>
                if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
            <td>1</td>
          </tr>

          <tr>
            <td><c>(7)</c></td>
            <td><c>end_record</c></td>
            <td>The front of the event queue is the invocation of <c>end_record</c> on <c>h</c>.
                The argument of the invocation is available as <c>(*this)[0]</c>
                if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
            <td>1</td>
          </tr>

          <tr>
            <td><c>(8)</c></td>
            <td><c>update</c></td>
            <td>The front of the event queue is the invocation of <c>update</c> on <c>h</c>.
                The arguments of the invocation are available as <c>(*this)[0]</c> and <c>(*this)[1]</c> in order
                if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
            <td>2</td>
          </tr>

          <tr>
            <td><c>(9)</c></td>
            <td><c>finalize</c></td>
            <td>The front of the event queue is the invocation of <c>finalize</c> on <c>h</c>.
                The arguments of the invocation are available as <c>(*this)[0]</c> and <c>(*this)[1]</c> in order
                if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
            <td>2</td>
          </tr>
        </table>
      </code-item>

      <code-item>
        <code>
explicit operator bool() const noexcept;
        </code>
        <returns><c>state() != primitive_table_pull_state::eof</c>.</returns>
      </code-item>

      <code-item>
        <code>
std::pair&lt;std::size_t, std::size_t> get_physical_position() const noexcept(<nc>see below</nc>);
        </code>
        <returns>If <c>physical_position_available</c> is <c>true</c>, <c>p.get_physical_position()</c> where <c>p</c> is the internal table parser object.
                 Otherwise, <c>std::make_pair(npos, npos)</c>.</returns>
        <throws>Nothing.</throws>
        <remark>The expression inside <c>noexcept</c> is <c>true</c> if <c>physical_position_available</c> is <c>false</c>.
                Otherwise, it is equivalent to <c>noexcept(p.get_physical_position()))</c> where <c>p</c> is the internal table parser object.</remark>
      </code-item>

      <code-item>
        <code>
char_type*       operator[](size_type i);
const char_type* operator[](size_type i) const;
        </code>
        <requires><c>i</c> shall be smaller than <c>data_size()</c>.</requires>
        <returns>The <c>i</c>-th (zero-based) argument value of the front of the event queue.</returns>
        <throws>Nothing.</throws>
      </code-item>

      <code-item>
        <code>
char_type*       at(size_type i);
const char_type* at(size_type i) const;
        </code>
        <throws><c>std::out_of_range</c> if <c>i >= data_size()</c>.</throws>
        <returns><c>(*this)[i]</c>.</returns>
      </code-item>

      <code-item>
        <code>
size_type data_size() const noexcept;
        </code>
        <returns>An integer value greater by one than the maximum value that can be passed to <c>operator[]</c>.</returns>
      </code-item>

      <code-item>
        <code>
size_type max_data_size() const noexcept;
        </code>
        <returns>The largest possible number that the member function <c>data_size</c> returns.</returns>
      </code-item>
    </section>
  </section>

  <section id="table_pull">
    <name>Class template <c>table_pull</c></name>

    <codeblock>
namespace commata {
  template &lt;class TableSource,
            class Allocator = std::allocator&lt;typename TableSource::char_type>>
    class table_pull {
  public:
    using char_type      = typename TableSource::char_type;
    using traits_type    = typename TableSource::traits_type;
    using allocator_type = Allocator;
    using view_type      = std::basic_string_view&lt;char_type, traits_type>;

    <c>// <n><xref id="table_pull.physical_position_available"/>, physical position availability:</n></c>
    static constexpr bool physical_position_available = <nc>see below</nc>;
    static constexpr std::size_t npos = -1;

    <c>// <n><xref id="table_pull.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class TableSourceR>
      explicit table_pull(TableSourceR&amp;&amp; in, std::size_t buffer_size = 0);
    template &lt;class TableSourceR>
      table_pull(std::allocator_arg_t, const Allocator&amp; alloc, TableSourceR&amp;&amp; in,
                 std::size_t buffer_size = 0);
    table_pull(table_pull&amp;&amp; other) noexcept;
   ~table_pull();

    <c>// <n><xref id="table_pull.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="table_pull.tweaks"/>, tweaks:</n></c>
    bool is_empty_physical_line_aware() const noexcept;
    table_pull&amp; set_empty_physical_line_aware(bool b = true) noexcept;

    <c>// <n><xref id="table_pull.inv"/>, invocation:</n></c>
    table_pull&amp; operator()(std::size_t n = 0);
    table_pull&amp; skip_record(std::size_t n = 0);

    <c>// <n><xref id="table_pull.state"/>, state:</n></c>
    table_pull_state state() const noexcept;
    explicit operator bool() const noexcept;
    std::pair&lt;std::size_t, std::size_t> get_physical_position() const noexcept(<nc>see below</nc>);
    std::pair&lt;std::size_t, std::size_t> get_position() const noexcept;
    const char_type* c_str() const noexcept;
    const view_type&amp; operator*() const noexcept;
    const view_type* operator->() const noexcept;

    <c>// <n><xref id="table_pull.mod"/>, in-place string value modification:</n></c>
    template &lt;class F> table_pull&amp; rewrite(F f);
  };

  template &lt;class TableSource, class... Args>
    table_pull(TableSource, Args...) -> table_pull&lt;TableSource>;
  template &lt;class TableSource, class Allocator, class... Args>
    table_pull(std::allocator_arg_t, Allocator, TableSource, Args...)
      -> table_pull&lt;TableSource, Allocator>;

  <c>// <n><xref id="table_pull.creation"/>, table_pull creation functions:</n></c>
  template &lt;class TableSource, class... Appendices>
    table_pull&lt;std::decay_t&lt;TableSource>>
      make_table_pull(TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
  template &lt;class TableSource, class Allocator, class... Appendices>
    table_pull&lt;std::decay_t&lt;TableSource>, Allocator>
      make_table_pull(std::allocator_arg_t, const Allocator&amp; alloc,
                      TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
}
    </codeblock>

    <p><c>table_pull</c> is another class template that describes pull parser objects for text tables (<xref id="definitions.text_table"/>) than <c>primitive_table_pull</c> (<xref id="primitive_table_pull"/>).
       It offers higher-level parsing functionality.</p>
    <p>The template parameter <c>TableSource</c> shall meet the <c>TableSource</c> requirements (<xref id="table_source.requirements"/>) for a char-like type.
       The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements for the type <c>TableSource::char_type</c>.</p>
    <p>An object of an instantiation of it holds a table parser object (<xref id="table_parser.requirements"/>) obtained from the table source object (<xref id="table_source.requirements"/>) passed to the constructor
       and performs field-wisely or record-wisely step-by-step parsing of a text table using it.
       Its user can retrieve the text values of the text fields through its <n>current string values</n>, which are null-terminated sequences of <c>TableSource::char_type</c>.</p>
    <p>An instance of <c>table_pull</c> meets the <c>ArithmeticConvertible</c> requirements (<xref id="arithmetic_convertible.requirements"/>) for <c>char_type</c>.</p>

    <section id="table_pull.physical_position_available">
      <name><c>table_pull</c> physical position availability</name>
      <code-item>
        <code>
static constexpr bool physical_position_available = <nc>see below</nc>;
        </code>
        <remark>The expression in the right of <c>=</c> in the initializer shall be <c>true</c>
                if the internal table parser implements the optional operation <c>get_physical_position</c> (<xref id="table_parser.requirements"/>);
                <c>false</c> otherwise.</remark>
      </code-item>
    </section>

    <section id="table_pull.cons">
      <name><c>table_pull</c> construct/copy/destroy</name>
      <code-item>
        <code>
template &lt;class TableSourceR>
  explicit table_pull(TableSourceR&amp;&amp; in, std::size_t buffer_size = 0);
        </code>
        <requires><c>std::is_default_constructible_v&lt;Allocator></c> shall be <c>true</c>.</requires>
        <effects>Initializes an object of <c>table_pull</c> with a default constructed <c>Allocator</c> object as its allocator object and with a table parser (<xref id="table_parser.requirements"/>) object created by invoking <c>operator()</c> on <c>std::forward&lt;TableSourceR>(in)</c>.
                 <c>buffer_size</c> serves as a hint to allocate buffers.
                 <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.</effects>
        <postcondition><c>is_empty_line_aware()</c> shall return <c>false</c>.</postcondition>
        <remark>This constructor shall not participate in overload resolution unless <c>std::is_base_of_v&lt;TableSource, std::decay_t&lt;TableSourceR>> &amp;&amp; !std::is_base_of_v&lt;table_pull, std::decay_t&lt;TableSourceR>></c> is <c>true</c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class TableSourceR>
  table_pull(std::allocator_arg_t, const Allocator&amp; alloc, TableSourceR&amp;&amp; in,
             std::size_t buffer_size = 0);
        </code>
        <effects>Initializes an object of <c>table_pull</c> with an allocator object constructed from <c>alloc</c> and with a table parser (<xref id="table_parser.requirements"/>) object created by invoking <c>operator()</c> on <c>std::forward&lt;TableSourceR>(in)</c>.
                 <c>buffer_size</c> serves as a hint to allocate buffers.
                 <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.</effects>
        <postcondition><c>is_empty_line_aware()</c> shall return <c>false</c>.</postcondition>
        <remark>This constructor shall not participate in overload resolution unless <c>std::is_base_of_v&lt;TableSource, std::decay_t&lt;TableSourceR>></c> is <c>true</c>.</remark>
      </code-item>

      <code-item>
        <code>
table_pull(table_pull&amp;&amp; other) noexcept;
        </code>
        <effects>Initializes an object of <c>table_pull</c> that takes over all the internal state of <c>other</c>.</effects>
      </code-item>
    </section>

    <section id="table_pull.allocator">
      <name><c>table_pull</c> allocator access</name>

      <code-item>
        <code>
allocator_type get_allocator() const noexcept;
        </code>
        <returns>A copy of the allocator object used by <c>*this</c>.</returns>
      </code-item>
    </section>

    <section id="table_pull.tweaks">
      <name><c>table_pull</c> tweaks</name>

      <code-item>
        <code>
bool is_empty_physical_line_aware() const noexcept;
        </code>
        <returns>Whether <c>*this</c> treats an empty physical line as a text record with no text fields (<c>true</c>) or ignore it (<c>false</c>).</returns>
      </code-item>

      <code-item>
        <code>
table_pull&amp; set_empty_physical_line_aware(bool b = true) noexcept;
        </code>
        <effects>Sets whether <c>*this</c> treats an empty physical line as a text record with no text fields (if <c>b</c> is not <c>false</c>) or ignore it (otherwise).</effects>
        <returns><c>*this</c>.</returns>
      </code-item>
    </section>

    <section id="table_pull.inv">
      <name><c>table_pull</c> invocation</name>

      <code-item>
        <code>
table_pull&amp; operator()(std::size_t n = 0);
        </code>
        <effects>If <c>state() == table_pull_state::eof</c> is <c>true</c>, returns without doing anything.
                 Otherwise, reads the text table until next <c>n + 1</c> text fields are read, an end of a text record is found, or the table source is fully consumed.</effects>
        <returns><c>*this</c>.</returns>
        <throws><c>parse_error</c> (<xref id="parse_error"/>) or any exception thrown by the internal table parser and the allocator.</throws>
        <postcondition><c>(state() == table_pull_state::eof) || (state() == table_pull_state::field) || (state() == table_pull_state::record_end)</c> shall be <c>true</c>.</postcondition>
        <remark>Invalidates all pointers that have been returned by <c>c_str</c> and all ranges represented by string view objects referenced or pointed by the return values of <c>operator*</c> and <c>operator-></c>.</remark>
        <note>If exits via an exception, <c>*this</c> will be left in a valid but unspecified state.</note>
      </code-item>

      <code-item>
        <code>
table_pull&amp; skip_record(std::size_t n = 0);
        </code>
        <effects>If <c>state() == table_pull_state::eof</c> is <c>true</c>, returns without doing anything.
                 Otherwise, reads the text table until <c>n + 1</c> ends of text records are found or the table source is fully consumed.</effects>
        <returns><c>*this</c>.</returns>
        <throws><c>parse_error</c> (<xref id="parse_error"/>) or any exception thrown by the internal table parser and the allocator.</throws>
        <postcondition><c>(state() == table_pull_state::eof) || (state() == table_pull_state::record_end)</c> shall be <c>true</c>.</postcondition>
        <remark>Invalidates all pointers that have been returned by <c>c_str</c> and all ranges represented by string view objects referenced or pointed by the return values of <c>operator*</c> and <c>operator-></c>.</remark>
        <note>If exits via an exception, <c>*this</c> will be left in a valid but unspecified state.</note>
      </code-item>
    </section>

    <section id="table_pull.state">
      <name><c>table_pull</c> state</name>

      <code-item>
        <code>
table_pull_state state() const noexcept;
        </code>
        <returns>A value of <c>table_pull_state</c> that tells the current status of <c>*this</c> as shown in <xref id="table.table_pull.state"/>.</returns>

        <table id="table.table_pull.state">
          <caption>The meanings of the values <c>state()</c> returns</caption>
          <col width="5"/><col width="18"/><col width="81"/><col width="27"/>

          <tr>
            <th>#</th>
            <th>Value</th>
            <th>The current status of <c>*this</c></th>
            <th>The current string value</th>
          </tr>

          <tr>
            <td><c>(1)</c></td>
            <td><c>before_parse</c></td>
            <td>Neither <c>operator()</c> nor <c>skip_record</c> has never been called yet.</td>
            <td>An empty string</td>
          </tr>

          <tr>
            <td><c>(2)</c></td>
            <td><c>eof</c></td>
            <td><c>*this</c> has already consumed all content of the table source.</td>
            <td>An empty string</td>
          </tr>

          <tr>
            <td><c>(3)</c></td>
            <td><c>field</c></td>
            <td><c>*this</c> has reached a text field with the latest call of <c>operator()</c>.</td>
            <td>The text value of the text field</td>
          </tr>

          <tr>
            <td><c>(4)</c></td>
            <td><c>record_end</c></td>
            <td><c>*this</c> has reached an end of the a text record with the latest call of <c>operator()</c> or <c>skip_record</c>.</td>
            <td>An empty string</td>
          </tr>
        </table>
      </code-item>

      <code-item>
        <code>
explicit operator bool() const noexcept;
        </code>
        <returns><c>state() != table_pull_state::eof</c>.</returns>
      </code-item>

      <code-item>
        <code>
std::pair&lt;std::size_t, std::size_t> get_physical_position() const noexcept(<nc>see below</nc>);
        </code>
        <returns>If <c>physical_position_available</c> is <c>true</c>, <c>p.get_physical_position()</c> where <c>p</c> is the internal table parser object.
                 Otherwise, <c>std::make_pair(npos, npos)</c>.</returns>
        <throws>Nothing.</throws>
        <remark>The expression inside <c>noexcept</c> is <c>true</c> if <c>physical_position_available</c> is <c>false</c>.
                Otherwise, it is equivalent to <c>noexcept(p.get_physical_position()))</c> where <c>p</c> is the internal table parser object.</remark>
      </code-item>

      <code-item>
        <code>
std::pair&lt;std::size_t, std::size_t> get_position() const noexcept;
        </code>
        <returns>A pair of integers that may point the logical position of the <c>*this</c> in the text table, whose meanings depend on the return value of <c>state</c> as in <xref id="table.table_pull.get_position"/>.
                 In <xref id="table.table_pull.get_position"/>, <c>r</c> denotes the return value.</returns>

        <table id="table.table_pull.get_position">
          <caption>The meanings of the values <c>get_position()</c> returns</caption>
          <col width="5"/><col width="18"/><col width="36"/><col width="72"/>

          <tr>
            <th>#</th>
            <th>state()</th>
            <th><c>r.first</c></th>
            <th><c>r.second</c></th>
          </tr>

          <tr>
            <td><c>(1)</c></td>
            <td><c>before_parse</c></td>
            <td>Unspecified</td>
            <td>Unspecified</td>
          </tr>

          <tr>
            <td><c>(2)</c></td>
            <td><c>eof</c></td>
            <td>The number of text records successfully read</td>
            <td>The number of text fields successfully read after the last text record successfully read</td>
          </tr>

          <tr>
            <td><c>(3)</c></td>
            <td><c>field</c></td>
            <td>The zero-based index of the text record</td>
            <td>The zero-based index of the field in the text record</td>
          </tr>

          <tr>
            <td><c>(4)</c></td>
            <td><c>record_end</c></td>
            <td>The zero-based index of the text record</td>
            <td>The number of the text fields contained in the text record</td>
          </tr>
        </table>
      </code-item>

      <code-item>
        <code>
const char_type* c_str() const noexcept;
        </code>
        <returns>A pointer that points the first element of a null-terminated sequence of the current string value.</returns>
      </code-item>

      <code-item>
        <code>
const view_type&amp; operator*() const noexcept;
const view_type* operator->() const noexcept;
        </code>
        <returns>A reference or a pointer to a string view object that represents the current string value.</returns>
      </code-item>
    </section>

    <section id="table_pull.mod">
      <name><c>table_pull</c> in-place string value modification</name>

      <code-item>
        <code>
template &lt;class F> table_pull&amp; rewrite(F f);
        </code>
        <requires><c>std::is_invocable_r_v&lt;char_type*, F, char_type*, char_type*></c> shall be true.
                  When evaluated as <c>f(first, last)</c>, <c>f</c> shall read and write at most the range [<c>first</c>, <c>last</c>).</requires>
        <effects>First evaluates <c>f(const_cast&lt;char_type*>(c_str()), const_cast&lt;char_type*>(c_str()) + (*this)->size())</c> and initialize an <c>char_type*</c> object <c>new_end</c> with its result.
                 Then conditionally shorten the current string value, preserving its null-terminated property, so that its size should be <c>new_end - data()</c>.</effects>
        <returns><c>*this</c>.</returns>
        <postcondition><c>state</c> member function shall return the same value as before the invocation.</postcondition>
        <remark>Invalidates all pointers that have been returned by <c>c_str</c> and all ranges represented by string view objects referenced or pointed by the return values of <c>operator*</c> and <c>operator-></c>.
                When an exception is thrown, the state of <c>*this</c> shall not be changed.</remark>
        <note>This member function template is primarily intended to be invoked with a <c>numpunct_replacer_to_c</c> (<xref id="numpunct_replacer_to_c"/>) object.</note>
      </code-item>
    </section>

    <section id="table_pull.creation">
      <name><c>table_pull</c> creation functions</name>
      <code-item>
        <code>
template &lt;class TableSource, class... Appendices>
  table_pull&lt;std::decay_t&lt;TableSource>>
    make_table_pull(TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
        </code>
        <effects><p>Equivalent to:</p>
                 <code>return table_pull&lt;std::decay_t&lt;TableSource>>(std::forward&lt;TableSource>(in),
                                             std::forward&lt;Appendices>(appendices)...);</code></effects>
        <remark>This overload shall not participate in overload resolution unless <c>std::is_constructible_v&lt;table_pull&lt;std::decay_t&lt;TableSource>>, TableSource&amp;&amp;, Appendices&amp;&amp;...></c> is <c>true</c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class TableSource, class Allocator, class... Appendices>
  table_pull&lt;std::decay_t&lt;TableSource>, Allocator>
    make_table_pull(std::allocator_arg_t, const Allocator&amp; alloc,
                    TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
        </code>
        <effects><p>Equivalent to:</p>
                 <code>return table_pull&lt;std::decay_t&lt;TableSource>, Allocator>(std::allocator_arg, alloc,
                                                        std::forward&lt;TableSource>(in),
                                                        std::forward&lt;Appendices>(appendices)...);</code></effects>
        <remark>This overload shall not participate in overload resolution unless <c>std::is_constructible_v&lt;table_pull&lt;std::decay_t&lt;TableSource, Allocator>>, std::allocator_arg_t, const Allocator&amp;, TableSource&amp;&amp;, Appendices&amp;&amp;...></c> is <c>true</c>.</remark>
      </code-item>
    </section>
  </section>
</section>

</document>
