<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="Commata.xsl"?>
<document>
<title>Specification of Commata, which is just another C++14 CSV parser</title>
<signature>2021-09-05 (UTC)</signature>

<section id="introduction">
  <name>Introduction</name>

  <section id="introduction.general">
    <name>General</name>

    <p>This document describes the specifications of Commata, which is a header-only library in C++14 to handle formatted texts, such as CSV texts.</p>
    <p>In this document, many terms and names introduced in ISO C++14 standard are referred without notice.
       &#x2018;Unspecified behaviour&#x2019;, &#x2018;<c>DefaultConstructible</c> requirements&#x2019;, &#x2018;formatted output function&#x2019;, &#x2018;<c>&lt;string></c>&#x2019; (as a header name) and &#x2018;<c>std::string</c>&#x2019; are the examples.</p>

    <p>The normativity of the specifications on this document is the same as the normativity of the description of the ISO C++14 standard for its conforming standard library implementations except that:</p>
    <ul>
      <li>class templates and function templates shall not have any additional template parameters no matter whether they have their default template arguments,</li>
      <li>member templates shall not have any additional template parameters no matter whether they have their default template arguments, except that constructor templates can have ones with their default template arguments, and</li>
      <li>member function templates shall not have any additional parameters no matter whether they have their default arguments.</li>
    </ul>
  </section>

  <section id="introduction.using">
    <name>Using Commata</name>

    <p>A translation unit may include headers described in this document in any order.
       Each may be included more than once, with no effect different from being included exactly once.</p>
    <p>A translation unit shall include a header described in this document only outside of any external declaration or definition, and shall include the header lexically before the first reference in that translation unit to any of the entities declared in that header.</p>
    <p>A translation unit shall not define a macro whose name meets one of the following before a point of an <c>#include</c> preprocessor directive that includes a header described in this document:</p>
    <ul>
      <li>it consists only of one uppercase alphabetic letter,</li>
      <li>it begins with a lowercase alphabetic letter,</li>
      <li>it consists only of alphabetic letters and possibly zero decimal digit characters, contains both of an uppercase alphabetic letter and a lowercase one, and begins with an uppercase one, or</li>
      <li>it begins with <c>COMMATA_</c>.</li>
    </ul>
    <p>Headers described in this document may define macros whose name begin with <c>COMMATA_</c> and may not define any macros with other names.</p>
  </section>

  <section id="concepts">
    <name>Basic concepts</name>

    <p>Users of Commata process texts coordinating two kinds of objects below:</p>
    <ul>
      <li><n>table parsers</n> (<xref id="table_parser.requirements"/>), which retrieve a sequence of char-like objects in a certain format such as a CSV text (<xref id="definitions.csv_text"/>) from an input, which is, for example, a stream or a stream buffer, and emits events to their tied table handlers, and</li>
      <li><n>table handlers</n> (<xref id="table_handler.requirements"/>), which receive events from the table parser and do some operation on them.</li>
    </ul>
    <p>Commata offers some default implementations of above two kinds of concepts.
       Users of Commata can unsurprisingly implement their own table handlers or table parsers, and make them collaborate with the default implementations.</p>
  </section>

  <section id="definitions">
    <name>Definitions</name>

    <section id="definitions.text_table">
      <name>Text tables</name>

      <p>Events that table handlers receive from the parser conform the <n>text table</n> model following:</p>
      <ul>
        <li>Each text table has its <n>char type</n> that is a char-like type.</li>
        <li>A text table is a sequence of <n>text records</n>.</li>
        <li>A text record is a sequence of <n>text fields</n>.</li>
        <li>Each text field has its <n>text value</n>, which is a sequence of the char type objects.</li>
      </ul>
    </section>

    <section id="definitions.csv_text">
      <name>CSV texts</name>

      <p>The CSV parser of Commata (<xref id="parse_csv"/>) conforms the <n>CSV text</n> model following:</p>
      <ul>
        <li>A CSV text is a representation of a text table (<xref id="definitions.text_table"/>) as a sequence of objects whose type is the char type of the text table.</li>
        <li>Each CSV text has its <n>char type</n> that is equal to the char type of the text table.</li>
        <li>Each text field of a text table represented as a CSV text is either of a <n>quoted field</n> or a <n>unquoted field</n>.</li>
        <li>A quoted field is represented as a sequence of the char type objects that starts with a double quote and ends with a double quote.
            Its representation cannot contain odd number of contiguous double quotes after the the starting double quote and before the ending double quote.</li>
        <li>An unquoted field is represented as a sequence of the char type objects that does not contain any double quotes, commas and <n>line breaks</n>.</li>
        <li>The text value of a quoted field is defined as follows:
            <ul>
              <li>first make a copy of the sequence of characters of the range [the next character of the starting double quote, the previous character of the ending double quote],</li>
              <li>then replace every occurrence of two contiguous double quotes in it into one double quote.</li>
            </ul>
        </li>
        <li>The text value of an unquoted field is the representation as a sequence of the char type objects itself.</li>
        <li>In a CSV text, each text record is represented as a comma-delimited sequence of representations of its text fields.
            The representation of the final text field in a text record is not followed by a comma.</li>
        <li>In a CSV text, the representations of its text records are delimited by a line break.
            The representation of the final record is or is not followed by a line break.</li>
        <li>Each line break is either of CR, LF, or CRLF where CR is a carrage return character, LF is a line feed (or new-line) character, and CRLF is a two-character sequence whose first character is CR and whose second is LF.</li>
      </ul>
    </section>

    <section id="definitions.others">
      <name>Other definitions</name>

      <p>Addtional terms on text tables used in this document are as follows:</p>
      <ul>
        <li>A <n>record index</n> of a text record in a text table is a number i where the record is the i-th record in the text table.
            It depends on situation whether i is zero-based or one-based.</li>
        <li>A <n>field index</n> of a text field in a text record is a number j where the field is the j-th field in the text record.
            It depends on situation whether j is zero-based or one-based.</li>
        <li>A <n>line</n> or <n>physical line</n> in a sequence of char-like objects is a sequence of characters delimited by line breaks. It does not contain any line breaks in it.</li>
        <li>A <n>column</n> or <n>physical column</n> in a sequence of char-like objects is a bundle of the same distant characters from the first character of each line.</li>
        <li>A <n>position</n> or <n>physical position</n> of a character in a sequence of char-like objects is the pair of m and n where the character belongs to the m-th line and the n-th column.
            It depends on situation whether m and n are zero-based or one-based.</li>
      </ul>
    </section>
  </section>

  <section id="requirements">
    <name>Basic requirements</name>

    <p>This subclause specifies requirements that correspond the basic concepts of Commata (<xref id="concepts"/>).</p>

    <section id="table_handler.requirements">
      <name><c>TableHandler</c> requirements</name>

      <p>A type <c>T</c> meets the <c>TableHandler</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
      <ul>
        <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>,</li>
        <li>the expressions shown in <xref id="table.table_handler.requirements"/> are valid and have the indicated semantics, and</li>
        <li>moved-to objects of <c>T</c> takes over the states of moved-from objects in terms of <xref id="table.table_handler.requirements"/>.</li>
      </ul>

      <p>In <xref id="table.table_handler.requirements"/>, <c>T</c> is cv-unqualified. <c>t</c> is an lvalue of <c>T</c>. <c>ct</c> is an lvalue of <c>const T</c>. <c>p</c> is an rvalue of <c>std::size_t</c>.</p>

      <p>A requirement is optional if the last column of <xref id="table.table_handler.requirements"/> specifies a default.</p>
      <p>If (2) in <xref id="table.table_handler.requirements"/> is satisfied without falling back on the default, then also (3) shall be so. Likewise, if (3) is satisfied without falling back on the default, then also (2) shall be so.
         That is, <c>T</c> shall either have both of <c>get_buffer</c> and <c>release_buffer</c> member functions or have none of them.</p>

      <table id="table.table_handler.requirements">
        <caption>TableHandler requirements</caption>
        <col width="2"/><col width="9"/><col width="9"/><col width="20"/><col width="8"/>

        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remark</th>
          <th>Default behaviour</th>
        </tr>

        <tr>
          <td>(1)</td>
          <td><c>T::char_type</c></td>
          <td></td>
          <td>Shall be an identical type to <c>Ch</c>.</td>
          <td></td>
        </tr>

        <tr>
          <td>(2)</td>
          <td><c>t.get_buffer()</c></td>
          <td><c>std::pair&lt;Ch*, std::size_t&gt;</c></td>
          <td><p>Called when the parser requires a new buffer.
                 The parser calls this function only just after it was attached to this handler or just after it called (3).</p>
              <p>Shall return a pair of a pointer that points the first element of a secured buffer and its length.
                 The parser utilizes the range [<c>gb.first</c>, <c>gb.first + gb.second</c>) as a buffer where <c>gb</c> is the return value of this function.</p></td>
          <td><p>At the first call, acquires a buffer of a certain length and returns it. </p>
              <p>Otherwise, returns a pooled buffer.</p></td>
        </tr>

        <tr>
          <td>(3)</td>
          <td><c>t.release_buffer(b)</c></td>
          <td>(Not used)</td>
          <td><p>Called when the parser unhold the buffer acquired by the latest call of (2).</p>
              <p><c>b</c> is identical to <c>gb.first</c> where <c>gb</c> is return value of the latest call of (2).</p>
              <p>The parser shall not call this without making a previous call of (2).</p>
              <p>The parser shall call this function just after the parsing process exits via an exception or an abortion when it holds the buffer acquired by a call of (2).</p>
              <p>This function shall not throw any exceptions.</p></td>
           <td>Stores <c>b</c> into a pool.</td>
        </tr>

        <tr>
          <td>(4)</td>
          <td><c>t.start_buffer(bb, be)</c></td>
          <td>(Not used)</td>
          <td><p>Called when the parser starts using its buffer.
                 Calling of this shall occur after a call of (2) and before its corresponding call of (3).</p>
              <p><c>bb</c> is a pointer to const-qualified <c>*gb.first</c> and <c>be</c> is of const-qualified <c>gb.first + gb.second</c> where <c>gb</c> is the return value of the latest call of (2).</p>
              <p>Just after a call of this, the parser shall make an intact copy of a sequence of char-like objects retrieved from its input into the range [<c>bb</c>, <c>bm</c>) where <c>bm</c> is a pointer that resides in [<c>bb</c>, <c>be</c>] and reported with (5) later.
                 After a call of this and before the corresponding call of (5), the parser shall report (possibly past-the-end) pointers on this copy.</p></td>
          <td>Does nothing.</td>
        </tr>

        <tr>
          <td>(5)</td>
          <td><c>t.end_buffer(bm)</c></td>
          <td>(Not used) </td>
          <td><p>Called when the parser finishes using its buffer.
                 Calling of this shall occur after a call of (2) and before its corresponding call of (3).</p>
              <p><c>bm</c> is the past-the-end pointer of the range in the buffer actually used and resides in [<c>bb</c>, <c>be</c>] where <c>bb</c> and <c>be</c> are the arguments of the latest call of (4).</p></td>
          <td>Does nothing.</td>
        </tr>

        <tr>
          <td>(6)</td>
          <td><c>t.empty_physical_line(w)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Called when the parser finds an empty line outside any record.
                 Calling of this shall occur after a call of (4) and before its corresponding call of (5).</p>
              <p><c>w</c> points the last line break character and resides in [<c>bb</c>, <c>gb.first + gb.second</c>) where <c>bb</c> is the argument of the latest call of (4) and gb is the return value of the latest call of (2).</p>
              <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td>Does nothing.</td>
        </tr>

        <tr>
          <td>(7)</td>
          <td><c>t.start_record(rb)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Called when the parser begins to process a record.
                 Calling of this shall occur after a call of (4) and before its corresponding call of (5).</p>
              <p><c>rb</c> is a pointer to the const-qualified first character of the record, not of the text value of the first field of the record. To be specific, if the text table follows the CSV text model (<xref id="definitions.csv_text"/>) and the first field of the records is quoted, <c>*rb</c> shall be a double quote.</p>
              <p><c>rb</c> resides in [<c>bb</c>, <c>gb.first + gb.second</c>) where <c>bb</c> is the argument of the latest call of (4) and gb is the return value of the latest call of (2).</p>
              <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td/>
        </tr>

        <tr>
          <td>(8)</td>
          <td><c>t.end_record(re)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Called when the parser finishes processing a record.
                 Calling of this shall occur after a call of (4) and before its corresponding call of (5).</p>
              <p><c>re</c> is the past-the-end pointer of the const-qualified characters that forms the record, not of the text value of the final field of the record. To be specific, if the text table follows the CSV text model (<xref id="definitions.csv_text"/>) and the final field of the record is quoted, <c>*(re - 1)</c> shall be a double quote.</p>
              <p><c>re</c> resides in [<c>vb</c>, <c>be</c>] where vb is an argument of the latest call of (4) (first argument), (7) (first argument), (9) (second argument) or (10) (second argument), and
                 <c>be</c> is the second argument of the latest call of (4).</p>
              <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td/>
        </tr>

        <tr>
          <td>(9)</td>
          <td><c>t.update(f, l)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Called when the parser finds a non-final chunk of a field value.
                 Calling of this shall occur after a call of (4) and before its corresponding call of (5), and after a call of (7) and before its corresponding call of (8).</p>
              <p><c>f</c> is a pointer whose pointee is const-qualified and resides in [<c>vb</c>, <c>be</c>], and <c>l</c> is a pointer whose pointee is const-qualified and resides [<c>f</c>, <c>be</c>], where <c>vb</c> is an argument of the latest call of
                 (4) (first argument), (7) (first argument), this (second argument) or (10) (second argument), and <c>be</c> is the second argument of the latest call of (4).</p>
              <p>After the call, the parser shall not dereference the range [<c>f</c>, <c>l</c>]; that is, if the table handler can reach the range as non-const, it may modify the elements in the range.</p>
              <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
           <td/>
        </tr>

        <tr>
          <td>(10)</td>
          <td><c>t.finalize(f, l)</c></td>
          <td><c>void</c> or a type contextually convertible to <c>bool</c></td>
          <td><p>Called when the parser finds a final chunk of a field value.
                 Calling of this shall occur after a call of (4) and before its corresponding call of (5), and after a call of (7) and before its corresponding call of (8).</p>
              <p><c>f</c> is a pointer whose pointee is const-qualified and resides in [<c>vb</c>, <c>be</c>], and <c>l</c> is a pointer whose pointee is const-qualified  and resides in [<c>f</c>, <c>be</c>], where <c>vb</c> is an argument of the latest call of
                 (4) (first argument), (7) (first argument), (9) (second argument) or this (second argument), and <c>be</c> is the second argument of the latest call of (4).</p>
              <p>After the call, the parser shall not dereference the range [<c>f</c>, <c>l</c>]; that is, if the table handler can reach the range as non-const, it may modify the element in the range.</p>
              <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is <c>false</c>, the parser shall aborts the parsing process.</p></td>
          <td/>
        </tr>

        <tr>
          <td>(11)</td>
          <td><c>t.yield(p)</c></td>
          <td>A type contextually convertible to <c>bool</c></td>
          <td><p>Called when the parser reaches an execution point where the parser can suspend the execution and return the control to its caller.
                 The parser shall call this also just after calling (5).
                 If this is called just after calling (5), the parser might invalidate all the pointers passed to the table handler since the latest call of (3) just after caling this.</p>
              <p><c>p</c> is a number that can identificate the execution point where the call of this function occurred.
                 Its value shall not be equal to <c>0</c>.
                 Its value of <c>-1</c> shall mean that the parser is about to complete the execution.</p>
              <p>If the contextually converted value to <c>bool</c> of the return value of a call of this is not <c>false</c>, the parser shall suspend the execution and return the control to its caller.</p></td>
          <td>Returns <c>false</c>.</td>
        </tr>

        <tr>
          <td>(12)</td>
          <td><c>ct.yield_position()</c></td>
          <td><c>std::size_t</c></td>
          <td><p>Called when the parser is about to start the execution or restart the execution after a suspension due to the latest return value of (11).</p>
              <p>Shall return <c>0</c> if (11) has never be called; otherwise shall return the value of the parameter <c>p</c> of the latest call of (11).</p></td>
          <td>Returns <c>0</c>.</td>
        </tr>
      </table>

      <p>A moved-from object whose type satisfies <c>TableHandler</c> requirements may cause undefined behaviour when used in terms of <xref id="table.table_handler.requirements"/>.</p>
    </section>

    <section id="table_parser.requirements">
      <name><c>TableParser</c> requirements</name>

      <p>A type <c>T</c> meets the <c>TableParser</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
      <ul>
        <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
        <li>each object of <c>T</c> has (possibly a reference to) a <n>tied character input</n> object, and (similarly, possibly a reference to) a <n>tied table handler</n> object whose type meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>);
            and the expressions shown in <xref id="table.table_parser.requirements"/> are valid and have the indicated semantics.</li>
      </ul>

      <p>In <xref id="table.table_parser.requirements"/>, <c>T</c> is cv-unqualified. <c>t</c> is an lvalue of <c>T</c>. <c>ct</c> is an lvalue of <c>const T</c>.</p>

      <table id="table.table_parser.requirements">
        <caption>TableParser requirements</caption>
        <col width="2"/><col width="9"/><col width="9"/><col width="28"/>

        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remark</th>
        </tr>

        <tr>
          <td>(1)</td>
          <td><c>t()</c></td>
          <td>A type contextually convertible to <c>bool</c></td>
          <td>Retrieves the text content from its tied character input, parses the text content, and calls the member functions of its tied table handler object compliantly with the <c>TableHandler</c> requirements.
              Returns <c>false</c> if the return value of a call on <c>empty_physical_line</c>, <c>start_record</c>, <c>end_record</c>, <c>update</c>, or <c>finalize</c> is <c>false</c>; <c>true</c> otherwise.
              If this returns <c>false</c> or exits via an exception, then this becomes unable to be called again.</td>
        </tr>

        <tr>
          <td>(2)</td>
          <td><c>ct.~T()</c></td>
          <td>(Not used)</td>
          <td>Calls <c>release_buffer</c> of its tied table handler object if and only if the latest call of (1) left a buffer obtained with <c>get_buffer</c> of the table handler object unreleased.</td>
        </tr>
      </table>

      <p><xref id="table.table_parser.optional"/> lists operations provided for some types of <c>TableParser</c>s but not others.
         Those types for which the listed operations are provided shall implement the semantics described in <xref id="table.table_parser.optional"/> unless otherwise stated.</p>

      <p>In <xref id="table.table_parser.optional"/>, <c>ct</c> is an lvalue of <c>const T</c>, where <c>T</c> is cv-unqualified.</p>

      <table id="table.table_parser.optional">
        <caption>Optional TableParser operations</caption>
        <col width="2"/><col width="9"/><col width="9"/><col width="28"/>

        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remark</th>
        </tr>

        <tr>
          <td>(1)</td>
          <td><c>ct.get_physical_position()</c></td>
          <td><c>std::pair&lt;std::size_t, std::size_t></c></td>
          <td>Returns a pair of the physical line number and the physical column number (<xref id="definitions.others"/>).
              The numbers are zero-based.
              <c>-1</c> means shall mean &#x2018;no information&#x2019;.
              Shall not exit via an exception.</td>
        </tr>
      </table>
    </section>
  </section>
</section>

<section id="utility">
  <name>General utilities</name>

  <section id="diagnostics">
    <name>Diagnostic facilities</name>

    <section id="diagnostics.general">
      <name>General</name>
      <p>This subclause describes an exception class <c>text_error</c> (<xref id="text_error"/>), which defines the base class for the types of objects thrown while the parsers are comsuming the texts, and some facilities to access information that <c>text_error</c> objects hold.</p>
    </section>

    <section id="header_text_error_hpp">
      <name>Header <c>"commama/text_error.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;cstddef>
#include &lt;exception>
#include &lt;ostream>
#include &lt;string>

namespace commata {
  class text_error_info;  <c>// <n>forward declaration</n></c>

  <c>// <n><xref id="text_error"/>, class text_error:</n></c>
  class text_error;

  <c>// <n><xref id="text_error_info"/>, class text_error_info:</n></c>
  class text_error_info;

  template &lt;class Tr>
    std::basic_ostream&lt;char, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;char, Tr>&amp; os,
                                             const text_error_info&amp; i);
  template &lt;class Tr>
    std::basic_ostream&lt;wchar_t, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;wchar_t, Tr>&amp; os,
                                                const text_error_info&amp; i);
  std::string to_string(const text_error_info&amp; i);
  std::wstring to_wstring(const text_error_info&amp; i);
}
      </codeblock>
    </section>

    <section id="text_error">
      <name>Class <c>text_error</c></name>

      <codeblock>
namespace commata {
  class text_error : public std::exception {
  public:
    static constexpr std::size_t npos = -1;

    <c>// <n><xref id="text_error.cons"/>, constructors and assignment operators:</n></c>
    text_error() noexcept;
    template &lt;class T> explicit text_error(T&amp;&amp; what_arg);
    text_error(const text_error&amp; other) noexcept;
    text_error(text_error&amp;&amp; other) noexcept;
    text_error&amp; operator=(const text_error&amp; other) noexcept;
    text_error&amp; operator=(text_error&amp;&amp; other) noexcept;

    const char* what() const noexcept override;

    <c>// <n><xref id="text_error.physical_position"/>, physical postion information:</n></c>
    text_error&amp; set_physical_position(std::size_t row = npos, std::size_t col = npos) noexcept;
    const std::pair&lt;std::size_t, std::size_t>* get_physical_position() const noexcept;

    <c>// <n><xref id="text_error.info"/>, textual information:</n></c>
    text_error_info info(std::size_t base = 1) const noexcept;
  };
}
      </codeblock>

      <p>The class <c>text_error</c> defines the base class for the types of the objects thrown by Commata library.</p>
      <p>An object of <c>text_error</c> can optionally have a physical position information (<xref id="definitions.others"/>), which consists of the line number and the column number of the point in the input text that has made the exception thrown.
         <c>npos</c> is a special value for the line number and the column number which indicates &#x2018;no information&#x2019;.</p>

      <section id="text_error.cons">
        <name><c>text_error</c> constructors and assignment operators</name>

        <code-item>
          <code>
text_error() noexcept;
          </code>
          <effects>Constructs an object of <c>text_error</c>.</effects>
          <postcondition><c>(*what() == '\0') &amp;&amp; !get_physical_position()</c> shall not be <c>false</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class T> explicit text_error(T&amp;&amp; what_arg);
          </code>
          <effects>Constructs an object of <c>text_error</c>.</effects>
          <postcondition><c>(std::strcmp(w.c_str(), what()) == 0) &amp;&amp; !get_physical_position()</c> shall not be <c>false</c>
                         where <c>w</c> is an object of <c>std::basic_string&lt;char, Tr, Allocator></c> for a certain combination of <c>Tr</c> and <c>Allocator</c>
                         that would be constructed with <c>std::forward&lt;T>(what_arg)</c>.</postcondition>
          <remark>This constructor shall not participate in overload resolution unless
                  <c>std::decay_t&lt;T></c> is the same type as <c>std::basic_string&lt;char, Tr, Allocator></c> for a certain combination of <c>Tr</c> and <c>Allocator</c>, or
                  <c>std::is_constructible&lt;std::string, T&amp;&amp;>::value</c> is not <c>false</c>.</remark>
        </code-item>

        <code-item>
          <code>
text_error(const text_error&amp; other) noexcept;
          </code>
          <effects>Constructs an object of <c>text_error</c> from another object of <c>text_error</c>.</effects>
          <postcondition><c>(std::strcmp(other.what(), what() == 0) &amp;&amp; (other.get_physical_position() ? (*other.get_physical_position() == *get_physical_position()) : !get_physical_position())</c> is not <c>false</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
text_error(text_error&amp;&amp; other) noexcept;
          </code>
          <effects>Constructs an object of <c>text_error</c> from another object of <c>text_error</c> placing <c>other</c> in a valid but unspecified state.</effects>
          <postcondition><c>(std::strcmp(c.what(), what()) == 0) &amp;&amp; (c.get_physical_position() ? (*c.get_physical_position() == *get_physical_position()) : !get_physical_position())</c> shall be not <c>false</c> where <c>c</c> is an object that would be copy constructed from <c>other</c> before the call.</postcondition>
        </code-item>

        <code-item>
          <code>
text_error&amp; operator=(const text_error&amp; other) noexcept;
          </code>
          <effects>Assigns an object of <c>text_error</c> from another object of <c>text_error</c>.</effects>
          <postcondition><c>(std::strcmp(ow, what()) == 0) &amp;&amp; (other.get_physical_position() ? (*other.get_physical_position() == *get_physical_position()) : !get_physical_position())</c> shall be not <c>false</c>.</postcondition>
          <returns><c>*this</c>.</returns>
        </code-item>

        <code-item>
          <code>
text_error&amp; operator=(text_error&amp;&amp; other) noexcept;
          </code>
          <effects>Assigns an object of <c>text_error</c> from another object of <c>text_error</c> placing <c>other</c> in a valid but unspecified state.</effects>
          <postcondition><c>(std::strcmp(ow, what()) == 0) &amp;&amp; (c.get_physical_position() ? (*c.get_physical_position() == *get_physical_position()) : !get_physical_position() == nullptr)</c> shall not be <c>false</c> where <c>c</c> is an object that would be copy constructed from <c>other</c> before the call.</postcondition>
          <returns><c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="text_error.physical_position">
        <name><c>text_error</c> physical position information</name>

        <code-item>
          <code>
text_error&amp; set_physical_position(std::size_t line = npos, std::size_t col = npos) noexcept;
          </code>
          <effects>If both of <c>line</c> and <c>col</c> are equal to <c>npos</c>, removes the position information if it exists. Otherwise, sets the position information whose line number and column number are <c>line</c> and <c>col</c> respectively.</effects>
          <postcondition>If both of <c>line</c> and <c>col</c> are equal to <c>npos</c>, <c>get_physical_position() == nullptr</c> shall not be <c>false</c>. Otherwise, <c>*get_physical_position() == std::make_pair(line, col)</c> shall not be <c>false</c>.</postcondition>
          <returns><c>*this</c>.</returns>
          <remark><c>line</c> and <c>col</c> shall be <c>npos</c> or zero-based numbers of the row and the column.
                  <c>npos</c> shall mean &#x2018;no information&#x2019;.</remark>
        </code-item>

        <code-item>
          <code>
const std::pair&lt;std::size_t, std::size_t>* get_physical_position() const noexcept;
          </code>
          <returns>If <c>*this</c> holds a physical position information, a pointer to an pair of its line number and column number. Otherwise, <c>nullptr</c>.</returns>
          <remark><c>p->first</c> and <c>p->second</c> shall be <c>npos</c> or zero-based numbers of the row and the column where <c>p</c> is the return value that is not equal to <c>nullptr</c>.
                  <c>npos</c> shall mean &#x2018;no information&#x2019;.</remark>
        </code-item>
      </section>

      <section id="text_error.info">
        <name><c>text_error</c> textual information</name>

        <code-item>
          <code>
text_error_info info(std::size_t base = 1) const noexcept;
          </code>
          <returns><c>text_error_info(*this, base)</c>.</returns>
        </code-item>
      </section>
    </section>

    <section id="text_error_info">
      <name>Class <c>text_error_info</c></name>

      <codeblock>
namespace commata {
  class text_error_info {
  public:
    text_error_info(const text_error&amp; ex, std::size_t base) noexcept;
    text_error_info(const text_error_info&amp; other) noexcept;
    text_error_info&amp; operator=(const text_error_info&amp; other) noexcept;

    const text_error&amp; error() const noexcept;
    std::size_t get_base() const noexcept;

  private:
    const text_error* e;  <c>// <n>exposition only</n></c>
    std::size_t b;        <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="text_error_info.char_repr"/>, chracter representations:</n></c>
  template &lt;class Tr>
    std::basic_ostream&lt;char, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;char, Tr>&amp; os,
                                             const text_error_info&amp; i);
  template &lt;class Tr>
    std::basic_ostream&lt;wchar_t, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;wchar_t, Tr>&amp; os,
                                                const text_error_info&amp; i);
  std::string to_string(const text_error_info&amp; i);
  std::wstring to_wstring(const text_error_info&amp; i);
}
      </codeblock>

      <p>An object of the class <c>text_error_info</c> is a mere reference-wrapper of an object of the class <c>text_error</c>.
         This class offers a simple character representation of objects of the class <c>text_error</c>.</p>

      <code-item>
        <code>
text_error_info(const text_error&amp; ex, std::size_t base) noexcept;
        </code>
        <effects>Initializes <c>e</c> with <c>std::addressof(ex)</c> and <c>b</c> with <c>base</c>.</effects>
      </code-item>

      <code-item>
        <code>
text_error_info(const text_error_info&amp; other) noexcept;
        </code>
        <effects>Initializes <c>e</c> with <c>other.e</c> and <c>b</c> with <c>other.b</c>.</effects>
      </code-item>

      <code-item>
        <code>
text_error_info&amp; operator=(const text_error_info&amp; other) noexcept;
        </code>
        <effects>Assigns <c>e</c> from <c>other.e</c> and <c>b</c> from <c>other.b</c>.</effects>
      </code-item>

      <code-item>
        <code>
const text_error&amp; error() const noexcept;
        </code>
        <returns><c>*e</c>.</returns>
      </code-item>

      <code-item>
        <code>
std::size_t get_base() const noexcept;
        </code>
        <returns><c>b</c>.</returns>
      </code-item>

      <section id="text_error_info.char_repr">
        <name><c>text_error_info</c> character representations</name>

        <code-item>
          <code>
template &lt;class Tr>
  std::basic_ostream&lt;char, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;char, Tr>&amp; os,
                                           const text_error_info&amp; i);
template &lt;class Tr>
  std::basic_ostream&lt;wchar_t, Tr>&amp; operator&lt;&lt;(std::basic_ostream&lt;wchar_t, Tr>&amp; os,
                                              const text_error_info&amp; i);
          </code>
          <effects>Behaves as a formatted output function of <c>os</c>.
                   Forms a character sequence <c>seq</c> of an unspecified concise character representation of <c>i.error()</c> from <c>i.error().what()</c> and <c>i.error().get_physical_position()</c>, in which the line number and the column number are <c>i.get_base()</c>-based.
                 Determines padding for <c>seq</c>. Then inserts <c>seq</c> as if by calling <c>os.rdbuf()->sputn(seq, n)</c> where <c>n</c> is the larger of <c>os.width()</c> and the size of <c>seq</c>. Then calls <c>os.width(0)</c>.</effects>
          <returns><c>os</c>.</returns>
          <remark>The second function template shall widen each character <c>c</c> in the null-terminated byte string pointed by <c>i.error().what()</c> with <c>os.widen(c)</c>.</remark>
          <note>The second function template may not recover the full information of <c>i.error().what()</c> when it is an NTMBS because of the nature of <c>std::basic_ostream&lt;wchar_t, Tr>::widen</c>.</note>
        </code-item>

        <code-item>
          <code>
std::string to_string(const text_error_info&amp; i);
std::wstring to_wstring(const text_error_info&amp; i);
          </code>
          <returns>A character representation of <c>i.error()</c> that is the same as the <c>operator&lt;&lt;</c> inserts into a stream.</returns>
        </code-item>
      </section>
    </section>

    <section id="header_parse_error_hpp">
      <name>Header <c>"commama/parse_error.hpp"</c> synopsis</name>
      <codeblock>
#include "text_error.hpp"

namespace commata {
  <c>// <n><xref id="parse_error"/>, parse_error:</n></c>
  class parse_error;
}
      </codeblock>
    </section>

    <section id="parse_error">
      <name>Class <c>parse_error</c></name>

      <codeblock>
namespace commata {
  class parse_error : public text_error {
  public:
    using text_error::text_error;
  };
}
      </codeblock>

      <p>An exception of type <c>parse_error</c> is thrown by the parser, for example by <c>parse_csv</c> (<xref id="parse_csv"/>), when the text does not have an appropriate format.</p>
    </section>
  </section>

  <section id="handler_wrappers">
    <name>Wrappers of table handlers</name>

    <section id="header_empty_physical_line_aware_handler">
      <name>Header <c>"commama/empty_physical_line_aware_handler.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;functional>

namespace commata {
  <c>// <n><xref id="empty_physical_line_aware_handler"/>, creation of table handler wrappers aware of empty physical lines:</n></c>
  template &lt;class Handler>
    <nc>unspecified</nc>
      make_empty_physical_line_aware(Handler&amp;&amp; handler) noexcept(<nc>see below</nc>);
  template &lt;class Handler>
    <nc>unspecified</nc>
      make_empty_physical_line_aware(const std::reference_wrapper&lt;Handler>&amp; handler) noexcept;
}
      </codeblock>
    </section>

    <section id="empty_physical_line_aware_handler">
      <name>Creation of table handler wrappers aware of empty physical lines</name>

      <code-item>
        <code>
template &lt;class Handler>
  <nc>unspecified</nc>
    make_empty_physical_line_aware(Handler&amp;&amp; handler) noexcept(<nc>see below</nc>);
template &lt;class Handler>
  <nc>unspecified</nc>
    make_empty_physical_line_aware(const std::reference_wrapper&lt;Handler>&amp; handler) noexcept;
        </code>
        <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements, except that in the second overload it need not meet either the <c>MoveConstructible</c> requirements or the <c>Destructible</c> requirements.</requires>
        <returns><p>An object of an unspecified type whose type meets the <c>TableHandler</c> requirements and that holds an object <c>h</c> that is a copy of <c>handler</c> (first overload) or a reference to <c>handler.get()</c> (second overload).
                    It forwards calls of its member functions to <c>h</c>; except that when its <c>empty_physical_line</c> member function is called with an argument <c>where</c>,
                    it first calls <c>h.start_record(where)</c>, and if its contextually converted return value to <c>bool</c> is not <c>false</c>, next calls <c>h.end_record(where)</c>.
                    Its return type and the return value are as follows:</p>
                 <ul>
                   <li>if both of the return types of <c>h.start_record(where)</c> and <c>h.end_record(where)</c> are <c>void</c>, the return type shall be <c>void</c>,</li>
                   <li>otherwise, the return type shall be <c>bool</c>, and the return value shall be <c>true</c> if and only if none of the the return values contextually converted to <c>bool</c> of <c>h.start_record(where)</c> and <c>h.end_record(where)</c> is <c>false</c>.</li>
                 </ul>
        </returns>
        <remark>The first overload shall not participate in overload resolution unless <c>std::decay_t&lt;Handler></c> is not the same type as <c>std::reference_wrapper&lt;T></c> for any <c>T</c>.
                The expression inside <c>noexcept</c> of the first overload is equivalent to <c>std::is_nothrow_move_constructible&lt;std::decay_t&lt;Handler>>::value</c>.</remark>
      </code-item>
    </section>
  </section>
</section>

<section id="parser">
  <name>Default table parsers</name>

  <section id="parser.input">
    <name>Input texts of parsing</name>

    <section id="parser.input.general">
      <name>General</name>

      <p>This subclause describes the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>), which is an abstraction of text inputs to be parsed, and its built-in implementations.</p>
    </section>

    <section id="char_input.requirements">
      <name><c>CharInput</c> requirements</name>

      <p>A type <c>T</c> meets the <c>CharInput</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
      <ul>
        <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
        <li>the expressions shown in <xref id="table.char_input.requirements"/> are valid and have the indicated semantics.</li>
      </ul>

       <p>In <xref id="table.char_input.requirements"/>, <c>T</c> is cv-unqualified. <c>t</c> is an lvalue of <c>T</c>. <c>d</c> is a rvalue of <c>Ch*</c>. <c>n</c> is a rvalue of <c>T::size_type</c>.</p>

      <table id="table.char_input.requirements">
        <caption>CharInput requirements</caption>
        <col width="3"/><col width="10"/><col width="10"/><col width="60"/>

        <tr>
          <th>#</th>
          <th>Expression</th>
          <th>Return type</th>
          <th>Remark</th>
        </tr>

        <tr>
          <td>(1)</td>
          <td><c>T::char_type</c></td>
          <td/>
          <td>Shall be identical to <c>Ch</c>.</td>
        </tr>

        <tr>
          <td>(2)</td>
          <td><c>T::traits_type</c></td>
          <td/>
          <td>Shall be a character traits type for <c>Ch</c>.</td>
        </tr>

        <tr>
          <td>(3)</td>
          <td><c>T::size_type</c></td>
          <td/>
          <td>Shall be an unsigned integer type.</td>
        </tr>

        <tr>
          <td>(4)</td>
          <td><c>t(d, n)</c></td>
          <td><c>T::size_type</c></td>
          <td>Assigns at most <c>n</c> characters to [<c>d</c>, <c>d + m</c>) where <c>m</c> denotes the number of characters actually assigned.
              Then returns <c>m</c>.</td>
        </tr>
      </table>
    </section>

    <section id="header_char_input_hpp">
      <name>Header <c>"commama/char_input.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;cstddef>
#include &lt;streambuf>
#include &lt;string>
#include &lt;type_traits>

namespace commata {
  <c>// <n><xref id="streambuf_input"/>, streambuf_input:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class streambuf_input;
  template &lt;class Ch, class Tr>
    void swap(streambuf_input&lt;Ch, Tr>&amp; left,
              streambuf_input&lt;Ch, Tr>&amp; right) noexcept;

  <c>// <n><xref id="owned_streambuf_input"/>, owned_streambuf_input:</n></c>
  template &lt;class Streambuf> class owned_streambuf_input;
  template &lt;class Streambuf>
    void swap(owned_streambuf_input&lt;Streambuf>&amp; left,
              owned_streambuf_input&lt;Streambuf>&amp; right) noexcept(<nc>see below</nc>);

  <c>// <n><xref id="owned_istream_input"/>, owned_istream_input:</n></c>
  template &lt;class IStream> class owned_istream_input;
  template &lt;class IStream>
    void swap(owned_istream_input&lt;IStream>&amp; left,
              owned_istream_input&lt;IStream>&amp; right) noexcept(<nc>see below</nc>);

  <c>// <n><xref id="string_input"/>, string_input:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class string_input;
  template &lt;class Ch, class Tr>
    void swap(string_input&lt;Ch, Tr>&amp; left,
              string_input&lt;Ch, Tr>&amp; right) noexcept;

  <c>// <n><xref id="owned_string_input"/>, owned_string_input:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class owned_string_input;
  template &lt;class Ch, class Tr, class Allocator>
    void swap(owned_string_input&lt;Ch, Tr, Allocator>&amp; left,
              owned_string_input&lt;Ch, Tr, Allocator>&amp; right) noexcept(<nc>see below</nc>);

  <c>// <n><xref id="char_input.creation"/>, CharInput creation functions:</n></c>
  template &lt;class Ch, class Tr>
    streambuf_input&lt;Ch, Tr> make_char_input(std::basic_streambuf&lt;Ch, Tr>* in);
  template &lt;class Ch, class Tr>
    streambuf_input&lt;Ch, Tr> make_char_input(std::basic_istream&lt;Ch, Tr>&amp; in) noexcept;
  template &lt;class Streambuf>
    owned_streambuf_input&lt;Streambuf> make_char_input(Streambuf&amp;&amp; in) noexcept(<nc>see below</nc>);
  template &lt;class IStream>
    owned_istream_input&lt;IStream> make_char_input(IStream&amp;&amp; in) noexcept(<nc>see below</nc>);
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>>
    string_input&lt;Ch, Tr> make_char_input(const Ch* in);
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>>
    string_input&lt;Ch, Tr> make_char_input(const Ch* in, std::size_t length);
  template &lt;class Ch, class Tr, class Allocator>
    string_input&lt;Ch, Tr>
      make_char_input(const std::basic_string&lt;Ch, Tr, Allocator>&amp; in) noexcept;
  template &lt;class Ch, class Tr, class Allocator>
    owned_string_input&lt;Ch, Tr, Allocator>
      make_char_input(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; in) noexcept;
}
      </codeblock>

      <p>The header <c>"commama/char_input.hpp"</c> defines some class templates whose instances meet the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>).</p>
    </section>

    <section id="streambuf_input">
      <name>Class template <c>streambuf_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class streambuf_input {
  public:
    using streambuf_type = std::basic_streambuf&lt;Ch, Tr>;
    using char_type      = Ch;
    using traits_type    = Tr;
    using size_type      = std::make_unsigned_t&lt;std::streamsize>;

    <c>// <n><xref id="streambuf_input.cons"/>, construct/copy/destroy:</n></c>
    streambuf_input() noexcept : in(nullptr) {}
    explicit streambuf_input(std::basic_streambuf&lt;Ch, Tr>* sb);
    explicit streambuf_input(std::basic_istream&lt;Ch, Tr>&amp; s) noexcept;
    streambuf_input(streambuf_input&amp;&amp; other) noexcept;
   ~streambuf_input() = default;
    streambuf_input&amp; operator=(streambuf_input&amp;&amp; other) noexcept;

    <c>// <n><xref id="streambuf_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);

    <c>// <n><xref id="streambuf_input.modifiers"/>, modifiers:</n></c>
    void swap(streambuf_input&amp; other) noexcept;

  private:
    std::basic_streambuf&lt;Ch, Tr>* in;  <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="streambuf_input.special"/>, specialized algorithms:</n></c>
  template &lt;class Ch, class Tr>
    void swap(streambuf_input&lt;Ch, Tr>&amp; left,
              streambuf_input&lt;Ch, Tr>&amp; right) noexcept;
}
      </codeblock>

      <p>The class template <c>streambuf_input</c> describes thin wrappers of stream buffers without any ownership of them.</p>
      <p>The template parameter <c>Ch</c> shall be a char-like type. The template parameter <c>Tr</c> shall be a character traits type for <c>Ch</c>.</p>
      <p>An instance of <c>streambuf_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Ch</c>.</p>

      <section id="streambuf_input.cons">
        <name><c>streambuf_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit streambuf_input(std::basic_streambuf&lt;Ch, Tr>* sb);
          </code>
          <requires><c>sb</c> shall be <c>nullptr</c> or a pointer to a valid stream buffer object.</requires>
          <effects>Initializes <c>in</c> with <c>sb</c>.</effects>
          <throws>Nothing.</throws>
        </code-item>

        <code-item>
          <code>
explicit streambuf_input(std::basic_istream&lt;Ch, Tr>&amp; s) noexcept;
          </code>
          <effects>Initializes <c>in</c> with <c>s.rdbuf()</c>.</effects>
        </code-item>

        <code-item>
          <code>
streambuf_input(streambuf_input&amp;&amp; other) noexcept;
          </code>
          <effects>Initializes <c>in</c> with <c>other.in</c> and then assigns <c>nullptr</c> to <c>other.in</c>.</effects>
        </code-item>

        <code-item>
          <code>
streambuf_input&amp; operator=(streambuf_input&amp;&amp; other) noexcept;
          </code>
          <effects>Assigns <c>other.in</c> to <c>in</c> and then assigns <c>nullptr</c> to <c>other.in</c>.</effects>
        </code-item>
      </section>

      <section id="streambuf_input.inv">
        <name><c>streambuf_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <requires>[<c>out</c>, <c>out + n</c>) shall be a valid range for output.</requires>
          <effects>If <c>in</c> is not equal to <c>nullptr</c>, assigns up to <c>n</c> characters obtained from <c>*in</c> to successive elements of the array whose first element is designated by <c>out</c>.</effects>
          <returns>The number of characters assigned.</returns>
        </code-item>
      </section>

      <section id="streambuf_input.modifiers">
        <name><c>streambuf_input</c> modifiers</name>

        <code-item>
          <code>
void swap(streambuf_input&amp; other) noexcept;
          </code>
          <effects>Exchanges <c>in</c> and <c>other.in</c>.</effects>
        </code-item>
      </section>

      <section id="streambuf_input.special">
        <name><c>streambuf_input</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Ch, class Tr>
  void swap(streambuf_input&lt;Ch, Tr>&amp; left,
            streambuf_input&lt;Ch, Tr>&amp; right) noexcept;
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
        </code-item>
      </section>
    </section>

    <section id="owned_streambuf_input">
      <name>Class template <c>owned_streambuf_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class Streambuf> class owned_streambuf_input {
  public:
    using streambuf_type = Streambuf;
    using char_type      = typename Streambuf::char_type;
    using traits_type    = typename Streambuf::traits_type;
    using size_type      = std::make_unsigned_t&lt;std::streamsize>;

    <c>// <n><xref id="owned_streambuf_input.cons"/>, construct/copy/destroy:</n></c>
    owned_streambuf_input() = default;
    explicit owned_streambuf_input(Streambuf&amp;&amp; sb) noexcept(<nc>see below</nc>);
    owned_streambuf_input(owned_streambuf_input&amp;&amp; other) = default;
   ~owned_streambuf_input() = default;
    owned_streambuf_input&amp; operator=(owned_streambuf_input&amp;&amp; other) = default;

    <c>// <n><xref id="owned_streambuf_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);

    <c>// <n><xref id="owned_streambuf_input.modifiers"/>, modifiers:</n></c>
    void swap(owned_streambuf_input&amp; other) noexcept(<nc>see below</nc>);

  private:
    Streambuf in;   <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="owned_streambuf_input.special"/>, specialized algorithms:</n></c>
  template &lt;class Streambuf>
    void swap(owned_streambuf_input&lt;Streambuf>&amp; left,
              owned_streambuf_input&lt;Streambuf>&amp; right) noexcept(<nc>see below</nc>);
}
      </codeblock>

      <p>The class template <c>owned_streambuf_input</c> describes thin wrappers of an object of an derived type of an instance of <c>std::basic_streambuf</c> with the ownership of it.</p>
      <p>The template parameter <c>Streambuf</c> shall be the same type as, or be a derived type of, <c>std::basic_streambuf&lt;Ch, Tr></c> for a certain combination of <c>Ch</c> and <c>Tr</c>.</p>
      <p>An instance of <c>owned_streambuf_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Streambuf::char_type</c>.</p>

      <section id="owned_streambuf_input.cons">
        <name><c>owned_streambuf_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit owned_streambuf_input(Streambuf&amp;&amp; sb) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes <c>in</c> with <c>std::move(sb)</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;Streambuf>::value</c>.</remark>
          <note>This constructor can cause a so-called slicing.</note>
        </code-item>
      </section>

      <section id="owned_streambuf_input.inv">
        <name><c>owned_streambuf_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <requires>[<c>out</c>, <c>out + n</c>) shall be a valid range for output.</requires>
          <effects>Assigns up to <c>n</c> characters obtained from <c>in</c> to successive elements of the array whose first element is designated by <c>out</c>.</effects>
          <returns>The number of characters assigned.</returns>
        </code-item>
      </section>

      <section id="owned_streambuf_input.modifiers">
        <name><c>owned_streambuf_input</c> modifiers</name>

        <code-item>
          <code>
void swap(owned_streambuf_input&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>in</c> shall be swappable with <c>other.in</c>.</requires>
          <effects>Exchanges <c>in</c> and <c>other.in</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to the value of <c>noexcept(swap(std::declval&lt;Streambuf&amp;>(), std::declval&lt;Streambuf&amp;>()))</c> evaluated in a context where <c>std::swap</c> participates in the overload resolution.</remark>
        </code-item>
      </section>

      <section id="owned_streambuf_input.special">
        <name><c>owned_streambuf_input</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Streambuf>
  void swap(owned_streambuf_input&lt;Ch, Tr>&amp; left,
            owned_streambuf_input&lt;Ch, Tr>&amp; right) noexcept(<nc>see below</nc>);
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>noexcept(left.swap(right))</c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="owned_istream_input">
      <name>Class template <c>owned_istream_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class IStream> class owned_istream_input {
  public:
    using istream_type = IStream;
    using char_type    = typename IStream::char_type;
    using traits_type  = typename IStream::traits_type;
    using size_type    = std::make_unsigned_t&lt;std::streamsize>;

    <c>// <n><xref id="owned_istream_input.cons"/>, construct/copy/destroy:</n></c>
    owned_istream_input() = default;
    explicit owned_istream_input(IStream&amp;&amp; s) noexcept(<nc>see below</nc>);
    owned_istream_input(owned_istream_input&amp;&amp; other) = default;
   ~owned_istream_input() = default;
    owned_istream_input&amp; operator=(owned_istream_input&amp;&amp; other) = default;

    <c>// <n><xref id="owned_istream_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);

    <c>// <n><xref id="owned_istream_input.modifiers"/>, modifiers:</n></c>
    void swap(owned_istream_input&amp; other) noexcept(<nc>see below</nc>);

  private:
    IStream in;     <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="owned_istream_input.special"/>, specialized algorithms:</n></c>
  template &lt;class Ch, class Tr>
    void swap(owned_istream_input&lt;IStream>&amp; left,
              owned_istream_input&lt;IStream>&amp; right) noexcept(<nc>see below</nc>);
}
      </codeblock>

      <p>The class template <c>owned_istream_input</c> describes thin wrappers of an object of an derived type of an instance of <c>std::basic_istream</c> with the ownership of it.</p>
      <p>The template parameter <c>IStream</c> shall be the same type as, or be a derived type of, <c>std::basic_istream&lt;Ch, Tr></c> for a certain combination of <c>Ch</c> and <c>Tr</c>.</p>
      <p>An instance of <c>owned_istream_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Streambuf::char_type</c>.</p>

      <section id="owned_istream_input.cons">
        <name><c>owned_istream_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit owned_istream_input(IStream&amp;&amp; s) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes <c>in</c> with <c>std::move(s)</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;IStream>::value</c>.</remark>
          <note>This constructor can cause a so-called slicing.</note>
        </code-item>
      </section>

      <section id="owned_istream_input.inv">
        <name><c>owned_istream_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <requires>[<c>out</c>, <c>out + n</c>) shall be a valid range for output.</requires>
          <effects>Assigns up to <c>n</c> characters obtained from <c>*in.rdbuf()</c> to successive elements of the array whose first element is designated by <c>out</c>.</effects>
          <returns>The number of characters assigned.</returns>
        </code-item>
      </section>

      <section id="owned_istream_input.modifiers">
        <name><c>owned_istream_input</c> modifiers</name>

        <code-item>
          <code>
void swap(owned_istream_input&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>in</c> shall be swappable with <c>other.in</c>.</requires>
          <effects>Exchanges <c>in</c> and <c>other.in</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to the value of <c>noexcept(swap(std::declval&lt;IStream&amp;>(), std::declval&lt;IStream&amp;>()))</c> evaluated in a context where <c>std::swap</c> participates in the overload resolution.</remark>
        </code-item>
      </section>

      <section id="owned_istream_input.special">
        <name><c>owned_istream_input</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Ch, class Tr>
  void swap(owned_istream_input&lt;Ch, Tr>&amp; left,
            owned_istream_input&lt;Ch, Tr>&amp; right) noexcept(<nc>see below</nc>);
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>noexcept(left.swap(right))</c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="string_input">
      <name>Class template <c>string_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>> class string_input {
  public:
    using char_type = Ch;
    using traits_type = Tr;
    using size_type = std::size_t;

    <c>// <n><xref id="string_input.cons"/>, construct/copy/destroy:</n></c>
    string_input() noexcept : begin(nullptr), end(nullptr) {}
    explicit string_input(const Ch* str);
    string_input(const Ch* data, std::size_t length);
    template &lt;class Allocator>
      explicit string_input(const std::basic_string&lt;Ch, Tr, Allocator>&amp; str) noexcept;
    string_input(const string_input&amp; other) = default;
   ~string_input() = default;
    string_input&amp; operator=(const string_input&amp; other) = default;

    <c>// <n><xref id="string_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);

    <c>// <n><xref id="string_input.modifiers"/>, modifiers:</n></c>
    void swap(string_input&amp; other) noexcept;

  private:
    const Ch* begin;  <c>// <n>exposition only</n></c>
    const Ch* end;    <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="string_input.special"/>, specialized algorithms:</n></c>
  template &lt;class Ch, class Tr>
    void swap(string_input&lt;Ch, Tr>&amp; left,
              string_input&lt;Ch, Tr>&amp; right) noexcept;
}
      </codeblock>

      <p>The class template <c>string_input</c> describes thin wrappers of on-memory character sequences without any ownership of them.</p>
      <p>The template parameter <c>Ch</c> shall be a char-like type. The template parameter <c>Tr</c> shall be a character traits type for <c>Ch</c>.</p>
      <p>An instance of <c>string_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Ch</c>.</p>

      <section id="string_input.cons">
        <name><c>string_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
explicit string_input(const Ch* str);
          </code>
          <requires><c>str</c> shall be a valid pointer to an element in a null terminated sequence.</requires>
          <effects>Initializes <c>begin</c> and <c>end_</c> with <c>str</c> and <c>str + Tr::length(in)</c> respectively.</effects>
          <throws>Nothing.</throws>
        </code-item>

        <code-item>
          <code>
string_input(const Ch* data, std::size_t length);
          </code>
          <requires>[<c>data</c>, <c>data + length</c>) shall be a valid range.</requires>
          <effects>Initializes <c>begin</c> with <c>data</c> and <c>end</c> with <c>data + length</c>.</effects>
          <throws>Nothing.</throws>
        </code-item>

        <code-item>
          <code>
template &lt;class Allocator>
  explicit string_input(const std::basic_string&lt;Ch, Tr, Allocator>&amp; str) noexcept;
          </code>
          <effects>Initializes <c>begin</c> with <c>str.data()</c> and <c>end</c> with <c>str.data() + str.size()</c>.</effects>
        </code-item>
      </section>

      <section id="string_input.inv">
        <name><c>string_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <preface>Let <c>rlen</c> be the smaller of <c>n</c> and <c>end - begin</c>.</preface>
          <requires>[<c>out</c>, <c>out + rlen</c>) shall be a valid range for output.</requires>
          <effects>Calls <c>Tr::copy(out, begin, rlen)</c>, and then evaluates <c>begin += rlen</c>.</effects>
          <returns><c>rlen</c>.</returns>
          <throws>Nothing.</throws>
        </code-item>
      </section>

      <section id="string_input.modifiers">
        <name><c>string_input</c> modifiers</name>

        <code-item>
          <code>
void swap(string_input&amp; other) noexcept;
          </code>
          <effects>Exchanges <c>begin</c> and <c>other.begin</c>, and, <c>end</c> and <c>other.end</c>, respectively.</effects>
        </code-item>
      </section>

      <section id="string_input.special">
        <name><c>string_input</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Ch, class Tr>
  void swap(string_input&lt;Ch, Tr>&amp; left,
            string_input&lt;Ch, Tr>&amp; right) noexcept;
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
        </code-item>
      </section>
    </section>

    <section id="owned_string_input">
      <name>Class template <c>owned_string_input</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class owned_string_input {
  public:
    using string_type = std::basic_string&lt;Ch, Tr, Allocator>;
    using char_type   = Ch;
    using traits_type = Tr;
    using size_type   = typename string_type::size_type;

    <c>// <n><xref id="owned_string_input.cons"/>, construct/copy/destroy:</n></c>
    owned_string_input() noexcept(<nc>see below</nc>);
    explicit owned_string_input(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; str) noexcept;
    owned_string_input(const owned_string_input&amp; other);
    owned_string_input(owned_string_input&amp;&amp; other) noexcept;
   ~owned_string_input() = default;
    owned_string_input&amp; operator=(const owned_string_input&amp; other);
    owned_string_input&amp; operator=(owned_string_input&amp;&amp; other) : noexcept(<nc>see below</nc>);

    <c>// <n><xref id="owned_string_input.inv"/>, invocation:</n></c>
    size_type operator()(Ch* out, size_type n);

    <c>// <n><xref id="owned_string_input.modifiers"/>, modifiers:</n></c>
    void swap(owned_string_input&amp; other) noexcept(<nc>see below</nc>);

  private:
    std::basic_string&lt;Ch, Tr, Allocator> s;     <c>// <n>exposition only</n></c>
    size_type head;                             <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="owned_string_input.special"/>, specialized algorithms:</n></c>
  template &lt;class Ch, class Tr, class Allocator>
    void swap(owned_string_input&lt;Ch, Tr, Allocator>&amp; left,
              owned_string_input&lt;Ch, Tr, Allocator>&amp; right) noexcept(<nc>see below</nc>);
}
      </codeblock>

      <p>The class template <c>owned_string_input</c> describes thin wrappers of an object of an instance of <c>std::basic_string</c> with the ownership of it.</p>
      <p>The template parameter <c>Ch</c> shall be a char-like type. The template parameter <c>Tr</c> shall be a character traits type for <c>Ch</c>.</p>
      <p>An instance of <c>owned_string_input</c> meets the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for <c>Ch</c>.</p>

      <section id="owned_string_input.cons">
        <name><c>owned_string_input</c> construct/copy/destroy</name>

        <code-item>
          <code>
owned_string_input() noexcept(<nc>see below</nc>);
          </code>
          <effects>Value-initializes <c>s</c> and initializes <c>head</c> with <c>0</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_default_constructible&lt;std::basic_string&lt;Ch, Tr, Allocator>>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
explicit owned_string_input(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; str) noexcept;
          </code>
          <effects>Initializes <c>s</c> with <c>std::move(str)</c> and <c>head</c> with <c>0</c>.</effects>
        </code-item>

        <code-item>
          <code>
owned_string_input(const owned_string_input&amp; other);
          </code>
          <effects>Initializes <c>s</c> with <c>other.s</c>, <c>other.head</c>, <c>std::basic_string&lt;Ch, Tr, Allocator>::npos</c> and <c>std::allocator_traits&lt;Allocator>::select_on_container_copy_construction(other.s.get_allocator())</c>, and <c>head</c> with <c>0</c>.</effects>
        </code-item>

        <code-item>
          <code>
owned_string_input(owned_string_input&amp;&amp; other) noexcept;
          </code>
          <effects>Initializes <c>s</c> with <c>std::move(other.s)</c> and <c>head</c> with <c>other.head</c>, and then assigns <c>other.size()</c> to <c>other.head</c>.</effects>
        </code-item>

        <code-item>
          <code>
owned_string_input&amp; operator=(const owned_string_input&amp; other);
          </code>
          <effects>Make <c>s.compare(head, s.size() - head, other.s, other.head)</c> be <c>0</c>.
                   Replaces the allocator of <c>s</c> with the allocator of <c>other.s</c> if and only if <c>std::allocator_traits&lt;Allocator>::propagate_on_container_copy_assignment</c> is <c>true</c>.</effects>
          <remark>If an exception is thrown by this function, the invocation shall have no effect.</remark>
        </code-item>

        <code-item>
          <code>
owned_string_input&amp; operator=(owned_string_input&amp;&amp; other) : noexcept(<nc>see below</nc>);
          </code>
          <effects>Assigns <c>std::move(other.s)</c> to <c>s</c> and <c>other.head</c> to <c>head</c>, and then assigns <c>other.size()</c> to <c>other.head</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_assignable&lt;std::basic_string&lt;Ch, Tr, Allocator>>::value</c>.</remark>
        </code-item>
      </section>

      <section id="owned_string_input.inv">
        <name><c>owned_string_input</c> invocation</name>

        <code-item>
          <code>
size_type operator()(Ch* out, size_type n);
          </code>
          <effects>Calls <c>s.copy(out, n, head)</c> and let <c>rlen</c> be the return value, and then evaluates <c>head += rlen</c>.</effects>
          <returns><c>rlen</c> above.</returns>
          <throws>Nothing.</throws>
        </code-item>
      </section>

      <section id="owned_string_input.modifiers">
        <name><c>owned_string_input</c> modifiers</name>

        <code-item>
          <code>
void swap(owned_string_input&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Exchanges <c>s</c> and <c>other.s</c>, and, <c>head</c> and <c>other.head</c>, respectively.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to the value of <c>noexcept(swap(std::declval&lt;std::basic_string&lt;Ch, Tr, Allocator>&amp;>(), std::declval&lt;std::basic_string&lt;Ch, Tr, Allocator>&amp;>()))</c> evaluated in a context where <c>std::swap</c> participates in the overload resolution.</remark>
        </code-item>
      </section>

      <section id="owned_string_input.special">
        <name><c>owned_string_input</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Ch, class Tr, class Allocator>
  void swap(owned_string_input&lt;Ch, Tr, Allocator>&amp; left,
            owned_string_input&lt;Ch, Tr, Allocator>&amp; right) noexcept(<nc>see below</nc>);
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>noexcept(left.swap(right))</c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="char_input.creation">
      <name><c>CharInput</c> creation functions</name>

      <code-item>
        <code>
template &lt;class Ch, class Tr>
  streambuf_input&lt;Ch, Tr> make_char_input(std::basic_streambuf&lt;Ch, Tr>* in);
template &lt;class Ch, class Tr>
  streambuf_input&lt;Ch, Tr> make_char_input(std::basic_istream&lt;Ch, Tr>&amp; in) noexcept;
        </code>
        <requires>In the first form, <c>in</c> shall be a valid pointer to a stream buffer object.</requires>
        <returns><c>streambuf_input&lt;Ch, Tr>(in)</c>.</returns>
        <throws>Nothing.</throws>
      </code-item>

      <code-item>
        <code>
template &lt;class Streambuf>
  owned_streambuf_input&lt;Streambuf> make_char_input(Streambuf&amp;&amp; in) noexcept(<nc>see below</nc>);
        </code>
        <returns><c>owned_streambuf_input&lt;Streambuf>(std::move(in))</c>.</returns>
        <remark>This overload shall not participate in overload resolution unless the template parameter <c>Streambuf</c> is not an lvalue reference and is the same type as, or is a derived type of, <c>std::basic_streambuf&lt;Ch, Tr></c> for a certain combination of <c>Ch</c> and <c>Tr</c>.
                The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;owned_streambuf_input&lt;Streambuf>, Streambuf&amp;&amp;>::value</c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class IStream>
  owned_istream_input&lt;IStream> make_char_input(IStream&amp;&amp; in) noexcept(<nc>see below</nc>);
        </code>
        <returns><c>owned_istream_input&lt;IStream>(std::move(in))</c>.</returns>
        <remark>This overload shall not participate in overload resolution unless the template parameter <c>IStream</c> is not an lvalue reference and is the same type as, or is a derived type of, <c>std::basic_istream&lt;Ch, Tr></c> for a certain combination of <c>Ch</c> and <c>Tr</c>.
                The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;owned_istream_input&lt;IStream>, IStream&amp;&amp;>::value</c>.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr = std::char_traits&lt;Ch>>
  string_input&lt;Ch, Tr> make_char_input(const Ch* in);
template &lt;class Ch, class Tr = std::char_traits&lt;Ch>>
  string_input&lt;Ch, Tr> make_char_input(const Ch* in, std::size_t length);
template &lt;class Ch, class Tr, class Allocator>
  string_input&lt;Ch, Tr>
    make_char_input(const std::basic_string&lt;Ch, Tr, Allocator>&amp; in) noexcept;
        </code>
        <requires>In the first form, <c>in</c> shall be a valid pointer to an element in a null terminated sequence.
                  In the second form, [<c>in</c>, <c>in + length</c>) shall be a valid range.</requires>
        <returns><c>string_input&lt;Ch, Tr>(in)</c> or <c>string_input&lt;Ch, Tr>(in, length)</c>.</returns>
        <throws>Nothing.</throws>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr, class Allocator>
  owned_string_input&lt;Ch, Tr, Allocator>
    make_char_input(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; in) noexcept;
        </code>
        <returns><c>owned_string_input&lt;Ch, Tr, Allocator>(std::move(in))</c>.</returns>
      </code-item>
    </section>
  </section>

  <section id="parser.csv">
    <name>Parsing CSV format texts</name>

    <section id="parser.csv.general">
      <name>General</name>
      <p>This subclause describes facilities to create or utilize the table parser (<xref id="concepts"/>) of the CSV text format (<xref id="definitions.csv_text"/>).</p>
    </section>

    <section id="header_parse_csv_hpp">
      <name>Header <c>"commama/parse_csv.hpp"</c> synopsis</name>
      <codeblock>
#include &lt;cstddef>
#include &lt;functional>
#include &lt;istream>
#include &lt;memory>
#include &lt;streambuf>

#include "parse_error.hpp"
#include "char_input.hpp"

namespace commata {
  <c>// <n><xref id="csv_source"/>, csv_source:</n></c>
  template &lt;class CharInput> class csv_source;
  template &lt;class CharInput>
    void swap(csv_source&lt;CharInput>&amp; left, csv_source&lt;CharInput>&amp; right) noexcept(<nc>see below</nc>);
  template &lt;class... Args> auto make_csv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>)
    -> csv_source&lt;decltype(make_char_input(std::forward&lt;Args>(args)...))>;

  <c>// <n><xref id="parse_csv"/>, functions that utilize the CSV parser:</n></c>
  template &lt;class Input, class... Args> bool parse_csv(Input&amp;&amp; in, Args&amp;&amp;... args);
}
      </codeblock>
    </section>

    <section id="csv_source">
      <name>Class template <c>csv_source</c></name>

      <codeblock>
namespace commata {
  template &lt;class CharInput> class csv_source {
  public:
    using char_type = typename CharInput::char_type;
    using traits_type = typename CharInput::traits_type;
    template &lt;class Handler, class Allocator = void> using parser_type = <nc>unspecified</nc>;
    template &lt;class Handler> using reference_handler_type = <nc>unspecified</nc>;
  
    <c>// <n><xref id="csv_source.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class... Args> explicit csv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>);
    csv_source(const csv_source&amp; other) = default;
    csv_source(csv_source&amp;&amp; other) = default;
   ~csv_source() = default;
    csv_source&amp; operator=(const csv_source&amp; other) = default;
    csv_source&amp; operator=(csv_source&amp;&amp; other) = default;

    <c>// <n><xref id="csv_source.inv"/>, invocation:</n></c>
    template &lt;class HandlerR>
      parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler) const&amp; noexcept(<nc>see below</nc>);
    template &lt;class HandlerR>
      parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler) &amp;&amp; noexcept(<nc>see below</nc>);
    template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
      parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
        operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
                   const Allocator&amp; alloc = Allocator()) const&amp; noexcept(<nc>see below</nc>);
    template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
      parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
        operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
                   const Allocator&amp; alloc = Allocator()) &amp;&amp; noexcept(<nc>see below</nc>);
    template &lt;class Handler, class... Args>
      <nc>see below</nc> operator()(const std::reference_wrapper&lt;Handler>&amp; handler,
                           Args&amp;&amp;... args) const&amp; noexcept;
    template &lt;class Handler, class... Args>
      <nc>see below</nc> operator()(const std::reference_wrapper&lt;Handler>&amp; handler,
                           Args&amp;&amp;... args) &amp;&amp; noexcept;

    <c>// <n><xref id="csv_source.modifiers"/>, modifiers:</n></c>
    void swap(csv_source&amp; other) noexcept(<nc>see below</nc>);

  private:
    CharInput in;   <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="csv_source.special"/>, specialized algorithms:</n></c>
  template &lt;class CharInput>
    void swap(csv_source&lt;CharInput>&amp; left, csv_source&lt;CharInput>&amp; right) noexcept(<nc>see below</nc>);

  <c>// <n><xref id="csv_source.creation"/>, creation functions:</n></c>
  template &lt;class... Args> auto make_csv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>)
    -> csv_source&lt;decltype(make_char_input(std::forward&lt;Args>(args)...))>;
}
      </codeblock>

      <p>The class template <c>csv_source</c> describes thin wrappers of sequences of characters that work as factories of <c>TableParser</c> objects (<xref id="table_parser.requirements"/>) of the CSV text format (<xref id="definitions.csv_text"/>).</p>
      <p>The template parameter <c>CharInput</c> shall meet the <c>CharInput</c> requirements (<xref id="char_input.requirements"/>) for a certain char-like type.</p>
      <p><c>csv_source&lt;CharInput></c> shall meet the <c>TableSource</c> requirements (<xref id="table_source.requirements"/>) for the type <c>CharInput::char_type</c>.</p>

      <section id="csv_source.cons">
        <name><c>csv_source</c> construct/copy/destroy</name>

        <code-item>
          <code>
template &lt;class... Args> explicit csv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>);
          </code>
          <effects>Initializes <c>in</c> with <c>std::forward&lt;Args>(args)...</c>.</effects>
          <remark>This constructor shall not participate in overload resolution if <c>sizeof...(Args)</c> is equal to <c>1</c> and
                  <c>csv_source&lt;CharInput></c> is a base class of or the same type as the reference-removed and cv-unqualified type of the first type of <c>args</c>.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;CharInput, Args&amp;&amp;...>::value</c>.</remark>
        </code-item>
      </section>

      <section id="csv_source.inv">
        <name><c>csv_source</c> invocation</name>

        <code-item>
          <code>
template &lt;class HandlerR>
  parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler) const&amp; noexcept(<nc>see below</nc>);
template &lt;class HandlerR>
  parser_type&lt;std:decay_t&lt;HandlerR>> operator()(HandlerR&amp;&amp; handler) &amp;&amp; noexcept(<nc>see below</nc>);
          </code>
          <preface>Let <c>Handler</c> be <c>std::decay_t&lt;HandlerR></c>.</preface>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>char_type</c>.</requires>
          <returns>A table parser object <c>p</c> for the CSV text format (<xref id="definitions.csv_text"/>) whose type (hereinafter called <c>P</c>) meets the <c>TableParser</c> requirements (<xref id="table_parser.requirements"/>) for <c>char_type</c>.
                   <c>p</c> holds an object of <c>CharInput</c> constructed with <c>in</c> (<c>&amp;</c> ref-qualifier version) or <c>std::move(in)</c> (<c>&amp;&amp;</c> ref-qualifier version) as its tied character input
                   and an object of <c>Handler</c> constructed with <c>std::forward&lt;HandlerR>(handler)</c> as its tied table handler.
                   <c>std::nothrow_move_constructible&lt;P>::value</c> shall be <c>true</c> if <c>std::nothrow_move_constructible&lt;Handler>::value</c> is <c>true</c>.
                   Invocation of <c>p()</c> might throw <c>parse_error</c> (<xref id="parse_error"/>), <c>std::bad_alloc</c> or any exception thrown by the tied table handler object.
                   <c>P</c> implements the optional <c>TableParser</c> operation <c>get_physical_position</c> (<xref id="table_parser.requirements"/>) with <c>noexcept(true)</c> exception specification.</returns>
          <remark>These member function templates shall not participate in overload resolution unless the reference-removed and cv-unqualified type of <c>HandlerR</c> is not an instance of <c>std::reference_wrapper</c> and has both of <c>get_buffer</c> and <c>release_buffer</c> member functions
                  that have signatures and return types compatible with <c>TableHandler</c> requirements.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;Handler, HandlerR&amp;&amp;>::value &amp;&amp; std::is_nothrow_move_constructible&lt;Handler>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
  parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
    operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
               const Allocator&amp; alloc = Allocator()) const&amp; noexcept(<nc>see below</nc>);
template &lt;class HandlerR, class Allocator = std::allocator&lt;char_type>>
  parser_type&lt;std:decay_t&lt;HandlerR>, Allocator>
    operator()(HandlerR&amp;&amp; handler, std::size_t buffer_size = 0,
               const Allocator&amp; alloc = Allocator()) &amp;&amp; noexcept(<nc>see below</nc>);
          </code>
          <preface>Let <c>Handler</c> be <c>std::decay_t&lt;HandlerR></c>.</preface>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>char_type</c>.
                    <c>Allocator</c> shall meet the <c>Allocator</c> requirements for <c>char_type</c>.</requires>
          <returns>A table parser object <c>p</c> for the CSV text format (<xref id="definitions.csv_text"/>) whose type (hereinafter called <c>P</c>) meets the <c>TableParser</c> requirements (<xref id="table_parser.requirements"/>) for <c>char_type</c>.
                   <c>p</c> holds an object of <c>CharInput</c> constructed with <c>in</c> (<c>&amp;</c> ref-qualifier version) or <c>std::move(in)</c> (<c>&amp;&amp;</c> ref-qualifier version) as its tied character input
                   and an object of <c>Handler</c> constructed with <c>std::forward&lt;HandlerR>(handler)</c> as its tied table handler,
                   and allocates and deallocates character buffers with a copy of <c>alloc</c>.
                   The length of the buffer is unspecified, but <c>buffer_size</c> serves as a hint. <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.
                   <c>std::nothrow_move_constructible&lt;P>::value</c> shall be <c>true</c> if <c>std::nothrow_move_constructible&lt;Handler>::value</c> is <c>true</c>.
                   Invocation of <c>p()</c> might throw <c>parse_error</c> (<xref id="parse_error"/>), <c>std::bad_alloc</c> or any exception thrown by the tied table handler object and the copy of <c>alloc</c>.
                   <c>P</c> implements the optional <c>TableParser</c> operation <c>get_physical_position</c> (<xref id="table_parser.requirements"/>) with <c>noexcept(true)</c> exception specification.</returns>
          <remark>These member function templates shall not participate in overload resolution unless the reference-removed and cv-unqualified type of <c>HandlerR</c> is not an instance of <c>std::reference_wrapper</c> and does not have both of <c>get_buffer</c> and <c>release_buffer</c> member function
                  that has a signature and a return type compatible with <c>TableHandler</c> requirements.
                  The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;Handler, HandlerR&amp;&amp;>::value &amp;&amp; std::is_nothrow_move_constructible&lt;Handler>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Handler, class... Args>
  <nc>see below</nc> operator()(const std::reference_wrapper&lt;Handler>&amp; handler,
                       Args&amp;&amp;... args) const&amp; noexcept;
template &lt;class Handler, class... Args>
  <nc>see below</nc> operator()(const std::reference_wrapper&lt;Handler>&amp; handler,
                       Args&amp;&amp;... args) &amp;&amp; noexcept;
          </code>
          <requires><c>Handler</c> shall meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>char_type</c>,
                    except that it need not meet either the <c>MoveConstructible</c> requirement or the <c>Destructible</c> requirements.</requires>
          <effects>Creates an object <c>h</c> whose type <c>H</c> is equal to <c>reference_handler_type&lt;Handler></c> and meets the <c>TableHandler</c> requirements.
                   <c>h</c> wraps <c>handler.get()</c> and forwards calls to <c>handler.get()</c>.
                   <c>std::is_nothrow_move_constructible&lt;H>::value</c> is <c>true</c>.
                   Then forwards the call with the arguments being <c>std::move(h), args...</c> to the other <c>operator()</c> member function templates that have the same ref-qualifier.</effects>
          <returns>The return value of the forwarded call above.</returns>
        </code-item>
      </section>

      <section id="csv_source.modifiers">
        <name><c>csv_source</c> modifiers</name>

        <code-item>
          <code>
void swap(csv_source&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>in</c> shall be swappable with <c>other.in</c>.</requires>
          <effects>Exchanges <c>in</c> and <c>other.in</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to the value of <c>noexcept(swap(std::declval&lt;CharInput&amp;>(), std::declval&lt;CharInput&amp;>()))</c> evaluated in a context where <c>std::swap</c> participates in the overload resolution.</remark>
        </code-item>
      </section>

      <section id="csv_source.special">
        <name><c>csv_source</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class CharInput>
  void swap(csv_source&lt;CharInput>&amp; left, csv_source&lt;CharInput>&amp; right) noexcept(<nc>see below</nc>);
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>noexcept(left.swap(right))</c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="csv_source.creation">
      <name><c>csv_source</c> creation functions</name>

      <code-item>
        <code>
template &lt;class... Args> auto make_csv_source(Args&amp;&amp;... args) noexcept(<nc>see below</nc>)
  -> csv_source&lt;decltype(make_char_input(std::forward&lt;Args>(args)...))>;
        </code>
        <preface>Let <c>CI</c> be <c>decltype(make_char_input(std::forward&lt;Args>(args)...))</c>.</preface>
        <returns><c>csv_source&lt;CI>(make_char_input(std::forward&lt;Args>(args)...))</c>.</returns>
        <remark>The expression inside <c>noexcept</c> is equivalent to <c>noexcept(make_char_input(std::forward&lt;Args>(args)...)) &amp;&amp; std::is_nothrow_move_constructible&lt;CI>::value</c>.</remark>
      </code-item>
    </section>

    <section id="parse_csv">
      <name>Utilizing the CSV parser</name>

      <code-item>
        <code>
template &lt;class Arg1, class Arg2, class... OtherArgs>
  bool parse_csv(Arg1&amp;&amp; arg1, Arg2&amp;&amp; arg2, OtherArgs&amp;&amp;... other_args);
        </code>
        <effects><p>If <c>make_csv_source(std::declval&lt;Arg1>(), std::declval&lt;Arg2>())</c> is well-formed when treated as an unevaluated operand, equivalent to:</p>
                 <code>return make_csv_source(std::forward&lt;Arg1>(arg1), std::forward&lt;Arg2>(arg2))
                      (std::forward&lt;OtherArgs>(other_args)...)
                      ();</code>
                 <p>Otherwise, equivalent to:</p>
                 <code>return make_csv_source(std::forward&lt;Arg1>(arg1))
                      (std::forward&lt;Arg2>(arg2), std::forward&lt;OtherArgs>(other_args)...)
                      ();</code></effects>
        <remark>This function template shall not participate in overload resolution unless either of <c>make_csv_source(std::declval&lt;Arg1>(), std::declval&lt;Arg2>())</c> or <c>make_csv_source(std::declval&lt;Arg1>(), std::declval&lt;Arg2>())</c> is well-formed when treated as an unevaluated operand.</remark>
      </code-item>
    </section>
  </section>
</section>

<section id="built-in_handlers">
  <name>Default table handlers</name>

  <section id="extractor">
    <name>Extraction of records into another stream</name>

    <section id="extractor.general">
      <name>General</name>

      <p>Commata offers two class templates <c>record_extractor</c> (<xref id="record_extractor"/>) and <c>record_extractor_with_indexed_key</c> (<xref id="record_extractor_with_indexed_key"/>), whose instances meet <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>), as simple facilities to reduce text records.</p>
      <p>An object of an instance of <c>record_extractor</c> or <c>record_extractor_with_indexed_key</c> receives parsing events from a parser and forwards some qualified records into another stream.
         Whether a record is qualified to be forwarded or not is decided by the value of its field at the <n>target field index</n>.
         The target field index can be given explicitly by the program (with <c>record_extractor_with_indexed_key</c>), or can be decided in reference to the first one record (with <c>record_extractor</c>).</p>
      <p>A record that can not be decided whether it is qualified to be forwarded or not due to non-existence of the field at the target field index shall cause an exception.</p>
      <p>An object of an instance of <c>record_extractor</c> or <c>record_extractor_with_indexed_key</c> can not be reused; that is, it can receive the parsing events that the parser emits only once.</p>
    </section>

    <section id="record_extractor_hpp">
      <name>Header <c>"commama/record_extractor.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;memory>
#include &lt;ostream>
#include &lt;streambuf>
#include &lt;string>
#include &lt;type_traits>

#include "text_error.hpp"

namespace commata {
  <c>// <n><xref id="record_extraction_error"/>, record_extraction_error:</n></c>
  class record_extraction_error;

  enum header_forwarding : unsigned {
    header_forwarding_yes = 1,
    header_forwarding_no  = 2
  };

  constexpr std::size_t record_extractor_npos = -1;

  <c>// <n><xref id="record_extractor"/>, record_extractor:</n></c>
  template &lt;class FieldNamePred, class FieldValuePred, class Ch, class Tr, class Allocator>
    class record_extractor;

  <c>// <n><xref id="record_extractor_with_indexed_key"/>, record_extractor_with_indexed_key:</n></c>
  template &lt;class FieldValuePred, class Ch, class Tr, class Allocator>
    class record_extractor_with_indexed_key;

  <c>// <n><xref id="record_extractor.creation"/>, creation functions:</n></c>
  template &lt;class FieldNamePred, class FieldValuePred,
            class Ch, class Tr, class Allocator, class... Appendices>
    <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                    std::basic_streambuf&lt;Ch, Tr>* out,
                                    FieldNamePred&amp;&amp; field_name_pred,
                                    FieldValuePred&amp;&amp; field_value_pred,
                                    Appendices&amp;&amp;... appendices);
  template &lt;class FieldValuePred,
            class Ch, class Tr, class Allocator, class... Appendices>
    <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                    std::basic_streambuf&lt;Ch, Tr>* out,
                                    std::size_t target_field_index,
                                    FieldValuePred&amp;&amp; field_value_pred,
                                    Appendices&amp;&amp;... appendices);
  template &lt;class Ch, class Tr, class Allocator, class... Appendices>
    <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                    std::basic_ostream&lt;Ch, Tr>&amp; out, Appendices&amp;&amp;... appendices);
  template &lt;class FieldIdentifier, class FieldValuePred, class Ch, class Tr, class... Appendices>
    <nc>see below</nc> make_record_extractor(std::basic_streambuf&lt;Ch, Tr>* out,
                                    FieldIdentifier&amp;&amp; field_id,
                                    FieldValuePred&amp;&amp; field_value_pred,
                                    Appendices&amp;&amp;... appendices);
  template &lt;class Ch, class Tr, class... Appendices>
    <nc>see below</nc> make_record_extractor(std::basic_ostream&lt;Ch, Tr>&amp; out,
                                    Appendices&amp;... appendices);
}
      </codeblock>
    </section>

    <section id="record_extraction_error">
      <name>Class <c>record_extraction_error</c></name>

      <codeblock>
namespace commata {
  class record_extraction_error : public text_error {
  public:
    using text_error::text_error;
  };
}
      </codeblock>

      <p>The class <c>record_extraction_error</c> defines a type of the objects thrown by <c>record_extractor</c> objects and <c>record_extractor_with_indexed_key</c> objects during the parsing.</p>
    </section>

    <section id="record_extractor">
      <name>Class template <c>record_extractor</c></name>

      <codeblock>
namespace commata {
  template &lt;class FieldNamePred, class FieldValuePred, class Ch,
            class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class record_extractor {
  public:
    using char_type = Ch;
    using traits_type = Tr;
    using allocator_type = Allocator;

    <c>// <n><xref id="record_extractor.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class FieldNamePredR, class FieldValuePredR>
      record_extractor(std::basic_streambuf&lt;Ch, Tr>* out,
                       FieldNamePredR&amp;&amp; field_name_pred, FieldValuePredR&amp;&amp; field_value_pred,
                       header_forwarding header = header_forwarding_yes,
                       std::size_t max_record_num = 0);
    template &lt;class FieldNamePredR, class FieldValuePredR>
      record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                       std::basic_streambuf&lt;Ch, Tr>* out,
                       FieldNamePredR&amp;&amp; field_name_pred, FieldValuePredR&amp;&amp; field_value_pred,
                       header_forwarding header = header_forwarding_yes,
                       std::size_t max_record_num = 0);
    record_extractor(record_extractor&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~record_extractor();

    <c>// <n><xref id="record_extractor.accessors"/>, accessors:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n>six member functions below are declared and defined to meet the TableHandler</n>
    // <n>requirements (<xref id="table_handler.requirements"/>):</n></c>
    void start_buffer(const Ch* buffer_begin, const Ch* buffer_end);
    void end_buffer(const Ch* buffer_end);
    void start_record(const Ch* record_begin);
    bool end_record(const Ch* record_end);
    void update(const Ch* first, const Ch* last);
    void finalize(const Ch* first, const Ch* last);

    <c>// <n><xref id="record_extractor.processing_state"/>, processing state:</n></c>
    bool is_in_header() const noexcept;
  };
}
      </codeblock>

      <p>An instance of <c>record_extractor</c> is a type that meets <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for the template parameter <c>Ch</c>.</p>
      <p>An object of it first scans the first record (hereinafter called the <n>header record</n>) to decide the target field index,
         and then scan the all non-header records to decide whether the record is forwarded to the stream in terms of their values of the field at the target field index.</p>
      <p>When the target field index is left undecided after the scanning of <c>record_extractor_npos - 1</c> text fields in the header record finished, an exception shall be thrown.</p>
      <p><c>FieldNamePred</c> and <c>FieldValuePred</c> shall be binary predicate types for two <c>const Ch*</c> parameters.
         <c>Ch</c> shall be a char-like type.
         <c>Tr</c> shall be a character traits type of <c>std::remove_const_t&lt;Ch></c>.
         <c>Allocator</c> shall meet the <c>Allocator</c> requirements.</p>
      <p>When the implementations of this class template throw an exception whose type is <c>text_error</c> or one of its derived classes, the message retrieved with a call to <c>what</c> member function on the exception object may be an NTMBS converted from an wide character string with <c>std::wcrtomb</c> or <c>std::wcsrtombs</c>, that is, with C's global locale.</p>

      <section id="record_extractor.cons">
        <name><c>record_extractor</c> constructors and assignment operators</name>

        <code-item>
          <code>
template &lt;class FieldNamePredR, class FieldValuePredR>
  record_extractor(std::basic_streambuf&lt;Ch, Tr>* out,
                   FieldNamePredR&amp;&amp; field_name_pred, FieldValuePredR&amp;&amp; field_value_pred,
                   header_forwarding header = header_forwarding_yes,
                   std::size_t max_record_num = record_extractor_npos);
template &lt;class FieldNamePredR, class FieldValuePredR>
  record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                   std::basic_streambuf&lt;Ch, Tr>* out,
                   FieldNamePredR&amp;&amp; field_name_pred, FieldValuePredR&amp;&amp; field_value_pred,
                   header_forwarding header = header_forwarding_yes,
                   std::size_t max_record_num = record_extractor_npos);
          </code>
          <requires><c>out</c> shall be a valid pointer. For the first overload, <c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <effects>Constructs an object <c>record_extractor</c>. The parameters work as <xref id="table.record_extractor.cons"/> shows.
                   An object constructed by the first overload uses a default constructed <c>Allocator</c> object to allocate memory.
                   One constructed by the second overload uses an <c>Allocator</c> object copy constructed from <c>alloc</c>.</effects>

          <table id="table.record_extractor.cons">
            <caption>Principal parameters of the constructors of <c>record_extractor</c> and the behaviour of the constructed object</caption>
            <col width="2"/><col width="12"/>
            <tr>
              <th>Parameter</th>
              <th>Remark</th>
            </tr>
            <tr>
              <td><c>out</c></td>
              <td>Points a stream buffer object that receives the extracted records.</td>
            </tr>
            <tr>
              <td><c>field_name_pred</c></td>
              <td>Forwarded as an argument to a constructor of <c>FieldNamePred</c> to make a predicate object called for every field in the header record.
                  The call parameters are <c>f</c> and <c>l</c> where the field value is the range [<c>f</c>, <c>l</c>).
                  If returns a non-<c>false</c> value, then the field index becomes the target field index.</td>
            </tr>
            <tr>
              <td><c>field_value_pred</c></td>
              <td>Forwarded as an argument to a constructor of <c>FieldNamePred</c> to make a predicate object called for every field at the target field index of non-header records.
                  The call parameters are <c>f</c> and <c>l</c> where the field value is the range [<c>f</c>, <c>l</c>).
                  If returns a non-<c>false</c> value, then the record is qualified to be forwarded to <c>out</c>.</td>
            </tr>
            <tr>
              <td><c>header</c></td>
              <td>If equal to <c>header_forwarding_yes</c>, the header record will always be forwarded to <c>out</c>.
                  Otherwise, if equal to <c>header_forwarding_no</c>, it will never be forwarded to <c>out</c>.
                  Otherwise, the behaviour is undefined.</td>
            </tr>
            <tr>
              <td><c>max_record_num</c></td>
              <td>If not equal to <c>0</c>, at most <c>max_record_num</c> non-header records are forwarded to <c>out</c>, and parsing will be aborted after <c>max_record_num</c> are forwarded.</td>
            </tr>
          </table>
        </code-item>

        <code-item>
          <code>
record_extractor(record_extractor&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <effects>Move constructs from an rvalue <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;FieldNamePred>::value &amp;&amp; std::is_nothrow_move_constructible&lt;FieldValuePred>::value</c>.
                  When this constructor exits via an exception, <c>other</c> will be placed in a valid but unspecified state.</remark>
        </code-item>
      </section>

      <section id="record_extractor.accessors">
        <name><c>record_extractor</c> accessors</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object used to allocate memory by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="record_extractor.processing_state">
        <name><c>record_extractor</c> processing state</name>
        <code-item>
          <code>
bool is_in_header() const noexcept;
          </code>
          <requires>Shall be invoked within a call of <c>parse_csv</c> (<xref id="parse_csv"/>).</requires>
          <returns><c>true</c> if <c>end_record</c> has not be called for the header record; <c>false</c> otherwise.</returns>
          <note>This member may be useful to implement a table handler class whose object wraps a <c>record_extractor</c> object.</note>
        </code-item>
      </section>
    </section>

    <section id="record_extractor_with_indexed_key">
      <name>Class template <c>record_extractor_with_indexed_key</c></name>

      <codeblock>
namespace commata {
  template &lt;class FieldValuePred, class Ch,
            class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class record_extractor_with_indexed_key {
  public:
    using char_type = Ch;
    using traits_type = Tr;
    using allocator_type = Allocator;

    <c>// <n><xref id="record_extractor_with_indexed_key.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class FieldValuePredR>
      record_extractor_with_indexed_key(std::basic_streambuf&lt;Ch, Tr>* out,
                                        std::size_t target_field_index,
                                        FieldValuePredR&amp;&amp; field_value_pred,
                                        std::underlying_t&lt;header_forwarding> header
                                          = header_forwarding_yes,
                                        std::size_t max_record_num = 0);
    template &lt;class FieldValuePredR>
      record_extractor_with_indexed_key(std::allocator_arg_t, const Allocator&amp; alloc,
                                        std::basic_streambuf&lt;Ch, Tr>* out,
                                        std::size_t target_field_index,
                                        FieldValuePredR&amp;&amp; field_value_pred,
                                        std::underlying_t&lt;header_forwarding> header
                                          = header_forwarding_yes,
                                        std::size_t max_record_num = 0);
    record_extractor_with_indexed_key(record_extractor_with_indexed_key&amp;&amp; other)
                                      noexcept(<nc>see below</nc>);
   ~record_extractor_with_indexed_key();

    <c>// <n><xref id="record_extractor_with_indexed_key.accessors"/>, accessors:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n>six member functions below are declared and defined to meet the TableHandler</n>
    // <n>requirements (<xref id="table_handler.requirements"/>):</n></c>
    void start_buffer(const Ch* buffer_begin, const Ch* buffer_end);
    void end_buffer(const Ch* buffer_end);
    void start_record(const Ch* record_begin);
    bool end_record(const Ch* record_end);
    void update(const Ch* first, const Ch* last);
    void finalize(const Ch* first, const Ch* last);

    <c>// <n><xref id="record_extractor_with_indexed_key.processing_state"/>, processing state:</n></c>
    bool is_in_header() const noexcept;
  };
}
      </codeblock>

      <p>An instance of <c>record_extractor_with_indexed_key</c> is a type that meets <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for the template parameter <c>Ch</c>.</p>
      <p>It regards the first at most one record as the <n>header record</n>.
         It scans the all non-header records to decide whether the record is forwarded to the stream in terms of their values of the field at the target field index instructed with a parameter of its constructor explicitly.</p>
      <p><c>FieldValuePred</c> shall be a binary predicate type for two <c>const Ch*</c> parameters.
         <c>Ch</c> shall be a char-like type.
         <c>Tr</c> shall be a character traits type of <c>std::remove_const_t&lt;Ch></c>.
         <c>Allocator</c> shall meet the <c>Allocator</c> requirements.</p>

      <section id="record_extractor_with_indexed_key.cons">
        <name><c>record_extractor_with_indexed_key</c> constructors and assignment operators</name>

        <code-item>
          <code>
template &lt;class FieldValuePredR>
  record_extractor_with_indexed_key(std::basic_streambuf&lt;Ch, Tr>* out,
                                    std::size_t target_field_index,
                                    FieldValuePredR&amp;&amp; field_value_pred,
                                    std::underlying_t&lt;header_forwarding> header
                                      = header_forwarding_yes,
                                    std::size_t max_record_num = record_extractor_npos);
template &lt;class FieldValuePredR>
  record_extractor_with_indexed_key(std::allocator_arg_t, const Allocator&amp; alloc,
                                    std::basic_streambuf&lt;Ch, Tr>* out,
                                    std::size_t target_field_index,
                                    FieldValuePredR&amp;&amp; field_value_pred,
                                    std::underlying_t&lt;header_forwarding> header
                                      = header_forwarding_yes,
                                    std::size_t max_record_num = record_extractor_npos);
          </code>
          <requires><c>out</c> shall be a valid pointer. For the first overload, <c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <effects>Constructs an object <c>record_extractor_with_indexed_key</c>. The parameters work as <xref id="table.record_extractor_with_indexed_key.cons"/> shows.
                   An object constructed by the first overload uses a default constructed <c>Allocator</c> object to allocate memory.
                   One constructed by the second overload uses an <c>Allocator</c> object copy constructed from <c>alloc</c>.</effects>

          <table id="table.record_extractor_with_indexed_key.cons">
            <caption>Principal parameters of the constructors of <c>record_extractor_with_indexed_key</c> and the behaviour of the constructed object</caption>
            <col width="2"/><col width="12"/>
            <tr>
              <th>Parameter</th>
              <th>Remark</th>
            </tr>
            <tr>
              <td><c>out</c></td>
              <td>Points a stream buffer object that receives the extracted records.</td>
            </tr>
            <tr>
              <td><c>target_field_index</c></td>
              <td>Tells the zero-based target field index, which <c>field_value_pred</c> is applied. If equal to <c>record_extractor_npos</c>, this constructor exits with <c>std::out_of_range</c>.</td>
            </tr>
            <tr>
              <td><c>field_value_pred</c></td>
              <td>Forwarded as an argument to a constructor of <c>FieldNamePred</c> to make a predicate object called for every field at the target field index of non-header records.
                  The parameters are <c>f</c> and <c>l</c> where the field value is the range [<c>f</c>, <c>l</c>).
                  If returns a non-<c>false</c> value, then the record is qualified to be forwarded to <c>out</c>.</td>
            </tr>
            <tr>
              <td><c>header</c></td>
              <td>If equal to <c>0</c>, the first record of the text table will not be regarded as a header record, that is, it will be treated similarly to other records.
                  Otherwise, if equal to <c>header_forwarding_yes</c>, it will be regarded as a header record and will always be forwarded to <c>out</c>.
                  Otherwise, if equal to <c>header_forwarding_no</c>, it will be regarded as a header record and wiil never be forwarded to <c>out</c>.
                  Otherwise, the behaviour is undefined.</td>
            </tr>
            <tr>
              <td><c>max_record_num</c></td>
              <td>If not equal to <c>0</c>, at most <c>max_record_num</c> non-header records are forwarded to <c>out</c>, and parsing will be aborted after <c>max_record_num</c> are forwarded.</td>
            </tr>
          </table>
        </code-item>
        <code-item>
          <code>
record_extractor_with_indexed_key(record_extractor_with_indexed_key&amp;&amp; other)
                                  noexcept(<nc>see below</nc>);
          </code>
          <effects>Move constructs from an rvalue <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;FieldValuePred>::value</c>.</remark>
        </code-item>
      </section>

      <section id="record_extractor_with_indexed_key.accessors">
        <name><c>record_extractor_with_indexed_key</c> accessors</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object used to allocate memory by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="record_extractor_with_indexed_key.processing_state">
        <name><c>record_extractor_with_indexed_key</c> processing state</name>
        <code-item>
          <code>
bool is_in_header() const noexcept;
          </code>
          <requires>Shall be invoked within a call of <c>parse_csv</c> (<xref id="parse_csv"/>).</requires>
          <returns><c>true</c> if <c>*this</c> is configured to regard the first records as the header record and
                   <c>end_record</c> has not be called for the header record; <c>false</c> otherwise.</returns>
          <note>This member may be useful to implement a table handler class whose object wraps a <c>record_extractor_with_indexed_key</c> object.</note>
        </code-item>
      </section>
    </section>

    <section id="record_extractor.creation">
      <name><c>record_extractor</c> and <c>record_extractor_with_indexed_key</c> creation functions</name>

      <p>In this subclause, for some expressions <c>p</c> and <c>a</c>, <c><nc>STRING_PRED</nc>&lt;Ch, Tr>(p, a)</c>, which is an expression of a binary predicate that takes two <c>const Ch*</c> paramters denoted by <c>f</c> and <c>l</c> here, is defined as following:</p>
      <ul>
        <li>if <c>p</c> is an rvalue of cv-unqualified <c>std::basic_string&lt;Ch, Tr, A></c> for a certain <c>A</c>,
            a prvalue of a binary predicate object that holds an <c>std::basic_string&lt;Ch, Tr, A></c> object (hereinafter called <c>s</c>) initialized with <c>std::move(p)</c>,
            and tells if a range [<c>f</c>, <c>l</c>) is equal to <c>s</c> in terms of <c>Tr::eq</c>,
            and whose type <c>T</c> is unspecified but satisfies <c>std::is_nothrow_move_constructible&lt;T>::value == true</c>,</li>
        <li>otherwise, if <c>p</c> is an lvalue of possibly const-qualified and volatile-unqualified <c>std::basic_string&lt;Ch, Tr, A></c> for a certain <c>A</c>,
            a prvalue of a binary predicate object that holds copies of the return values of the calls of <c>p.data()</c> (hereinafter called <c>s</c>) and <c>p.size()</c> (hereinafter called <c>len</c>),
            and tells if a range [<c>f</c>, <c>l</c>) is equal to [<c>s</c>, <c>s + len</c>) in terms of <c>Tr::eq</c>,
            and whose type <c>T</c> is unspecified but satisfies <c>std::is_nothrow_move_constructible&lt;T>::value == true</c>,</li>
        <li>otherwise, if <c>p</c> is an expression whose type is possibly const-qualified <c>Ch*</c>,
            a prvalue of a binary predicate object that holds copies of <c>p</c> and the return value of of the call of <c>std::strlen(p)</c> (hereinafter called <c>len</c>),
            and tells if a range [<c>f</c>, <c>l</c>) is equal to [<c>p</c>, <c>p + len</c>) in terms of <c>Tr::eq</c>,
            and whose type <c>T</c> is unspecified but satisfies <c>std::is_nothrow_move_constructible&lt;T>::value == true</c>,</li>
        <li>otherwise, if <c>P::const_iterator</c> denotes a type where <c>P</c> is the type of <c>p</c>,
            a prvalue of a binary predicate object that holds an <c>std::basic_string&lt;Ch, Tr, Allocator></c> object (hereinafter called <c>s</c>) initialized with <c>p.cbegin()</c>, <c>p.cend()</c> and <c>a</c>,
            and tells if a range [<c>f</c>, <c>l</c>) is equal to <c>s</c> in terms of <c>Tr::eq</c>,
            and whose type <c>T</c> is unspecified but satisfies <c>std::is_nothrow_move_constructible&lt;T>::value == true</c>,</li>
        <li>otherwise, if <c>p</c> is a binary predicate that takes two <c>const Ch*</c> paramters, <c>p</c> itself,</li>
        <li>otherwise, the program is ill-formed.</li>
      </ul>

      <code-item>
        <code>
template &lt;class FieldNamePred, class FieldValuePred,
          class Ch, class Tr, class Allocator, class... Appendices>
  <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                  std::basic_streambuf&lt;Ch, Tr>* out,
                                  FieldNamePred&amp;&amp; field_name_pred,
                                  FieldValuePred&amp;&amp; field_value_pred,
                                  Appendices&amp;&amp;... appendices);
        </code>
        <effects><p>Equivalent to:</p>
                 <code>auto fnp = <n>STRING_PRED</n>&lt;Ch, Tr>(std::forward&lt;FieldNamePred>(field_name_pred), alloc);
auto fvp = <n>STRING_PRED</n>&lt;Ch, Tr>(std::forward&lt;FieldValuePred>(field_value_pred), alloc);
return record_extractor&lt;decltype(fnp), decltype(fvp), Ch, Tr, Allocator>(
         std::allocator_arg, alloc,
         out, std::move(fnp), std::move(fvp), std::forward&lt;Appendices>(appendices)...);</code>
        </effects>
        <remark>This overload shall not participate in overload resolution unless both of <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;FieldNamePred>(), std::declval&lt;Allocator>())</c> and
                <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;FieldValuePred>(), std::declval&lt;Allocator>())</c> are well-formed when treated as unevaluated operands.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class FieldValuePred,
          class Ch, class Tr, class Allocator, class... Appendices>
  <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                  std::basic_streambuf&lt;Ch, Tr>* out,
                                  std::size_t target_field_index,
                                  FieldValuePred&amp;&amp; field_value_pred,
                                  Appendices&amp;&amp;... appendices);
        </code>
        <effects><p>Equivalent to:</p>
                 <code>auto fvp = <n>STRING_PRED</n>&lt;Ch, Tr>(std::forward&lt;FieldValuePred>(field_value_pred), alloc);
return record_extractor_with_indexed_key&lt;decltype(fvp), Ch, Tr, Allocator>(
         std::allocator_arg, alloc,
         out, target_field_index, std::move(fvp), std::forward&lt;Appendices>(appendices)...);</code>
        </effects>
        <remark>This overload shall not participate in overload resolution unless <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;FieldValuePred>(), std::declval&lt;Allocator>())</c> is well-formed when treated as an unevaluated operand.</remark>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr, class Allocator, class... Appendices>
  <nc>see below</nc> make_record_extractor(std::allocator_arg_t, const Allocator&amp; alloc,
                                  std::basic_ostream&lt;Ch, Tr>&amp; out, Appendices&amp;&amp;... appendices);
        </code>
        <effects><p>Equivalent to:</p>
                 <code>return make_record_extractor(std::allocator_arg, alloc,
                             out.rdbuf(), std::forward&lt;Appendices>(appendices)...);</code>
        </effects>
        <remark><p>Let <c>Ts</c> be <c>std::tuple&lt;Appendices...></c> and <c>T&lt;N></c> be <c>typename std::tuple_element&lt;N, Ts>::type</c>.
                   This overload shall not participate in overload resolution unless <c>std::tuple_size&lt;Ts> > 1</c> is <c>true</c> and:</p>
                <ul>
                  <li>both of <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;T&lt;0>>(), std::declval&lt;Allocator>())</c> and <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;T&lt;1>>(), std::declval&lt;Allocator>())</c> are well-formed when treated as unevaluated operands, or</li>
                  <li><c>std::is_convertible&lt;T&lt;1>, std::size_t>::value</c> is <c>true</c> and <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;T&lt;1>>(), std::declval&lt;Allocator>())</c> is well-formed when treated as an unevaluated operand.</li>
                </ul>
        </remark>
      </code-item>

      <code-item>
        <code>
template &lt;class Ch, class Tr, class... Appendices>
  <nc>see below</nc> make_record_extractor(std::basic_streambuf&lt;Ch, Tr>* out,
                                  Appendices&amp;&amp;... appendices);
template &lt;class Ch, class Tr, class... Appendices>
  <nc>see below</nc> make_record_extractor(std::basic_ostream&lt;Ch, Tr>&amp; out,
                                  Appendices&amp;&amp;... appendices);
        </code>
        <effects><p>Equivalent to:</p>
                 <code>return make_record_extractor(std::allocator_arg, std::allocator&lt;Ch>(),
                             out, std::forward&lt;Appendices>(appendices)...);</code>
        </effects>
        <remark><p>Let <c>Ts</c> be <c>std::tuple&lt;Appendices...></c> and <c>T&lt;N></c> be <c>typename std::tuple_element&lt;N, Ts>::type</c>.
                   These overloads shall not participate in overload resolution unless <c>std::tuple_size&lt;Ts> > 1</c> is <c>true</c> and:</p>
                <ul>
                  <li>both of <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;T&lt;0>>(), std::declval&lt;Allocator>())</c> and <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;T&lt;1>>(), std::declval&lt;Allocator>())</c> are well-formed when treated as unevaluated operands, or</li>
                  <li><c>std::is_convertible&lt;T&lt;1>, std::size_t>::value</c> is <c>true</c> and <c><n>STRING_PRED</n>&lt;Ch, Tr>(std::declval&lt;T&lt;1>>(), std::declval&lt;Allocator>())</c> is well-formed when treated as an unevaluated operand.</li>
                </ul>
        </remark>
      </code-item>
    </section>
  </section>

  <section id="table">
    <name>Creation of a whole table image in memory</name>

    <section id="table.general">
      <name>General</name>

      <p>Commata offers class template <c>basic_stored_table</c> (<xref id="basic_stored_table"/>), which is an implementation of a in-memory text table (<xref id="definitions.text_table"/>).
         The text values of text fields contained by an object of an instance of it are represented by class template <c>basic_stored_value</c> (<xref id="basic_stored_value"/>),
         whose instance is a type whose object is actually a contiguous and null-terminated range of char type objects of the text table.</p>
      <p>A text table is built by an object of an instance of <c>stored_table_builder</c> (<xref id="stored_table_builder"/>), whose instances meet <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>).</p>
    </section>

    <section id="stored_table_hpp">
      <name>Header <c>"commama/stored_table.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;deque>
#include &lt;functional>
#include &lt;iterator>
#include &lt;memory>
#include &lt;ostream>
#include &lt;string>
#include &lt;type_traits>
#include &lt;vector>

namespace commata {
  <c>// <n><xref id="basic_stored_value"/>, basic_stored_value:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;std::remove_const_t&lt;Ch>>>
    class basic_stored_value;

  template &lt;class ChL, class ChR, class Tr>
    bool operator==(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator==(const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator==(const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator!=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator!=(const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt; (const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt; (const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator> (const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator> (const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator> (const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt;=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt;=(const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
  template &lt;class ChL, class ChR, class Tr>
    bool operator>=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator>=(const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);

  template &lt;class ChC, class Tr>
    std::basic_ostream&lt;std::remove_const_t&lt;ChC>, Tr>&amp; operator&lt;&lt;(
      std::basic_ostream&lt;ChC, Tr>&amp; os, const basic_stored_value&lt;ChC, Tr>&amp; o);

  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
      const basic_stored_value&lt;ChC, Tr>&amp;                                left,
      const std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp; right);
  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
      const basic_stored_value&lt;ChC, Tr>&amp;                                left,
      std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp;&amp;      right);
  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
      const std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp; left,
      const basic_stored_value&lt;ChC, Tr>&amp;                                right);
  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
      std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp;&amp;      left,
      const basic_stored_value&lt;ChC, Tr>&amp;                                right);
  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp; operator+=(
      std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp;       left,
      const basic_stored_value&lt;ChC, Tr>&amp;                                right);
  template &lt;class Ch, class Tr, class Allocator = std::allocator&lt;std::remove_const&lt;Ch>>>
    std::basic_string&lt;std::remove_const&lt;Ch>, std::char_traits&lt;std::remove_const&lt;Ch>>, Allocator>
      to_string(basic_stored_value&lt;Ch, Tr>&amp; o, const Allocator&amp; alloc = Allocator());

  template &lt;class Ch, class Tr> void swap(basic_stored_value&lt;Ch, Tr>&amp; left,
                                          basic_stored_value&lt;Ch, Tr>&amp; right) noexcept;

  using stored_value   = basic_stored_value&lt;char>;
  using wstored_value  = basic_stored_value&lt;wchar_t>;
  using cstored_value  = basic_stored_value&lt;const char>;
  using cwstored_value = basic_stored_value&lt;const wchar_t>;

  <c>// <n><xref id="basic_stored_table"/>, basic_stored_table:</n></c>
  template &lt;class Content, class Allocator = std::allocator&lt;Content>> class basic_stored_table;

  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);

  template &lt;class Content, class Allocator>
    void swap(basic_stored_table&lt;Content, Allocator>&amp; left,
              basic_stored_table&lt;Content, Allocator>&amp; right)
      noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_swap::value);

  using stored_table   = basic_stored_table&lt;std::deque&lt;std::vector&lt;stored_value>>>;
  using wstored_table  = basic_stored_table&lt;std::deque&lt;std::vector&lt;wstored_value>>>;
  using cstored_table  = basic_stored_table&lt;std::deque&lt;std::vector&lt;cstored_value>>>;
  using cwstored_table = basic_stored_table&lt;std::deque&lt;std::vector&lt;cwstored_value>>>;

  enum stored_table_builder_option : <nc>unspecified</nc> {
    stored_table_builder_option_transpose = 1
  };

  <c>// <n><xref id="stored_table_builder"/>, stored_table_builder:</n></c>
  template &lt;class Content, class Allocator,
            std::underlying_type_t&lt;stored_table_builder_option> Options = 0>
    class stored_table_builder;

  template &lt;class Content, class Allocator, class... Args>
    <nc>see below</nc> make_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table,
                                        Args&amp;&amp;... args);
  template &lt;class Content, class Allocator, class... Args>
    <nc>see below</nc> make_transposed_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table,
                                                   Args&amp;&amp;... args);
}

namespace std {
  <c>// <n><xref id="basic_stored_value.hash"/>, basic_stored_value hash support:</n></c>
  template &lt;class Ch, class Tr> struct hash&lt;commata::basic_stored_value&lt;Ch, Tr>>;
}
      </codeblock>
    </section>

    <section id="basic_stored_value">
      <name>Class template <c>basic_stored_value</c></name>

      <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;std::remove_const_t&lt;Ch>>>
    class basic_stored_value {
  public:
    using value_type      = Ch;
    using reference       = Ch&amp;;
    using const_reference = const Ch&amp;;
    using pointer         = Ch*;
    using const_pointer   = const Ch*;
    using iterator        = <nc>unspecified</nc>;
    using const_iterator  = <nc>unspecified</nc>;
    using difference_type = std::ptrdiff_t;
    using size_type       = std::size_t;
    using traits_type     = Tr;

    using reverse_iterator       = std::reverse_iterator&lt;iterator>;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator>;

    static constexpr size_type npos = -1;

    <c>// <n><xref id="basic_stored_value.cons"/>, construct/copy/destroy:</n></c>
    basic_stored_value() noexcept;
    basic_stored_value(Ch* begin, Ch* end);
    basic_stored_value(const basic_stored_value&amp; other) noexcept = default;
    template &lt;class OtherCh>
      basic_stored_value(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;
   ~basic_stored_value() = default;
    basic_stored_value&amp; operator=(const basic_stored_value&amp; other) noexcept = default;
    template &lt;class OtherCh>
      basic_stored_value&amp; operator=(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;

    <c>// <n><xref id="basic_stored_value.iterators"/>, iterators:</n></c>
    iterator       begin()        noexcept;
    const_iterator begin()  const noexcept;
    const_iterator cbegin() const noexcept;

    iterator       end()        noexcept;
    const_iterator end()  const noexcept;
    const_iterator cend() const noexcept;

    reverse_iterator       rbegin()        noexcept;
    const_reverse_iterator rbegin()  const noexcept;
    const_reverse_iterator crbegin() const noexcept;

    reverse_iterator       rend()        noexcept;
    const_reverse_iterator rend()  const noexcept;
    const_reverse_iterator crend() const noexcept;

    <c>// <n><xref id="basic_stored_value.capacity"/>, capacity:</n></c>
    size_type size()   const noexcept;
    size_type length() const noexcept;
    size_type max_size() const noexcept;
    void clear() noexcept;
    bool empty() const noexcept;

    <c>// <n><xref id="basic_stored_value.access"/>, element access:</n></c>
    reference       operator[](size_type pos);
    const_reference operator[](size_type pos) const;
    reference       at(size_type pos);
    const_reference at(size_type pos) const;

    reference       front();
    const_reference front() const;
    reference       back();
    const_reference back()  const;

    pointer       c_str()       noexcept;
    const_pointer c_str() const noexcept;
    pointer       data()        noexcept;
    const_pointer data()  const noexcept;

    template &lt;class OtherTr = std::char_traits&lt;std::remove_const_t&lt;Ch>>,
              class Allocator = std::allocator&lt;std::remove_const_t&lt;Ch>>>
      explicit operator std::basic_string&lt;std::remove_const_t&lt;Ch>, OtherTr, Allocator>() const;

    <c>// <n><xref id="basic_stored_value.modifiers"/>, modifiers:</n></c>
    iterator erase(const_iterator first, const_iterator last);
    iterator erase(const_iterator position);
    basic_stored_value&amp; erase(size_type pos = 0, size_type n = npos);

    void pop_front();
    void pop_back();

    void swap(basic_stored_value&amp; other) noexcept;

  private:
    Ch* b;    <c>// <n>exposition only</n></c>
    Ch* e;    <c>// <n>exposition only</n></c>
  };

  <c>// <n><xref id="basic_stored_value.comparison"/>, comparison functions:</n></c>
  template &lt;class ChL, class ChR, class Tr>
    bool operator==(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator==(const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator==(const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator!=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator!=(const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt; (const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp; v,
                    const Other&amp;                       o) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt; (const Other&amp;                       o,
                    const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator> (const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator> (const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator> (const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator&lt;=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator&lt;=(const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);

  template &lt;class ChL, class ChR, class Tr>
    bool operator>=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                    const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
  template &lt;class ChC, class Tr, class Other>
    bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                    const Other&amp;                       r) noexcept(<nc>see below</nc>);
  template &lt;class ChC, class Tr, class Other>
    bool operator>=(const Other&amp;                       l,
                    const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);

  <c>// <n><xref id="basic_stored_value.inserter"/>, inserters:</n></c>
  template &lt;class ChC, class Tr>
    std::basic_ostream&lt;std::remove_const_t&lt;ChC>, Tr>&amp; operator&lt;&lt;(
      std::basic_ostream&lt;ChC, Tr>&amp; os, const basic_stored_value&lt;ChC, Tr>&amp; o);

  <c>// <n><xref id="basic_stored_value.conversion"/>, conversion:</n></c>
  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
      const basic_stored_value&lt;ChC, Tr>&amp;                                left,
      const std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp; right);
  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
      const basic_stored_value&lt;ChC, Tr>&amp;                                left,
      std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp;&amp;      right);
  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
      const std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp; left,
      const basic_stored_value&lt;ChC, Tr>&amp;                                right);
  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
      std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp;&amp;      left,
      const basic_stored_value&lt;ChC, Tr>&amp;                                right);

  template &lt;class ChC, class Tr, class Allocator>
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp; operator+=(
      std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp;       left,
      const basic_stored_value&lt;ChC, Tr>&amp;                                right);

  template &lt;class Ch, class Tr, class Allocator = std::allocator&lt;std::remove_const&lt;Ch>>>
    std::basic_string&lt;std::remove_const&lt;Ch>, std::char_traits&lt;std::remove_const&lt;Ch>>, Allocator>
      to_string(basic_stored_value&lt;Ch, Tr>&amp; o, const Allocator&amp; alloc = Allocator());

  <c>// <n><xref id="basic_stored_value.swap"/>, specialized algorithms:</n></c>
  template &lt;class Ch, class Tr> void swap(basic_stored_value&lt;Ch, Tr>&amp; left,
                                          basic_stored_value&lt;Ch, Tr>&amp; right) noexcept;
}
      </codeblock>

      <p>The class template <c>basic_stored_value</c> describes an object that references the text value of a text field in a text table (<xref id="definitions.text_table"/>) represented by an object of an instance of <c>basic_stored_table</c> (<xref id="basic_stored_table"/>).</p>
      <p><c>Ch</c> shall be a possibly const-qualified char-like type. <c>Tr</c> shall be a character traits type for <c>Ch</c>.</p>
      <p>The text value is represented by the range [<c>b</c>, <c>e</c>). <c>*e</c> is always equal to <c>0</c>.
         Programs can read from the range [<c>b</c>, <c>e</c>], and write to the range [<c>b</c>, <c>e</c>) if <c>Ch</c> is not const-qualified.
         To modify the size (that is, <c>e - b</c>), programs can use the store-accessing facilities (<xref id="basic_stored_table.rewrite"/>) of the <c>basic_stored_table</c> object concerned.</p>
      <p>On the types <c>basic_stored_value&lt;Ch, Tr>::iterator</c> and <c>basic_stored_value&lt;Ch, Tr>::const_iterator</c>, it shall be satisfied that:</p>
      <ul>
        <li>they shall meet the random access iterator requirements,</li>
        <li><c>basic_stored_value&lt;Ch, Tr>::iterator</c> shall be convertible to <c>basic_stored_value&lt;Ch, Tr>::const_iterator</c>, and</li>
        <li>each instance of <c>std::iterator_traits</c> on them shall have a set of member typedefs indicated in <xref id="table.basic_stored_value.iterator.typedefs"/>.</li>
      </ul>

      <table id="table.basic_stored_value.iterator.typedefs">
        <caption>Member typedefs of each instance of <c>std::iterator_traits&lt;T></c> where <c>T</c> is either of <c>iterator</c> or <c>const_iterator</c> of <c>basic_stored_value&lt;Ch, Tr></c></caption>
        <col width="3"/><col width="5"/><col width="5"/>

        <tr>
          <th>Member typedef</th>
          <th><c>T</c> is <c>iterator</c></th>
          <th><c>T</c> is <c>const_iterator</c></th>
        </tr>

        <tr>
          <td><c>difference_type</c></td>
          <td colspan="2"><c>std::ptrdiff_t</c></td>
        </tr>

        <tr>
          <td><c>value_type</c></td>
          <td><c>Ch</c></td>
          <td><c>const Ch</c></td>
        </tr>

        <tr>
          <td><c>pointer</c></td>
          <td><c>Ch*</c></td>
          <td><c>const Ch*</c></td>
        </tr>

        <tr>
          <td><c>reference</c></td>
          <td><c>Ch&amp;</c></td>
          <td><c>const Ch&amp;</c></td>
        </tr>

        <tr>
          <td><c>iterator_category</c></td>
          <td colspan="2"><c>std::random_access_iterator_tag</c> or its derived type</td>
        </tr>
      </table>

      <section id="basic_stored_value.cons">
        <name><c>basic_stored_value</c> constructors and assignment operators</name>

        <code-item>
          <code>
basic_stored_value() noexcept;
          </code>
          <effects>Constructs an empty object of <c>basic_stored_value</c>.</effects>
          <postcondition><c>b == e</c> and <c>*e</c> is equal to <c>0</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_value(Ch* begin, Ch* end);
          </code>
          <requires>[<c>begin</c>, <c>end</c>] shall be a valid range. <c>*end</c> shall be equal to <c>0</c>.</requires>
          <throws>Nothing.</throws>
          <effects>Initializes <c>b</c> with <c>begin</c> and <c>e</c> with <c>end</c>.</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherCh>
  basic_stored_value(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;
          </code>
          <effects>Initializes <c>b</c> with <c>other.begin()</c> and <c>e</c> with <c>other.end()</c>.</effects>
          <remark>This overload shall not participate in overload resolution unless <c>Ch</c> is const-qualified and <c>Ch</c> and <c>const OtherCh</c> are the same type.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherCh>
  basic_stored_value&amp; operator=(const basic_stored_value&lt;OtherCh, Tr>&amp; other) noexcept;
          </code>
          <effects>Assigns <c>b</c> from <c>other.begin()</c> and <c>e</c> from <c>other.end()</c>.</effects>
          <remark>This overload shall not participate in overload resolution unless <c>Ch</c> is const-qualified and <c>Ch</c> and <c>const OtherCh</c> are the same type.</remark>
        </code-item>
      </section>

      <section id="basic_stored_value.iterators">
        <name><c>basic_stored_value</c> iterator support</name>

        <code-item>
          <code>
iterator       begin()        noexcept;
const_iterator begin()  const noexcept;
const_iterator cbegin() const noexcept;
          </code>
          <returns><c>b</c>.</returns>
        </code-item>

        <code-item>
          <code>
iterator       end()        noexcept;
const_iterator end()  const noexcept;
const_iterator cend() const noexcept;
          </code>
          <returns><c>e</c>.</returns>
        </code-item>

        <code-item>
          <code>
reverse_iterator       rbegin()        noexcept;
const_reverse_iterator rbegin()  const noexcept;
const_reverse_iterator crbegin() const noexcept;
          </code>
          <returns><c>reverse_iterator(end())</c>.</returns>
        </code-item>

        <code-item>
          <code>
reverse_iterator       rend()        noexcept;
const_reverse_iterator rend()  const noexcept;
const_reverse_iterator crend() const noexcept;
          </code>
          <returns><c>reverse_iterator(begin())</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.capacity">
        <name><c>basic_stored_value</c> capacity</name>

        <code-item>
          <code>
size_type size()   const noexcept;
size_type length() const noexcept;
          </code>
          <returns><c>end() - begin()</c>.</returns>
        </code-item>

        <code-item>
          <code>
size_type max_size() const noexcept;
          </code>
          <returns>The largest possible number that the member function <c>size</c> returns.</returns>
        </code-item>

        <code-item>
          <code>
void clear() noexcept;
          </code>
          <effects><c>erase(begin(), end())</c>.</effects>
        </code-item>

        <code-item>
          <code>
bool empty() const noexcept;
          </code>
          <returns><c>size() == 0</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.access">
        <name><c>basic_stored_value</c> element access</name>

        <code-item>
          <code>
reference       operator[](size_type pos);
const_reference operator[](size_type pos) const;
          </code>
          <requires><c>pos &lt;= size()</c>.</requires>
          <throws>Nothing.</throws>
          <returns><c>begin()[pos]</c>.</returns>
          <remark>if <c>pos == size()</c>, the returned reference is read-only.</remark>
        </code-item>

        <code-item>
          <code>
reference       at(size_type pos);
const_reference at(size_type pos) const;
          </code>
          <throws><c>std::out_of_range</c> if <c>pos >= size()</c>.</throws>
          <returns><c>(*this)[pos]</c>.</returns>
        </code-item>

        <code-item>
          <code>
reference       front();
const_reference front() const;
          </code>
          <requires><c>!empty()</c>.</requires>
          <throws>Nothing.</throws>
          <returns><c>(*this)[0]</c>.</returns>
        </code-item>

        <code-item>
          <code>
reference       back();
const_reference back() const;
          </code>
          <requires><c>!empty()</c>.</requires>
          <throws>Nothing.</throws>
          <returns><c>(*this)[size() - 1]</c>.</returns>
        </code-item>

        <code-item>
          <code>
pointer       c_str()       noexcept;
const_pointer c_str() const noexcept;
pointer       data()        noexcept;
const_pointer data()  const noexcept;
          </code>
          <returns><c>b</c>.</returns>
          <remark>The range [<c>r</c>, <c>r + size()</c>] is readable and the range [<c>r</c>, <c>r + size()</c>) is writable where <c>r</c> is the returned value.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherTr = std::char_traits&lt;std::remove_const_t&lt;Ch>>,
          class Allocator = std::allocator&lt;std::remove_const_t&lt;Ch>>>
  explicit operator std::basic_string&lt;std::remove_const_t&lt;Ch>, OtherTr, Allocator>() const;
          </code>
          <returns><c>std::basic_string&lt;std::remove_const_t&lt;Ch>, OtherTr, Allocator>(cbegin(), cend())</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.modifiers">
        <name><c>basic_stored_value</c> modifiers</name>

        <code-item>
          <code>
iterator erase(const_iterator first, const_iterator last);
          </code>
          <requires>[<c>first</c>, <c>last</c>) shall be comprised in [<c>cbegin()</c>, <c>cend()</c>).</requires>
          <throws>Nothing.</throws>
          <postcondition>Suppose that <c>prefix</c> is the string of [<c>cbegin()</c>, <c>first</c>) and <c>postfix</c> is of [<c>last</c>, <c>cend()</c>) before the call.
                         Then the string of [<c>b</c>, <c>e</c>) shall be equal to <c>prefix</c> and <c>postfix</c> concatenated.
                         <c>*e</c> shall be <c>0</c>.</postcondition>
          <returns><c>begin() + off</c> where <c>off</c> is the value of <c>first - cbegin()</c> before the call.</returns>
          <remark>Calling this function invalidates all references, pointers, and iterators to the objects in the before-call range [<c>begin()</c>, <c>end()</c>].</remark>
        </code-item>

        <code-item>
          <code>
iterator erase(const_iterator position);
          </code>
          <requires><c>position</c> shall point an object in [<c>cbegin()</c>, <c>cend()</c>).</requires>
          <throws>Nothing.</throws>
          <effects>Equivalent to call <c>erase(position, position + 1)</c>.</effects>
          <returns><c>begin() + off</c> where <c>off</c> is the value of <c>position - cbegin()</c> before the call.</returns>
        </code-item>

        <code-item>
          <code>
basic_stored_value&amp; erase(size_type pos = 0, size_type n = npos);
          </code>
          <throws><c>std::out_of_range</c> if <c>pos > size()</c>.</throws>
          <effects>Equivalent to call <c>erase(cbegin() + pos, cbegin() + pos + xlen)</c> where <c>xlen</c> is the smaller of <c>n</c> and <c>size() - pos</c>.</effects>
          <returns><c>*this</c>.</returns>
        </code-item>

        <code-item>
          <code>
void pop_front();
          </code>
          <requires><c>empty()</c> shall not be <c>false</c>.</requires>
          <throws>Nothing.</throws>
          <effects>Equivalent to call <c>erase(cbegin())</c>.</effects>
        </code-item>

        <code-item>
          <code>
void pop_back();
          </code>
          <requires><c>empty()</c> shall not be <c>false</c>.</requires>
          <throws>Nothing.</throws>
          <effects>Equivalent to call <c>erase(cend() - 1)</c>.</effects>
        </code-item>

        <code-item>
          <code>
void swap(basic_stored_value&amp; other) noexcept;
          </code>
          <effects>Exchanges the values of <c>b</c> and <c>other.b</c>, and does the same with <c>e</c> and <c>other.e</c>.</effects>
        </code-item>
      </section>

      <section id="basic_stored_value.comparison">
        <name><c>basic_stored_value</c> comparison functions</name>

        <p>Function templates described in this subclause that take template parameters <c>ChL</c> and <c>ChR</c> shall not participate in overload resolution unless <c>std::remove_const_t&lt;ChL></c> and <c>std::remove_const_t&lt;ChR></c> are the same type.</p>
        <p>Function templates described in this subclause that take template parameters <c>ChC</c> and <c>Other</c> shall not participate in overload resolution unless <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is not <c>false</c> or <c>Other</c> is the same type as <c>std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator></c> for a certain type <c>Allocator</c>.</p>

        <section id="basic_stored_value.opeq">
          <name><c>operator==</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator==(const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
            </code>
            <returns><c>l.size() == r.size() &amp;&amp; Tr::compare(l.data(), r.data(), l.size()) == 0</c>.</returns>
          </code-item>

          <code-item>
            <code>
template &lt;class ChC, class Tr, class Other>
  bool operator==(const basic_stored_value&lt;ChC, Tr>&amp; v,
                  const Other&amp;                       o) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator==(const Other&amp;                       o,
                  const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
            </code>
            <returns>If <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c>, <c>v.size() == o.size() &amp;&amp; Tr::compare(v.data(), o.data(), v.size()) == 0</c>.
                     Otherwise, <c>v.size() == Tr::length(o) &amp;&amp; Tr::compare(v.data(), o, v.size()) == 0</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> are <c>true</c> if <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.opne">
          <name><c>operator!=</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator!=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
template &lt;class ChC, class Tr, class Other>
  bool operator!=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                  const Other&amp;                       r) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator!=(const Other&amp;                       l,
                  const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>!(l == r)</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> if <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.oplt">
          <name><c>operator&lt;</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator&lt; (const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
            </code>
            <returns><c>c &lt; 0 || (c == 0 &amp;&amp; l.size() &lt; r.size())</c> where <c>c</c> is the return value of <c>Tr::compare(l.data(), r.data(), rlen)</c> and <c>rlen</c> is the smaller of <c>l.size()</c> and <c>r.size()</c>.</returns>
          </code-item>

          <code-item>
            <code>
template &lt;class ChC, class Tr, class Other>
  bool operator&lt; (const basic_stored_value&lt;ChC, Tr>&amp; v,
                  const Other&amp;                       o) noexcept(<nc>see below</nc>);
            </code>
            <returns>If <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c>,
                     <c>c &lt; 0 || (c == 0 &amp;&amp; v.size() &lt; o.size()</c> where <c>c</c> is the return value of <c>Tr::compare(v.data(), o.data(), rlen)</c> and <c>rlen</c> is the smaller of <c>v.size()</c> and <c>o.size()</c>.
                     Otherwise, <c>c &lt; 0 || (c == 0 &amp;&amp; v.size() &lt; Tr::length(o)</c> where <c>c</c> is the return value of <c>Tr::compare(v.data(), o, rlen)</c> and <c>rlen</c> is the smaller of <c>v.size()</c> and <c>Tr::length(o)</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is <c>true</c> if <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class ChC, class Tr, class Other>
  bool operator&lt; (const Other&amp;                       o,
                  const basic_stored_value&lt;ChC, Tr>&amp; v) noexcept(<nc>see below</nc>);
            </code>
            <returns>If <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c>,
                     <c>c &lt; 0 || (c == 0 &amp;&amp; o.size() &lt; v.size()</c> where <c>c</c> is the return value of <c>Tr::compare(o.data(), v.data(), rlen)</c> and <c>rlen</c> is the smaller of <c>o.size()</c> and <c>v.size()</c>.
                     Otherwise, <c>c &lt; 0 || (c == 0 &amp;&amp; Tr::length(o) &lt; v.size()</c> where <c>c</c> is the return value of <c>Tr::compare(o, v.data(), rlen)</c> and <c>rlen</c> is the smaller of <c>Tr::length(o)</c> and <c>v.size()</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is <c>true</c> if <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.opgt">
          <name><c>operator></c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator> (const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
template &lt;class ChC, class Tr, class Other>
  bool operator> (const basic_stored_value&lt;ChC, Tr>&amp; l,
                  const Other&amp;                       r) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator> (const Other&amp;                       l,
                  const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>r &lt; l</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> if <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.ople">
          <name><c>operator&lt;=</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator&lt;=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
template &lt;class ChC, class Tr, class Other>
  bool operator&lt;=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                  const Other&amp;                       r) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator&lt;=(const Other&amp;                       l,
                  const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>!(r &lt; l)</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> if <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="basic_stored_value.opge">
          <name><c>operator>=</c></name>
          <code-item>
            <code>
template &lt;class ChL, class ChR, class Tr>
  bool operator>=(const basic_stored_value&lt;ChL, Tr>&amp; l,
                  const basic_stored_value&lt;ChR, Tr>&amp; r) noexcept;
template &lt;class ChC, class Tr, class Other>
  bool operator>=(const basic_stored_value&lt;ChC, Tr>&amp; l,
                  const Other&amp;                       r) noexcept(<nc>see below</nc>);
template &lt;class ChC, class Tr, class Other>
  bool operator>=(const Other&amp;                       l,
                  const basic_stored_value&lt;ChC, Tr>&amp; r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>!(l &lt; r)</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> if <c>std::is_convertible&lt;Other, const std::remove_const_t&lt;ChC>*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>
      </section>

      <section id="basic_stored_value.inserter">
        <name><c>basic_stored_value</c> inserters</name>

        <code-item>
          <code>
template &lt;class ChC, class Tr>
  std::basic_ostream&lt;std::remove_const_t&lt;ChC>, Tr>&amp; operator&lt;&lt;(
    std::basic_ostream&lt;ChC, Tr>&amp; os, const basic_stored_value&lt;ChC, Tr>&amp; o);
          </code>
          <effects>Behaves as a formatted output function of <c>os</c>.
                    Forms a character sequence <c>seq</c>, initially consisting of the elements defined by the range [<c>o.cbegin()</c>, <c>o.cend()</c>).
                    Determines padding for <c>seq</c>. Then inserts <c>seq</c> as if by calling <c>os.rdbuf()->sputn(seq, n)</c>, where <c>n</c> is the larger of <c>os.width()</c> and the size of <c>seq</c>; then calls <c>os.width(0)</c>.</effects>
          <returns><c>os</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.conversion">
        <name><c>basic_stored_value</c> conversion</name>

        <code-item>
          <code>
template &lt;class ChC, class Tr, class Allocator>
  std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
    const basic_stored_value&lt;ChC, Tr>&amp;                                left,
    const std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp; right);
template &lt;class ChC, class Tr, class Allocator>
  std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
    const basic_stored_value&lt;ChC, Tr>&amp;                                left,
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp;&amp;      right);
template &lt;class ChC, class Tr, class Allocator>
  std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
    const std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp; left,
    const basic_stored_value&lt;ChC, Tr>&amp;                                right);
template &lt;class ChC, class Tr, class Allocator>
  std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator> operator+(
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp;&amp;      left,
    const basic_stored_value&lt;ChC, Tr>&amp;                                right);
          </code>
          <returns>A string object whose content is [<c>l.cbegin()</c>, <c>l.cend()</c>) and [<c>r.cbegin()</c>, <c>r.cend()</c>) concatenated
                   where <c>l</c> and <c>r</c> are the values of <c>left</c> and <c>right</c> before the call respectively.</returns>
          <remark>If an exception is thrown by an instance of these function templates, the invocation shall have no effect.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class ChC, class Tr, class Allocator>
  std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp; operator+=(
    std::basic_string&lt;std::remove_const_t&lt;ChC>, Tr, Allocator>&amp;       left,
    const basic_stored_value&lt;ChC, Tr>&amp;                                right);
          </code>
          <effects>Equivalent to call <c>left.append(right.cbegin(), right.cend())</c>.</effects>
          <returns><c>left</c>.</returns>
          <remark>If an exception is thrown by an instance of these function templates, the invocation shall have no effect.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Ch, class Tr, class Allocator = std::allocator&lt;std::remove_const&lt;Ch>>>
  std::basic_string&lt;std::remove_const&lt;Ch>, std::char_traits&lt;std::remove_const&lt;Ch>>, Allocator>
    to_string(basic_stored_value&lt;Ch, Tr>&amp; o, const Allocator&amp; alloc = Allocator());
          </code>
          <returns><c>std::basic_string&lt;std::remote_const&lt;Ch>, std::char_traits&lt;std::remove_const&lt;Ch>>, Allocator>(o.cbegin(), o.cend(), alloc)</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_value.swap">
        <name><c>basic_stored_value</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Ch, class Tr> void swap(basic_stored_value&lt;Ch, Tr>&amp; left,
                                        basic_stored_value&lt;Ch, Tr>&amp; right) noexcept;
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
        </code-item>
      </section>

      <section id="basic_stored_value.hash">
        <name><c>basic_stored_value</c> hash support</name>

        <codeblock>
namespace std {
  template &lt;class Ch, class Tr> struct hash&lt;commata::basic_stored_value&lt;Ch, Tr>>;
}
        </codeblock>
        <p>This template specialization shall meet the requirements of class template <c>std::hash</c>.</p>
      </section>
    </section>

    <section id="basic_stored_table">
      <name>Class template <c>basic_stored_table</c></name>

      <section id="basic_stored_table.overview">
        <name>Class template <c>basic_stored_table</c> overview</name>

        <codeblock>
namespace commata {
  template &lt;class Content, class Allocator = std::allocator&lt;Content>>
    class basic_stored_table {
  public:
    using allocator_type  = Allocator;
    using content_type    = Content;
    using record_type     = typename content_type::value_type;
    using value_type      = typename record_type::value_type;
    using char_type       = std::remove_const_t&lt;typename value_type::value_type>;
    using traits_type     = typename value_type::traits_type;
    using size_type       = typename content_type::size_type;

    <c>// <n><xref id="basic_stored_table.cons"/>, construct/copy/destroy:</n></c>
    explicit basic_stored_table(std::size_t buffer_size = 0) :
      basic_stored_table(std::allocator_arg, Allocator(), buffer_size);
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc, std::size_t buffer_size = 0U);
    basic_stored_table(const basic_stored_table&amp;  other);
    basic_stored_table(      basic_stored_table&amp;&amp; other) noexcept;
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                       std::size_t buffer_size = 0);
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                       const basic_stored_table&amp;  other);
    basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                             basic_stored_table&amp;&amp; other);
   ~basic_stored_table();
    basic_stored_table&amp; operator=(const basic_stored_table&amp;  other);
    basic_stored_table&amp; operator=(      basic_stored_table&amp;&amp; other)
      noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_move_assignment::value);

    <c>// <n><xref id="basic_stored_table.constituents"/>, access to the constituents:</n></c>
    allocator_type get_allocator() const noexcept;
    std::size_t get_buffer_size() const noexcept;
    content_type&amp;       content();
    const content_type&amp; content() const;
    record_type&amp;       operator[](size_type record_index);
    const record_type&amp; operator[](size_type record_index) const;
    size_type size() const noexcept(<nc>see below</nc>);
    bool empty() const noexcept(<nc>see below</nc>);
    void clear() noexcept(<nc>see below</nc>);

    <c>// <n><xref id="basic_stored_table.capacity"/>, capacity:</n></c>
    void shrink_to_fit();

    <c>// <n><xref id="basic_stored_table.rewrite"/>, store operations:</n></c>
    template &lt;class ForwardIterator, class ForwardIteratorEnd>
      value_type&amp;
        rewrite_value(value_type&amp; value,
                      ForwardIterator new_value_begin, ForwardIteratorEnd new_value_end);
    template &lt;class ForwardIterator>
      value_type&amp; rewrite_value(value_type&amp; value, ForwardIterator new_value);
    template &lt;class OtherValue>
      value_type&amp; rewrite_value(value_type&amp; value, const OtherValue&amp; new_value);
    template &lt;class... Args> value_type import_value(Args&amp;&amp;... args);
    template &lt;class F> auto guard_rewrite(F f) -> decltype(f(*this));

    <c>// <n><xref id="basic_stored_table.primitives"/>, primitive store operations:</n></c>
    std::pair&lt;char_type*, std::size_t> generate_buffer(std::size_t min_size);
    void consume_buffer(char_type* buffer, std::size_t size) const;
    void add_buffer(char_type* buffer, std::size_t size);
    void secure_current_upto(char_type* secured_last);

    <c>// <n><xref id="basic_stored_table.modifiers"/>, modifiers:</n></c>
    template &lt;class OtherContent, class OtherAllocator>
      basic_stored_table&amp; operator+=(
        const basic_stored_table&lt;OtherContent, OtherAllocator>&amp; other);
    template &lt;class OtherContent>
      basic_stored_table&amp; operator+=(
              basic_stored_table&lt;OtherContent, Allocator>&amp;&amp;     other);
    void swap(basic_stored_table&amp; other)
      noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_swap::value);
  
  private:
    <c>// <nc>exposition only</nc></c>
    struct null_termination {
      template &lt;class InputIterator> friend bool operator!=(InputIterator left, null_termination) {
        return !traits_type::eq(*left, char_type());
      }
    };
  };

  <c>// <n><xref id="basic_stored_table.nonmember"/>, non-member functions:</n></c>
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
  template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
    basic_stored_table&lt;ContentL, AllocatorL>
      operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                      basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);

  <c>// <n><xref id="basic_stored_table.swap"/>, specialized algorithms:</n></c>
  template &lt;class Content, class Allocator>
    void swap(basic_stored_table&lt;Content, Allocator>&amp; left,
              basic_stored_table&lt;Content, Allocator>&amp; right)
      noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_swap::value);
}
        </codeblock>

        <p>The class template <c>basic_stored_table</c> describes an in-memory image of a text table (<xref id="definitions.text_table"/>), whose text values are arranged two-dimensionally.</p>

        <p>The template parameter <c>Content</c> shall be a sequence container type of a sequence container type of <c>basic_stored_value&lt;Ch, Tr></c> (<xref id="basic_stored_value"/>) for some <c>Ch</c> and <c>Tr</c>
           and shall meet the <c>DefaultInsertable</c> requirements with <c>Allocator</c>.
           Note that <c>std::array</c> and <c>std::forward_list</c> do not qualify because they lack some essential functionalities of sequence containers.</p>
        <p>The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements for <c>Content</c>.</p>

        <section id="basic_stored_table.parts">
          <name><c>basic_stored_table</c> constituents</name>

          <p>Let <c>Ch</c> be <c>std::remove_const_t&lt;typename Content::value_type::value_type::value_type></c>.</p>
          <p>An object of <c>basic_stored_table&lt;Content, Allocator></c> consists of the four following constituents:</p>
          <ul>
            <li>a <n>content container</n>, which is an allocator-aware container of <c>Content</c> with its size being at most one (and its possible sole element is called the <n>content</n>),</li>
            <li>a <n>store</n>, which is a bundle of <n>buffers</n> and a <n>bookkeeper object</n>; each one of the the buffers is an array of <c>Ch</c> and contains memory referenced by the text values in the content and the bookkeeper object memorizes all the ranges of memory possibly reserved for the text values,</li>
            <li>an allocator, whose type is <c>Allocator</c>, which is used to allocate and construct the content, and whose rebound coplies for <c>Ch</c> are used to allocate memories required by the store, and</li>
            <li>a <n>buffer size</n>, whose type is <c>std::size_t</c> and that is used as the least amount of <c>Ch</c> in one memory allocation.</li>
          </ul>
          <p>The store of an object of <c>basic_stored_table</c> marks one buffer in it as its <n>current buffer</n> when it is not empty; that is, when it has at least one buffer.</p>
        </section>

        <section id="basic_stored_table.defs">
          <name>Definitions</name>

          <p>The <n>value type</n> of an object of an instance of <c>basic_stored_table&lt;Content, Allocator></c> denotes <c>typename Content::value_type::value_type</c>, which is an instance of <c>basic_stored_value</c>.</p>

          <p>The <n>char type</n> of an object of an instance of <c>basic_stored_table&lt;Content, Allocator></c> denotes <c>std::remove_const_t&lt;typename V::value_type></c> where <c>V</c> is the value type, which is a char-like type.</p>

          <p><n>Contained values</n> of an object <c>t</c> of an instance <c>T</c> of <c>basic_stored_table</c> denotes the objects of the value type in the content of <c>t</c>.</p>

          <p>An object <c>v</c> of a value type is called <n>backed by</n> an object <c>t</c> of an instance of <c>basic_stored_table</c> if:</p>
          <ul>
            <li><c>v.empty()</c> is not <c>false</c>, or</li>
            <li>the range [<c>v.cbegin()</c>, <c>v.cend()</c>] resides in a buffer in the store of <c>t</c>, and <c>*v.cend()</c> is equal to a value-initialized char type value.</li>
          </ul>
          <p>An object of an instance of <c>basic_stored_table</c> is called <n>complete</n> if none of its contained values is not backed by it.</p>

          <p>Two objects <c>v</c> and <c>w</c> of a value type is called <n>overlapping</n> if two ranges [<c>v.cbegin()</c>, <c>v.cend()</c>], [<c>w.cbegin()</c>, <c>w.cend()</c>] have at least one common element.</p>
        </section>

        <section id="basic_stored_table.conds">
          <name>General requirements and postconditions</name>

          <p>All member functions of <c>basic_stored_table</c> and all instances of non-member function templates declared in this header (<xref id="stored_table_hpp"/>) that take at least one parameter whose reference-removed and cv-unqualified type is an instance of <c>basic_stored_table</c> require that the following conditions meet:</p>
          <ul>
             <li>all participating <c>basic_stored_table</c> objects are complete, and</li>
             <li>no two of the contained values of the participating <c>basic_stored_table</c> objects overlap.</li>
          </ul>
          <p>And they shall meet the following postconditions:</p>
          <ul>
             <li>all participating <c>basic_stored_table</c> objects are be complete,</li>
             <li>no two of the contained values of the participating <c>basic_stored_table</c> objects overlap, and</li>
             <li>the states of the participating <c>basic_stored_table</c> objects are not changed if the call exits via an exception.</li>
          </ul>

          <p>All non-const member functions of <c>basic_stored_table</c> and all instances of non-member function templates declared in this header (<xref id="stored_table_hpp"/>) that take at least one parameter whose type is a reference to a non-const <c>basic_stored_table&lt;Ch, Tr></c> for some <c>Ch</c> and <c>Tr</c> may change the current buffer marks of the participating non-const <c>basic_stored_table</c> objects.</p>
        </section>
      </section>

      <section id="basic_stored_table.cons">
        <name><c>basic_stored_table</c> construct/copy/destroy</name>

        <p>In this subclause, <c>AT</c> denotes <c>std::allocator_traits&lt;Allocator></c>, <c>CAT</c> denotes <c>typename AT::template rebind_traits&lt;Ch></c> and <c>CA</c> denotes <c>typename CAT::allocator_type</c>.</p>
        <p>All constructors and assignment operators shall make an appropriate decision about propagation of the allocator in accordance with <c>AT::select_on_container_copy_construnction</c>, <c>AT::propagete_on_container_copy_assignment</c> and <c>AT::propagete_on_container_move_assignment</c>.</p>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc, std::size_t buffer_size = 0U);
          </code>
          <effects>Copy constructs the allocator from <c>alloc</c>.
                   If <c>buffer_size</c> is greater than <c>0</c>, initializes the buffer size to a value that is the smaller of <c>CAT::max_size(CA(a))</c> and the greater of <c>buffer_size</c> and <c>2</c> where <c>a</c> is an lvalue to the allocator.
                   Otherwise, initializes it to an unspecified value.
                   Initializes the content container to have an element as default inserted into it.</effects>
        </code-item>

        <code-item>
          <code>
basic_stored_table(const basic_stored_table&amp; other);
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(get_allocator()))</c> and <c>other.get_buffer_size()</c> where <c>CAT</c> is equal to <c>std::allocator_traits&lt;Allocator>::template rebind_alloc&lt;char_type></c>.
                         If defined, also <c>content() == other.content()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table(basic_stored_table&amp;&amp; other) noexcept;
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(get_allocator()))</c> and the value of <c>other.get_buffer_size()</c> before this construction.
                         If defined, <c>content()</c> shall be equal to the value that <c>other.content()</c> had before this construction.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                   std::size_t buffer_size = 0);
          </code>
          <effects>If <c>buffer_size</c> is greater than <c>0</c>, initializes the buffer size to a value that is the smaller of <c>CAT::max_size(CA(alloc))</c> and the greater of <c>buffer_size</c> and <c>2</c>.
                   Otherwise, initializes it to a unspecified value.
                   Initializes the allocator with <c>alloc</c>.
                   Make the content container have an element as default inserted.</effects>
        </code-item>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                   const basic_stored_table&amp; other);
          </code>
          <postcondition><c>get_allocator() == alloc</c> shall be <c>true</c> and <c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(alloc))</c> and <c>other.get_buffer_size()</c>.
                         If defined, <c>content() == other.content()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table(std::allocator_arg_t, const Allocator&amp; alloc,
                   basic_stored_table&amp;&amp; other);
          </code>
          <postcondition><c>get_allocator() == alloc</c> shall be <c>true</c> and <c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(alloc))</c> and <c>other.get_buffer_size()</c>.
                         If defined, <c>content()</c> shall be equal to the value that <c>other.content()</c> had before this construction.</postcondition>
        </code-item>

        <code-item>
          <code>
~basic_stored_table();
          </code>
          <effects>Destroys the content container, deallocates all buffers in the store, and destroys the allocator.</effects>
        </code-item>

        <code-item>
          <code>
basic_stored_table&amp; operator=(const basic_stored_table&amp; other);
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(get_allocator()))</c> and <c>other.get_buffer_size()</c>.
                         If defined, <c>content() == other.content()</c> shall be <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
basic_stored_table&amp; operator=(basic_stored_table&amp;&amp; other)
  noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_move_assignment::value);
          </code>
          <postcondition><c>get_buffer_size()</c> shall be the smaller of <c>CAT::max_size(CA(get_allocator()))</c> and the value of <c>other.get_buffer_size()</c> before this assignment.
                         If defined, <c>content()</c> shall be equal to the value that <c>other.content()</c> had before this assignment.</postcondition>
        </code-item>
      </section>

      <section id="basic_stored_table.constituents">
        <name><c>basic_stored_table</c> constituent access</name>

        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>The allocator.</returns>
        </code-item>

        <code-item>
          <code>
std::size_t get_buffer_size() const noexcept;
          </code>
          <returns>The buffer size.</returns>
        </code-item>

        <code-item>
          <code>
content_type&amp;       content();
const content_type&amp; content() const;
          </code>
          <requires>The content container of <c>*this</c> shall not be empty.</requires>
          <returns>A reference to the content, which is the sole element of the content container.</returns>
          <throws>Nothing.</throws>
        </code-item>

        <code-item>
          <code>
record_type&amp;       operator[](size_type record_index);
const record_type&amp; operator[](size_type record_index) const;
          </code>
          <requires>The content container of <c>*this</c> shall not be empty.</requires>
          <returns><c>content()[record_index]</c>.</returns>
        </code-item>

        <code-item>
          <code>
size_type size() const noexcept(<nc>see below</nc>);
          </code>
          <returns><c>0</c> if the content container is empty; <c>content().size()</c> otherwise.</returns>
          <remark>The expression inside <c>noexcept</c> is <c>false</c> if and only if <c>Content::size</c> with no parameters is not marked as <c>noexcept</c>.</remark>
        </code-item>

        <code-item>
          <code>
bool empty() const noexcept(<nc>see below</nc>);
          </code>
          <returns><c>true</c> if the content container is empty; <c>content().empty()</c> otherwise.</returns>
          <remark>The expression inside <c>noexcept</c> is <c>false</c> if and only if <c>Content::empty</c> with no parameters is not marked as <c>noexcept</c>.</remark>
        </code-item>

        <code-item>
          <code>
void clear() noexcept(<nc>see below</nc>);
          </code>
          <effects>Calls <c>content().clear()</c> if and only if the content container of <c>*this</c> is not be empty. Then makes the bookkeeper object of the store recognize no memory in the buffers of the store are reserved for any text values.</effects>
          <remark>The expression inside <c>noexcept</c> is <c>false</c> if and only if <c>Content::clear</c> with no parameters is not marked as <c>noexcept</c>.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.capacity">
        <name><c>basic_stored_table</c> capacity</name>
        <code-item>
          <code>
void shrink_to_fit();
          </code>
          <postcondition>The values of <c>content()</c> (if defined), <c>get_allocator()</c> and <c>get_buffer_size()</c> shall be equal to the values that those had before this call.</postcondition>
          <remark>This is a non-binding request to reduce memory use.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.rewrite">
        <name><c>basic_stored_table</c> store operations</name>

        <code-item>
          <code>
template &lt;class ForwardIterator, class ForwardIteratorEnd>
  value_type&amp;
    rewrite_value(value_type&amp; value,
                  ForwardIterator new_value_begin, ForwardIteratorEnd new_value_end);
          </code>
          <requires>The template parameter <c>ForwardIterator</c> shall meet the <c>ForwardIterator</c> requirements for <c>char_type</c>.
                    The template parameter <c>ForwardIteratorEnd</c> shall meet the <c>CopyConstructible</c> requirements and <c>Destructible</c> requirements.
                    <c>std::declval&lt;const ForwardIterator&amp;>() != std::declval&lt;const ForwardIteratorEnd&amp;>()</c> shall be a valid expression whose value can be contextually converted to <c>bool</c>.
                    <c>value</c> shall be backed by <c>*this</c>.
                    <c>new_value_begin</c> shall point an element in, or be a past-the-end iterator of, a valid range.</requires>
          <postcondition><c>value</c> shall be unchangedly backed by <c>*this</c>.
                         Let <c>n</c> is the smallest non-negative integer which makes the value of <c>std::next(new_value_begin, n) != new_value_end</c> contextually converted to <c>bool</c> be <c>false</c>.
                         Then <c>std::equal(value.cbegin(), value.cend(), new_value_begin, std::next(new_value_begin, n), p)</c> shall not be <c>false</c>
                         where <c>p</c> is an equivalent predicate to <c>traits_type::eq</c>.</postcondition>
          <returns><c>value</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class ForwardIterator>
  value_type&amp; rewrite_value(value_type&amp; value, ForwardIterator new_value);
          </code>
          <requires>The template parameter <c>ForwardIterator</c> shall meet the <c>ForwardIterator</c> requirements for <c>char_type</c>.
                    <c>value</c> shall be backed by <c>*this</c>.
                    <c>new_value</c> shall point the first element of a valid null-terminated sequence of <c>char_type</c>.</requires>
          <effects>Calls <c>rewrite_value(value, new_value, null_termination())</c>.</effects>
          <returns><c>value</c>.</returns>
          <remark>This overload shall not participate in overload resolution unless <c>std::iterator_traits&lt;ForwardIterator>::iterator_category</c> is a type
                  that is equal to or a derived class of <c>std::forward_iterator_tag</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherValue>
  value_type&amp; rewrite_value(value_type&amp; value, const OtherValue&amp; new_value);
          </code>
          <requires><c>value</c> shall be backed by <c>*this</c>.</requires>
          <effects>Calls <c>rewrite_value(value, new_value.cbegin(), new_value.cend())</c>.</effects>
          <returns><c>value</c>.</returns>
          <remark>This overload shall not participate in overload resolution unless <c>OtherValue::const_iterator</c> is a type.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class... Args> value_type import_value(Args&amp;&amp;... args);
          </code>
          <effects>Constructs an object of <c>value_type</c> with no arguments, which is named <c>value</c>.
                   Then calls <c>rewrite_value(value, std::forward&lt;Args>(args)...)</c>.</effects>
          <returns><c>value</c> above.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class F> auto guard_rewrite(F f) -> decltype(f(*this));
          </code>
          <requires><c>f</c> shall possibly call functions that do not change the state of <c>*this</c> except <c>rewrite_value</c>, <c>import_value</c>, <c>generate_buffer</c>, <c>consume_buffer</c>, <c>add_buffer</c> and <c>secure_current_upto</c>.</requires>
          <effects>Calls <c>f(*this)</c>.</effects>
          <returns>The return value of the call above.</returns>
          <remark>If an exception is thrown, all objects returned by the calls of <c>rewrite_value</c> and therefore <c>import_value</c> during the call of <c>f(*this)</c> are invalidated
                  and the current buffer mark and its reservation marks (<xref id="basic_stored_table.primitives"/>) are restored.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.primitives">
        <name><c>basic_stored_table</c> primitive store operations</name>

        <code-item>
          <code>
std::pair&lt;char_type*, std::size_t> generate_buffer(std::size_t min_size);
          </code>
          <effects>Optionally finds a buffer in the store whose length is not less than <c>min_size</c> and whose absence does not have any effects on the completeness of the table.
                   If a suitable buffer is found, then makes the store release the ownership of it.
                   Otherwise, makes a rebound copy of a return value of <c>get_allocator</c> to <c>char_type</c> and allocates a buffer for <c>min_size</c> <c>char_type</c> objects with it.</effects>
          <returns>A pair object of a pointer to the first element of a buffer and its length, which is the value passed to the allocator to obtain the memory.</returns>
          <remark>This function does not change the current buffer mark.</remark>
        </code-item>

        <code-item>
          <code>
void consume_buffer(char_type* buffer, std::size_t size);
          </code>
          <requires><c>buffer</c> shall point the first element of a buffer allocated by a rebound copy of a return value of <c>get_allocator()</c> to <c>char_type</c>.
                    <c>size</c> shall match the value passed to the allocator to obtain this memory.
                    The range [<c>buffer</c>, <c>buffer + size</c>) shall not overlap with any buffers in the store of <c>*this</c>.</requires>
          <effects>Makes the store take over the ownership of the buffer whose first element is pointed by <c>buffer</c> and whose length is <c>size</c>.
                   Then optionally makes a rebound copy of <c>get_allocator</c> to <c>char_type</c> and deallocates the buffer with it.</effects>
          <throws>Nothing.</throws>
          <remark>This function does not change the current buffer mark.</remark>
        </code-item>

        <code-item>
          <code>
void add_buffer(char_type* buffer, std::size_t size);
          </code>
          <requires><c>buffer</c> shall point the first element of a buffer allocated by a rebound copy of a return value of <c>get_allocator()</c> to <c>char_type</c>.
                    <c>size</c> shall match the value passed to the allocator to obtain this memory.
                    The range [<c>buffer</c>, <c>buffer + size</c>) shall not overlap with any buffers in the store of <c>*this</c>.</requires>
          <effects>Makes the store take over the ownership of the buffer whose first element is pointed by <c>buffer</c> and whose length is <c>size</c>.
                   Then marks it as the current buffer.</effects>
          <remark>If an exception is thrown, the buffer is deallocated and the current buffer mark is not changed.</remark>
        </code-item>

        <code-item>
          <code>
void secure_current_upto(char_type* secured_last);
          </code>
          <requires><c>secured_last</c> shall point an element in the current buffer or be the past-the-end pointer of the current buffer.</requires>
          <effects>Marks the range [<c>cb</c>, <c>secured_last</c>) as reserved against <c>rewrite_value</c> and therefore <c>import_value</c> (<xref id="basic_stored_table.rewrite"/>), where <c>cb</c> is a pointer to the first element of the current buffer.</effects>
          <throws>Nothing.</throws>
          <remark>This function does not change the current buffer mark. The reservation marks can not be revoked except by <c>guard_rewrite</c>.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.modifiers">
        <name><c>basic_stored_table</c> modifiers</name>

        <p>To achieve clarity, in this subclause <c>operator[]</c> are used on an object <c>t</c> of an instance of <c>basic_stored_table</c> that does not necessarily have them well-defined. In these cases, the semaintics of <c>t[n]</c> is the same as that of <c>*std::next(t.content().cbegin(), n)</c>.</p>

        <code-item>
          <code>
template &lt;class OtherContent, class OtherAllocator>
  basic_stored_table&amp; operator+=(
    const basic_stored_table&lt;OtherContent, OtherAllocator>&amp; other);
          </code>
          <requires><c>basic_stored_table&lt;OtherContent, OtherAllocator>::char_type</c> and <c>basic_stored_table&lt;OtherContent, OtherAllocator>::traits_type</c> shall be identical types to <c>char_type</c> and <c>traits_type</c> respectively.
                    If an exception is thrown by a call of <c>emplace</c> of <c>content()</c> at the end, there shall be no effects on the before-end elements.
                    Any calls of <c>erase</c> of <c>content()</c> at the end shall not exit via an exception.</requires>
          <postcondition>Let <c>lsize</c> be the value that <c>size()</c> returned before the call.
                         <c>size() == lsize + other.size()</c> shall be <c>true</c>.
                         For each <c>i</c> in the range [<c>0</c>, <c>lsize</c>), the value of <c>(*this)[i]</c> shall be equal to the value that it had before call.
                         For each <c>i</c> in the range [<c>0</c>, <c>other.size()</c>), <c>(*this)[lsize + i] == record_type(other[i].cbegin(), other[i].cend())</c> shall hold <c>true</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherContent>
  basic_stored_table&amp; operator+=(
    basic_stored_table&lt;OtherContent, Allocator>&amp;&amp; other);
          </code>
          <requires><c>basic_stored_table&lt;OtherContent, OtherAllocator>::char_type</c> and <c>basic_stored_table&lt;OtherContent, OtherAllocator>::traits_type</c> shall be identical types to <c>char_type</c> and <c>traits_type</c> respectively.
                    If an exception is thrown by a call of <c>emplace</c> of <c>content()</c> at the end, there shall be no effects on the before-end elements.
                    Neither calls of <c>erase</c> of <c>content()</c> at the end nor <c>erase</c> of <c>other.content()</c> at the end shall exit via an exception.
                    If <c>content_type</c> and <c>OtherContent</c> is the same type which has a nested <c>allocator_type</c> type, their type shall be an allocator-aware container type and any calls of its <c>swap</c> on two objects with equal allocators shall not exit via exception.</requires>
          <postcondition>Let <c>lsize</c> be the value that <c>size()</c> returned before the call.
                         <c>size() == lsize + other.size()</c> shall be <c>true</c>.
                         For each <c>i</c> in the range [<c>0</c>, <c>lsize</c>), the value of <c>(*this)[i]</c> shall be equal to the value that it had before call.
                         For each <c>i</c> in the range [<c>0</c>, <c>other.size()</c>), the value of <c>(*this)[lsize + i]</c> shall be equal to the value that <c>record_type(other[i].cbegin(), other[i].cend())</c> had before the call.</postcondition>
        </code-item>

        <code-item>
          <code>
void swap(basic_stored_table&amp; other)
  noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_swap::value);
          </code>
          <requires>If <c>std::allocator_traits&lt;allocator_type>::propagate_on_container_swap::value</c> is <c>false</c>, <c>get_allocator() == other.get_allocator()</c> shall be <c>true</c>.</requires>
          <effects>Exchanges the contents of <c>*this</c> and <c>other</c>.</effects>
          <remark>The allocators are exchanged if and only if <c>std::allocator_traits&lt;allocator_type>::propagate_on_container_swap::value</c> is not <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="basic_stored_table.nonmember">
        <name><c>basic_stored_table</c> non-member functions</name>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp; left,
              const basic_stored_table&lt;ContentR, AllocatorR>&amp; right);
          </code>
          <effects>Makes a copy of <c>left</c> with the copy constructor of <c>basic_stored_table&lt;ContentL, AllocatorL></c>, which is named <c>t</c>. Then evaluates <c>t += right</c>.</effects>
          <returns><c>t</c> above.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(const basic_stored_table&lt;ContentL, AllocatorL>&amp;  left,
                    basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
          </code>
          <effects>Makes a copy of <c>left</c> with the copy constructor of <c>basic_stored_table&lt;ContentL, AllocatorL></c>, which is named <c>t</c>. Then evaluates <c>t += std::move(right)</c>.</effects>
          <returns><c>t</c> above.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
              const basic_stored_table&lt;ContentR, AllocatorR>&amp;  right);
          </code>
          <returns><c>basic_stored_table&lt;ContentL, AllocatorL>(std::move(left += right))</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class ContentL, class AllocatorL, class ContentR, class AllocatorR>
  basic_stored_table&lt;ContentL, AllocatorL>
    operator+(      basic_stored_table&lt;ContentL, AllocatorL>&amp;&amp; left,
                    basic_stored_table&lt;ContentR, AllocatorR>&amp;&amp; right);
          </code>
          <returns><c>basic_stored_table&lt;ContentL, AllocatorL>(std::move(left += std::move(right)))</c>.</returns>
        </code-item>
      </section>

      <section id="basic_stored_table.swap">
        <name><c>basic_stored_table</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class Content, class Allocator>
  void swap(basic_stored_table&lt;Content, Allocator>&amp; left,
            basic_stored_table&lt;Content, Allocator>&amp; right)
    noexcept(std::allocator_traits&lt;Allocator>::propagate_on_container_swap::value);
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
        </code-item>
      </section>
    </section>

    <section id="stored_table_builder">
      <name>Class template <c>stored_table_builder</c></name>

      <codeblock>
namespace commata {
  template &lt;class Content, class Allocator,
            std::underlying_type_t&lt;stored_table_builder_option> Options = 0>
    class stored_table_builder {
  public:
    using table_type = basic_stored_table&lt;Content, Allocator>;
    using char_type = typename table_type::char_type;

    <c>// <n><xref id="stored_table_builder.cons"/>, construct/copy/destroy:</n></c>
    explicit stored_table_builder(table_type&amp; table, std::size_t max_record_num = 0);
    stored_table_builder(stored_table_builder&amp;&amp; other) noexcept;
   ~stored_table_builder();

    <c>// <n>six member functions below are declared and defined to meet the TableHandler</n>
    // <n>requirements (<xref id="table_handler.requirements"/>):</n></c>
    std::pair&lt;char_type*, std::size_t> get_buffer();
    void release_buffer(const char_type* buffer) noexcept;
    void start_record(const char_type* record_begin);
    bool end_record(const char_type* record_end);
    void update(const char_type* first, const char_type* last);
    void finalize(const char_type* first, const char_type* last);
  };

  <c>// <n><xref id="stored_table_builder.creation"/>, creation functions:</n></c>
  template &lt;class Content, class Allocator, class... Args>
    <nc>see below</nc> make_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table,
                                        Args&amp;&amp;... args);
  template &lt;class Content, class Allocator, class... Args>
    <nc>see below</nc> make_transposed_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table,
                                                   Args&amp;&amp;... args);
}
      </codeblock>

      <p>The class template <c>stored_table_builder</c> is a tool to create an image of a text table (<xref id="definitions.text_table"/>) into a <c>basic_stored_table</c> (<xref id="basic_stored_table"/>) object, which is called the <n>targeted object</n>.
         An instantiation of it satisfies the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for its <c>char_type</c>.
         An object of an instantiation of it can not be reused; that is, it can receive the parsing events that the parser emits only once.</p>

      <p>The template parameters <c>Content</c> and <c>Allocator</c> shall be types that make <c>basic_stored_table&lt;Content, Allocator></c> a valid type.</p>

      <p>The template parameter <c>Options</c> is a bitmask to control the behaviour of the builder.
         Its effects are described in <xref id="table.stored_table_builder.options"/>.
         In it, <c>c</c> denotes an lvalue reference to <c>content()</c> of the targeted object and <c>s</c> does the value that <c>c.size()</c> had before the parsing.
         Indices <c>i</c> and <c>j</c> are zero-based.
         In addition, <c>operator[]</c> and <c>operator+</c> are used on types that do not necessarily have them well-defined.
         In these cases, the semantics of <c>d[n]</c> and <c>p + n</c> are the same as those of <c>*std::next(d.begin(), n)</c> and <c>std::next(p, n)</c> respectively.</p>

      <table id="table.stored_table_builder.options">
        <caption><c>stored_table_builder</c> options</caption>
        <col width="3"/><col width="5"/>

        <tr>
          <th>Condition</th>
          <th>Effects</th>
        </tr>

        <tr>
          <td><c>(Options &amp; stored_table_builder_option_transpose) == 0</c></td>
          <td>The value of the <c>j</c>-th field of the <c>i</c>-th record of the text shall be arranged into <c>c[s + i][j]</c>.</td>
        </tr>

        <tr>
          <td><c>(Options &amp; stored_table_builder_option_transpose) != 0</c></td>
          <td>The value of the <c>j</c>-th field of the <c>i</c>-th record of the text shall be arranged into <c>c[j][s + i]</c>.
              On each arrangement, the range [<c>c[j].begin() + e</c>, <c>c[j].begin() + (s + i)</c>) shall be filled by empty values where <c>e</c> is the value that <c>c[j].size()</c> had before the arrangement.</td>
        </tr>
      </table>

      <p>After parsing, even when it has exited via an exception, the targeted object shall be complete (<xref id="basic_stored_table.defs"/>) and have its content container not empty.</p>

      <section id="stored_table_builder.cons">
        <name><c>stored_table_builder</c> construct/copy/destroy</name>
        <code-item>
          <code>
explicit stored_table_builder(table_type&amp; table, std::size_t max_record_num = 0);
          </code>
          <requires><c>table</c> shall have its content container not empty.</requires>
          <effects>Initializes an object of <c>stored_table_builder&lt;Content, Allocator, Options></c> that holds a reference to the targeted object <c>table</c>.
                   If <c>max_record_num</c> is not <c>0</c>, the returned object make the parser after the first <c>max_record_num</c> records are processed.</effects>
          <remark><c>table.empty()</c> may be <c>false</c>. This constructor does nothing on the targeted object.</remark>
        </code-item>

        <code-item>
          <code>
stored_table_builder(stored_table_builder&amp;&amp; other) noexcept;
          </code>
          <effects>Initializes an object of <c>stored_table_builder&lt;Content, Allocator, Options></c> that holds the same reference to the targeted object as <c>other</c>.</effects>
          <remark>This constructor does nothing on the targeted object.</remark>
        </code-item>

        <code-item>
          <code>
~stored_table_builder();
          </code>
          <remark>This destructor does nothing on the targeted object.</remark>
        </code-item>
      </section>

      <section id="stored_table_builder.creation">
        <name><c>stored_table_builder</c> creation functions</name>

        <code-item>
          <code>
template &lt;class Content, class Allocator, class... Args>
  <nc>see below</nc> make_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table,
                                      Args&amp;&amp;... args);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return stored_table_builder&lt;Content, Allocator>(
         table, std::forward&lt;Args>(args)...);</code>
          </effects>
        </code-item>

        <code-item>
          <code>
template &lt;class Content, class Allocator, class... Args>
  <nc>see below</nc> make_transposed_stored_table_builder(basic_stored_table&lt;Content, Allocator>&amp; table,
                                                 Args&amp;&amp;... args);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return stored_table_builder&lt;Content, Allocator, stored_table_builder_option_transpose>(
         table, std::forward&lt;Args>(args)...));</code>
          </effects>
        </code-item>
      </section>
    </section>
  </section>

  <section id="scanner">
    <name>One-pass scanning operation</name>

    <section id="scanner.table">
      <name>The table scanner</name>

      <section id="scanner.table.general">
        <name>General</name>

        <p>Commata offers a <n>table scanner</n> class template, whose name is <c>basic_table_scanner</c> (<xref id="basic_table_scanner"/>), whose instances meet the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) as a simple facility for one-pass scanning of texts.</p>
        <p>A table scanner object can hold a <n>body field scanner</n> object for each field to which it forwards the field values, and it can hold a <n>record-end scanner</n> object to which it noitifies the end-of-record events.</p>
        <p>In addition, a table scanner object can be configured to recognize some first records as &#x2018;header&#x2019; records. It can simply ignore the header records or can forward the field values in the header to a <n>header field scanner</n> object it holds optionally.</p>
        <p>Properties that the type of the body field scanners shall meet, type of the record-end scanners shall meet, and the type of the header field scanners shall meet are bundled as
           the <c>BodyFieldScanner</c>, the <c>RecordEndScanner</c> and the <c>HeaderFieldScanner</c> requirements respectively.</p>
      </section>

      <section id="field_scanner.requirements">
        <name><c>BodyFieldScanner</c> requirements</name>

        <p>A type <c>S</c> meets the <c>BodyFieldScanner</c> requirements for <c>Ch</c> that is a char-like type, <c>Tr</c> that is a character traits type of <c>Ch</c>, and <c>Allocator</c> that is an allocator type of <c>Ch</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expressions shown in <xref id="table.field_scanner.requirements"/> are valid and have the indicated semantics.</li>
        </ul>

        <p>In <xref id="table.field_scanner.requirements"/>, <c>s</c> is an lvalue of cv-unqualified <c>S</c>.
           <c>b</c> and <c>e</c> are rvalues of <c>Ch*</c>.
           <c>rv</c> is an rvalue of <c>std::basic_string&lt;Ch, Tr, Allocator></c>.</p>

        <p>Requirements shown as (1) and (2) in <xref id="table.field_scanner.requirements"/> are optional, but at least one of (1) and (2) shall be satisfied without falling back to the default behaviours, because they are defined in a cross-referencing manner.</p>

        <table id="table.field_scanner.requirements">
          <caption><c>BodyFieldScanner</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="10"/><col width="6"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remark</th>
            <th>Default behaviour</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>s.field_value(b, e)</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has finalized a text value of the field of a body record.
                Any pointers in the range [<c>b</c>, <c>e</c>] are dereferenceable and any values stored at them are modifiable.
                Initially the range [<c>b</c>, <c>e</c>) represents the value of the field and <c>*e</c> is the terminating zero.
                The range [<c>b</c>, <c>e</c>] may be invalidated after the invocation exits.
                It is unspecified which of (1) and (2) the table scanner calls.</td>
            <td>Creates an <c>std::basic_string&lt;Ch, Tr, Allocator></c> object with the range [<c>b</c>, <c>e</c>) and the table scanners allocator, and then calls (2) with it.</td>
          </tr>

          <tr>
            <td>(2)</td>
            <td><c>s.field_value(rv)</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has finalized a text value of the field of a body record. The value of the field is <c>rv</c>.</td>
            <td>Calls (1) with <c>&amp;*rv.begin()</c> and <c>&amp;*rv.begin() + rv.size()</c>.</td>
          </tr>

          <tr>
            <td>(3)</td>
            <td><c>s.field_skipped()</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has found that the field does not appear in the body record, that is, the record has too few fields to reach the field.</td>
            <td></td>
          </tr>
        </table>
      </section>

      <section id="record_end_scanner.requirements">
        <name><c>RecordEndScanner</c> requirements</name>

        <p>A type <c>S</c> meets the <c>RecordEndScanner</c> requirements if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expression shown in <xref id="table.record_end_scanner.requirements"/> is valid and have the indicated semantics.</li>
        </ul>

        <p>In <xref id="table.record_end_scanner.requirements"/>, <c>s</c> is an lvalue of cv-unqualified <c>S</c>.</p>

        <table id="table.record_end_scanner.requirements">
          <caption><c>RecordEndScanner</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="16"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remark</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>s()</c></td>
            <td>(Not used)</td>
            <td>Called when the table scanner has met an end of a body record.</td>
          </tr>
        </table>
      </section>

      <section id="header_field_scanner.requirements">
        <name><c>HeaderFieldScanner</c> requirements</name>

        <p>A type <c>S</c> meets the <c>HeaderFieldScanner</c> requirements for an instance of <c>basic_table_scanner</c> (<xref id="basic_table_scanner"/>) <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expression shown in <xref id="table.header_field_scanner.requirements"/> is valid and have the indicated semantics.</li>
        </ul>

        <p>In <xref id="table.header_field_scanner.requirements"/>, <c>s</c> is an lvalue of cv-unqualified <c>S</c>.
           The type of <c>j</c> is <c>std::size_t</c>.
           The type of <c>v</c> is <c>const std::pair&lt;T::char_type*, T::char_type*>*</c>.
           <c>t</c> is an lvalue of cv-unqualified <c>T</c>.</p>

        <table id="table.header_field_scanner.requirements">
          <caption><c>HeaderFieldScanner</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="16"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remark</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>s(j, v, t)</c></td>
            <td>Contextually convertible to <c>bool</c></td>
            <td>Called by the table scanner in two situations following.
                <ul>
                  <li>When the table scanner has finalized a value of the header field. <c>j</c> is the zero-based field index.
                      Any pointers in the range [<c>v->first</c>, <c>v->second</c>] are dereferenceable and any values stored at them are modifiable.
                      Initially the range [<c>v->first</c>, <c>v->second</c>) represents the value of the header field and <c>*e</c> is the terminating zero.
                      The range [<c>v->first</c>, <c>v->second</c>] may be invalidated after the invocation exits.</li>
                  <li>When a record in the header has ended. <c>j</c> is the number of the fields in the records. <c>v</c> is a null pointer.</li>
                </ul>
                In any of cases, when <c>!r</c> is not <c>false</c> where <c>r</c> is the return value of this, the table scanner shall uninstall this header field scanner and recognizes that the current record is the final header record, that is, the next record will be the first body record.</td>
          </tr>
        </table>
      </section>
    </section>

    <section id="scanner.builtin_body_field_scanners">
      <name>Default body field scanners</name>

      <section id="scanner.builtin_body_field_scanners.general">
        <name>General</name>

        <p>The Commata library offers three default body field scanner types that meet the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>):
           <c>arithmetic_field_translator</c> (<xref id="arithmetic_field_translator"/>), <c>locale_based_arithmetic_field_translator</c> (<xref id="locale_based_arithmetic_field_translator"/>) and <c>string_field_translator</c> (<xref id="string_field_translator"/>).</p>
        <p>An object of these types <n>translates</n> a field value into a value of its <n>target type</n> and forwards it into its installed <n>sink</n>.</p>
        <p>Behaviours of these default body scanner objects can be customized through the three concepts: <c>FieldTranslatorSink</c> (<xref id="field_translator_sink.requirements"/>), <c>SkippingHandler</c> (<xref id="skipping_handler.requirements"/>) and <c>ConversionErrorHandler</c> (<xref id="conversion_error_handler.requirements"/>).</p>
      </section>

      <section id="field_translator_sink.requirements">
        <name><c>FieldTranslatorSink</c> requirements</name>

        <p>A type <c>S</c> is a <c>FieldTranslatorSink</c> type for the target type <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>it is an output iterator type for the type <c>T</c> or a callable type for an argument of an rvalue of cv-unqualified <c>T</c>.</li>
        </ul>

        <p>To <n>put</n> an object expressed by an rvalue <c>rt</c> of the cv-unqualified type <c>T</c> to an object expressed by an lvalue <c>s</c> of the cv-unqualified type <c>S</c> that is a <c>FieldTranslatorSink</c> type is:</p>
        <ul>
          <li>if <c>S</c> is an output iterator type, to evaluate <c>*s = rt</c>,</li>
          <li>otherwise, to evaluate <c>s(rt)</c>.</li>
        </ul>
      </section>

      <section id="skipping_handler.requirements">
        <name><c>SkippingHandler</c> requirements</name>

        <p>A type <c>H</c> meets the <c>SkippingHandler</c> requirements for the target type <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expression shown in <xref id="table.skipping_handler.requirements"/> is valid and have the indicated semantics.</li>
        </ul>

        <p><xref id="table.skipping_handler.requirements"/> shows two expressions per row.
           It is required that at least one of these two expression qualifies, that is, it is not needed that both of two do.</p>

        <p>In <xref id="table.skipping_handler.requirements"/>, <c>h</c> is an lvalue of cv-unqualified <c>H</c>.
           <c>n</c> is a null pointer whose type is <c>T*</c>.</p>

        <table id="table.skipping_handler.requirements">
          <caption><c>SkippingHandler</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="15"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remark</th>
          </tr>

          <tr>
            <td rowspan="2">(1)</td>
            <td><c>h()</c></td>
            <td rowspan="2"><c>replacement&lt;T></c></td>
            <td rowspan="2">Called when the corresponding field has been skipped, that is, the record has had too few fields to reach the field.
                If <c>r.get()</c> is not <c>nullptr</c> where <c>r</c> is the return value, the translated value of the field shall be constructed from <c>std::move(*r)</c>;
                otherwise, no values shall be put to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td><c>h(n)</c></td>
          </tr>
        </table>
      </section>

      <section id="conversion_error_handler.requirements">
        <name><c>ConversionErrorHandler</c> requirements</name>

        <p>A type <c>H</c> meets the <c>ConversionErrorHandler</c> requirements for a char-like type <c>Ch</c> and the target type <c>T</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>the expressions shown in <xref id="table.conversion_error_handler.requirements"/> are valid and have the indicated semantics.</li>
        </ul>

        <p><xref id="table.conversion_error_handler.requirements"/> shows two expressions per row.
           It is required that at least one of these two expression qualifies, that is, it is not needed that both of two do.</p>

        <p>In <xref id="table.conversion_error_handler.requirements"/>, <c>h</c> is an lvalue of cv-unqualified <c>H</c>.
           <c>b</c> and <c>e</c> are pointers to cv-unqualified <c>Ch</c>.
           The range [<c>b</c>, <c>e</c>) is the value of the field.
           <c>e</c> can be dereferenced and points the terminating zero.
           The type of <c>s</c> is <c>int</c>.
           <c>n</c> is a null pointer whose type is <c>T*</c>.</p>

        <table id="table.conversion_error_handler.requirements">
          <caption><c>ConversionErrorHandler</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="3"/><col width="15"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remark</th>
          </tr>

          <tr>
            <td rowspan="2">(1)</td>
            <td><c>h.invalid_format(b, e)</c></td>
            <td rowspan="2"><c>replacement&lt;T></c></td>
            <td rowspan="2">Called when the corresponding field has a value that can not be converted a value of <c>T</c> due to a format error.
                If <c>r.get()</c> is not <c>nullptr</c> where <c>r</c> is the return value, the translated value of the field shall be constructed from <c>std::move(*r)</c>;
                otherwise, no values shall be put to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td><c>h.invalid_format(b, e, n)</c></td>
          </tr>

          <tr>
            <td rowspan="2">(2)</td>
            <td><c>h.out_of_range(b, e, s)</c></td>
            <td rowspan="2"><c>replacement&lt;T></c></td>
            <td rowspan="2">Called when the corresponding field has a value that can not be converted a value of <c>T</c> due to a range error.
                <c>s</c> shall has a positive value if the field value should be translated into a value above the domain of <c>T</c>, a negative value if the field value should be translated into a value below the domain of <c>T</c>, or <c>0</c> otherwise.
                If <c>r.get()</c> is not <c>nullptr</c> where <c>r</c> is the return value, the translated value of the field shall be constructed from <c>std::move(*r)</c>;
                otherwise, no values shall be put to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td><c>h.out_of_range(b, e, s, n)</c></td>
          </tr>

          <tr>
            <td rowspan="2">(3)</td>
            <td><c>h.empty()</c></td>
            <td rowspan="2"><c>replacement&lt;T></c></td>
            <td rowspan="2">Called when the corresponding field has a value that is empty.
                If <c>r.get()</c> is not <c>nullptr</c> where <c>r</c> is the return value, the translated value of the field shall be constructed from <c>std::move(*r)</c>;
                otherwise, no values shall be put to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td><c>h.empty(n)</c></td>
          </tr>
        </table>
      </section>
    </section>

    <section id="table_scanner_hpp">
      <name>Header <c>"commama/table_scanner.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;cstddef>
#include &lt;locale>
#include &lt;memory>
#include &lt;string>
#include &lt;typeinfo>
#include &lt;utility>

#include "text_error.hpp"

namespace commata {
  <c>// <n><xref id="basic_table_scanner"/>, basic_table_scanner:</n></c>
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class basic_table_scanner;

  using table_scanner = basic_table_scanner&lt;char>;
  using wtable_scanner = basic_table_scanner&lt;wchar_t>;

  <c>// <n><xref id="scanner.builtin.exceptions"/>, exception classes:</n></c>
  class field_translation_error : public text_error;
    class field_not_found : public field_translation_error;
    class field_invalid_format : public field_translation_error;
      class field_empty : public field_invalid_format;
    class field_out_of_range : public field_translation_error;

  struct replacement_ignore_t {};
  constexpr replacement_ignore_t replacement_ignore = replacement_ignore_t{};

  <c>// <n><xref id="replacement"/>, replacement:</n></c>
  template &lt;class T> class replacement;
  template &lt;class T> void swap(replacement&lt;T>&amp; left,
                               replacement&lt;T>&amp; right) noexcept(<nc>see below</nc>);

  struct replacement_fail_t {};
  constexpr replacement_fail_t replacement_fail = replacement_fail_t{};

  <c>// <n><xref id="scanner.builtin.skipping_handlers"/>, default skipping handler classes:</n></c>
  struct fail_if_skipped;
  template &lt;class T> class replace_if_skipped;
  template &lt;class T> void swap(replace_if_skipped&lt;T>&amp; left,
                               replace_if_skipped&lt;T>&amp; right) noexcept(<nc>see below</nc>);

  <c>// <n><xref id="scanner.builtin.conversion_error_handlers"/>, default conversion error handler classes:</n></c>
  struct fail_if_conversion_failed;
  template &lt;class T> class replace_if_conversion_failed;
  template &lt;class T> void swap(replace_if_conversion_failed&lt;T>&amp; left,
                               replace_if_conversion_failed&lt;T>&amp; right) noexcept(<nc>see below</nc>);

  <c>// <n><xref id="arithmetic_field_translator"/>, arithmetic_field_translator:</n></c>
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class arithmetic_field_translator;

  <c>// <n><xref id="locale_based_arithmetic_field_translator"/>, locale_based_arithmetic_field_translator:</n></c>
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class locale_based_arithmetic_field_translator;

  <c>// <n><xref id="string_field_translator"/>, string_field_translator:</n></c>
  template &lt;class Sink, class Ch, class Tr = std::char_traits&lt;Ch>,
            class Allocator = std::allocator&lt;Ch>,
            class SkippingHandler = fail_if_skipped>
    class string_field_translator;

  <c>// <n><xref id="make_field_translator"/>, creation of default field scanners:</n></c>
  template &lt;class T, class Sink, class... Appendices>
    <nc>see below</nc> make_field_translator(Sink sink, Appendices&amp;&amp;... appendices);
  template &lt;class T, class Allocator, class Sink, class... Appendices>
    <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                    Sink sink, Appendices&amp;&amp;... appendices);
  template &lt;class Container, class... Appendices>
    <nc>see below</nc> make_field_translator(Container&amp; values, Appendices&amp;&amp;... appendices);
  template &lt;class Allocator, class Container, class... Appendices>
    <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                    Container&amp; values, Appendices&amp;&amp;... appendices);
}
      </codeblock>
    </section>

    <section id="basic_table_scanner">
      <name>Class template <c>basic_table_scanner</c></name>

      <section id="basic_table_scanner.overview">
        <name>Class template <c>basic_table_scanner</c> overview</name>

        <codeblock>
namespace commata {
  template &lt;class Ch, class Tr = std::char_traits&lt;Ch>, class Allocator = std::allocator&lt;Ch>>
    class basic_table_scanner {
  public:
    using char_type = Ch;
    using traits_type = Tr;
    using allocator_type = Allocator;
    using size_type = typename std::allocator_traits&lt;Allocator>::size_type;

    <c>// <n><xref id="basic_table_scanner.cons"/>, construction:</n></c>
    explicit basic_table_scanner(std::size_t header_record_count = 0, size_type buffer_size = 0);
    basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                        std::size_t header_record_count = 0, size_type buffer_size = 0);
    template &lt;class HeaderFieldScanner>
      explicit basic_table_scanner(HeaderFieldScanner s, size_type buffer_size = 0);
    template &lt;class HeaderFieldScanner>
      basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                          HeaderFieldScanner s, size_type buffer_size = 0);
    basic_table_scanner(basic_table_scanner&amp;&amp; other) noexcept;

   ~basic_table_scanner();

    <c>// <n><xref id="basic_table_scanner.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="basic_table_scanner.field_scanner_access"/>, body field scanner access:</n></c>
    template &lt;class T = std::nullptr_t> void set_field_scanner(std::size_t j, T s = T());
    bool has_field_scanner(std::size_t j) const noexcept;
    const std::type_info&amp; get_field_scanner_type(std::size_t j) const noexcept;
    template &lt;class T> const T* get_field_scanner(std::size_t j) const noexcept;
    template &lt;class T>       T* get_field_scanner(std::size_t j)       noexcept;

    <c>// <n><xref id="basic_table_scanner.record_end_scanner_access"/>, record-end scanner access:</n></c>
    template &lt;class T = std::nullptr_t> void set_record_end_scanner(T s = T());
    bool has_record_end_scanner() const noexcept;
    const std::type_info&amp; get_record_end_scanner_type() const noexcept;
    template &lt;class T> const T* get_record_end_scanner() const noexcept;
    template &lt;class T>       T* get_record_end_scanner()       noexcept;

    <c>// <n>six member functions below are declared and defined to meet the TableHandler</n>
    // <n>requirements (<xref id="table_handler.requirements"/>):</n></c>
    std::pair&lt;Ch*, std::size_t> get_buffer();
    void release_buffer(const Ch* buffer);
    void start_record(const Ch* record_begin);
    void end_record(const Ch* record_end);
    void update(const Ch* first, const Ch* last);
    void finalize(const Ch* first, const Ch* last);

    <c>// <n><xref id="basic_table_scanner.processing_state"/>, processing state:</n></c>
    bool is_in_header() const noexcept;
  };
}
        </codeblock>

        <p>The class template <c>basic_table_scanner</c> describes the table scanner objects (<xref id="scanner.table.general"/>).
           An instantiation of it satisfies the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for the template parameter <c>Ch</c>.
           An object of an instantiation of it can not be reused; that is, it can receive the parsing events that the parser emits only once.</p>
        <p>The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements and <c>Allocator::value_type</c> shall be a type identical to <c>Ch</c>.</p>
      </section>

      <section id="basic_table_scanner.cons">
        <name><c>basic_table_scanner</c> construction</name>

        <code-item>
          <code>
explicit basic_table_scanner(std::size_t header_record_count = 0, size_type buffer_size = 0);
basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                    std::size_t header_record_count = 0, size_type buffer_size = 0);
          </code>
          <effects>Constructs an object of <c>basic_table_scanner</c>.
                   The scanner shall ignore the first <c>header_record_count</c> records as header records.
                   The length of the buffer allocated by <c>get_buffer</c> is unspecified, but <c>buffer_size</c> serves as a hint. <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.
                   The scanner shall allocate and deallocate memory with a default constructed <c>Allocator</c> object (first overload) or a copy of <c>alloc</c> (second overload).</effects>
          <postcondition><c>*this</c> has neither a header field scanner nor any body field scanners installed.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class HeaderFieldScanner>
  explicit basic_table_scanner(HeaderFieldScanner s, size_type buffer_size = 0);
template &lt;class HeaderFieldScanner>
  basic_table_scanner(std::allocator_arg_t, const Allocator&amp; alloc,
                      HeaderFieldScanner s, size_type buffer_size = 0);
          </code>
          <requires><c>HeaderFieldScanner</c> shall meet the <c>HeaderFieldScanner</c> requirements (<xref id="header_field_scanner.requirements"/>) for <c>basic_table_scanner&lt;Ch, Tr, Allocator></c>.</requires>
          <effects>Constructs an object of <c>basic_table_scanner</c> with an header field scanner object installed.
                   The length of the buffer allocated by <c>get_buffer</c> is unspecified, but <c>buffer_size</c> serves as a hint. <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.
                   The scanner shall allocate and deallocate memory with a default constructed <c>Allocator</c> object (first overload) or a copy of <c>alloc</c> (second overload).</effects>
          <postcondition><c>*this</c> has a header field scanner constructed as a copy of <c>s</c> installed and no body field scanners installed.</postcondition>
          <remark>These constructors shall not participate in overload resolution unless <c>std::is_integral&lt;HeaderFieldScanner>::value</c> is <c>false</c>.</remark>
        </code-item>
      </section>

      <section id="basic_table_scanner.allocator">
        <name><c>basic_table_scanner</c> allocator access</name>
        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object held by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="basic_table_scanner.field_scanner_access">
        <name><c>basic_table_scanner</c> body field scanner access</name>

        <code-item>
          <code>
template &lt;class T = std::nullptr_t> void set_field_scanner(std::size_t j, T s = T());
          </code>
          <requires><c>T</c> shall either be (possibly cv-qualified) <c>std::nullptr_t</c>,
                    meet the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>) for <c>Ch</c>, <c>Tr</c> and <c>Allocator</c>, or
                    be (possibly cv-qualified) <c>std::reference_wrapper&lt;U></c> where <c>U</c> shall be a type that meets the <c>BodyFieldScanner</c> requirements for <c>Ch</c> and <c>Tr</c> except that it need not be either <c>MoveConstructible</c> or <c>Destructible</c>.</requires>
          <effects>If <c>T</c> is (possibly cv-qualified) <c>std::nullptr_t</c>, uninstalls the body field scanner installed at zero-based field index <c>j</c> if any.
                   Otherwise, uninstalls the body field scanner installed there if any, and installs a copy of <c>s</c> as a body field scanner in place of it.</effects>
          <remark>If an exception is thrown by this function, this function has no effects.</remark>
        </code-item>

        <code-item>
          <code>
bool has_field_scanner(std::size_t j) const noexcept;
          </code>
          <returns>If <c>*this</c> has a body field scanner installed at zero-based field index <c>j</c>, <c>true</c>; otherwise, <c>false</c>.</returns>
        </code-item>

        <code-item>
          <code>
const std::type_info&amp; get_field_scanner_type(std::size_t j) const noexcept;
          </code>
          <returns>If <c>*this</c> has a body field scanner of type <c>T</c> installed at zero-based field index <c>j</c>, <c>typeid(T)</c>; otherwise, <c>typeid(void)</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class T> const T* get_field_scanner(std::size_t j) const noexcept;
template &lt;class T>       T* get_field_scanner(std::size_t j)       noexcept;
          </code>
          <returns>If <c>get_field_scanner_type(j) == typeid(T)</c>, a pointer to the body field scanner object installed at zero-based field index <c>j</c>; otherwise, a null pointer.</returns>
        </code-item>
      </section>

      <section id="basic_table_scanner.record_end_scanner_access">
        <name><c>basic_table_scanner</c> record-end scanner access</name>

        <code-item>
          <code>
template &lt;class T = std::nullptr_t> void set_record_end_scanner(T s = T());
          </code>
          <requires><c>T</c> shall either be (possibly cv-qualified) <c>std::nullptr_t</c> or meet the <c>RecordEndScanner</c> requirements (<xref id="record_end_scanner.requirements"/>).</requires>
          <effects>If <c>T</c> is (possibly cv-qualified) <c>std::nullptr_t</c>, uninstalls the record-end scanner installed if any.
                   Otherwise, uninstalls the record-end scanner installed if any, and installs a copy of <c>s</c> as the record-end scanner in place of it.</effects>
          <remark>If an exception is thrown by this function, this function has no effects.</remark>
        </code-item>

        <code-item>
          <code>
bool has_record_end_scanner() const noexcept;
          </code>
          <returns>If <c>*this</c> has a record-end scanner installed, <c>true</c>; otherwise, <c>false</c>.</returns>
        </code-item>

        <code-item>
          <code>
const std::type_info&amp; get_record_end_scanner_type() const noexcept;
          </code>
          <returns>If <c>*this</c> has a record-end scanner of type <c>T</c> installed, <c>typeid(T)</c>; otherwise, <c>typeid(void)</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class T> const T* get_record_end_scanner() const noexcept;
template &lt;class T>       T* get_record_end_scanner()       noexcept;
          </code>
          <returns>If <c>get_record_end_scanner_type() == typeid(T)</c>, a pointer to the record-end scanner object installed; otherwise, a null pointer.</returns>
        </code-item>
      </section>

      <section id="basic_table_scanner.processing_state">
        <name><c>basic_table_scanner</c> processing state</name>
        <code-item>
          <code>
bool is_in_header() const noexcept;
          </code>
          <requires>Shall be invoked within a call of <c>parse_csv</c> (<xref id="parse_csv"/>).</requires>
          <returns><c>true</c> if <c>*this</c> is configured to regard some first records as header records and
                   <c>end_record</c> has not be called for the final header record; <c>false</c> otherwise.</returns>
          <note>This member may be useful to implement a table handler class whose object wraps a <c>basic_table_scanner</c> object.</note>
        </code-item>
      </section>
    </section>

    <section id="scanner.builtin.exceptions">
      <name>Exception classes</name>

      <section id="field_translation_error">
        <name>Class <c>field_translation_error</c></name>

        <codeblock>
namespace commata {
  class field_translation_error : public text_error {
  public:
    using text_error::text_error;
  };
}
        </codeblock>

        <p>The class <c>field_translation_error</c> defines the type of the objects thrown by default field scanners of Commata library.</p>
      </section>

      <section id="field_not_found">
        <name>Class <c>field_not_found</c></name>

        <codeblock>
namespace commata {
  class field_not_found : public field_translation_error {
  public:
    using field_translation_error::field_translation_error;
  };
}
        </codeblock>

        <p>The class <c>field_not_found</c> defines the type of the objects thrown by default field scanners of Commata library to report that a record that has too few fields to reach the field scanner concerned was found.</p>
      </section>

      <section id="field_invalid_format">
        <name>Class <c>field_invalid_format</c></name>

        <codeblock>
namespace commata {
  class field_invalid_format : public field_translation_error {
  public:
    using field_translation_error::field_translation_error;
  };
}
        </codeblock>

        <p>The class <c>field_invalid_format</c> defines the type of the objects thrown by default field scanners of Commata library to report field format errors.</p>
      </section>

      <section id="field_empty">
        <name>Class <c>field_empty</c></name>

        <codeblock>
namespace commata {
  class field_empty : public field_invalid_format {
  public:
    using field_invalid_format::field_invalid_format;
  };
}
        </codeblock>

        <p>The class <c>field_empty</c> defines the type of the objects thrown by default field scanners of Commata library to report an empty field.</p>
      </section>

      <section id="field_out_of_range">
        <name>Class <c>field_out_of_range</c></name>

        <codeblock>
namespace commata {
  class field_out_of_range : public field_translation_error {
  public:
    using field_translation_error::field_translation_error;
  };
}
        </codeblock>

        <p>The class <c>field_out_of_range</c> defines the type of the objects thrown by default field scanners of Commata library to report they found a translated field value out of its domain.</p>
      </section>
    </section>

    <section id="replacement">
      <name>Class template <c>replacement</c></name>

      <codeblock>
namespace commata {
  template &lt;class T> class replacement {
  public:
    using value_type = T;

    <c>// <n><xref id="replacement.cons"/>, construct/copy/destroy:</n></c>
    replacement() noexcept;
    replacement(replacement_ignore_t) noexcept;
    template &lt;class U> explicit replacement(U&amp;&amp; t) noexcept(<nc>see below</nc>);
    replacement(const replacement&amp;  other) noexcept(<nc>see below</nc>);
    replacement(      replacement&amp;&amp; other) noexcept(<nc>see below</nc>);
    template &lt;class U> replacement(const replacement&lt;U>&amp;  other) noexcept(<nc>see below</nc>);
    template &lt;class U> replacement(      replacement&lt;U>&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~replacement();
    replacement&amp; operator=(replacement_ignore_t) noexcept;
    template &lt;class U> replacement&amp; operator=(U&amp;&amp; t) noexcept(<nc>see below</nc>);
    replacement&amp; operator=(const replacement&amp;  other) noexcept(<nc>see below</nc>);
    replacement&amp; operator=(      replacement&amp;&amp; other) noexcept(<nc>see below</nc>);
    template &lt;class U> replacement&amp; operator=(const replacement&lt;U>&amp;  other) noexcept(<nc>see below</nc>);
    template &lt;class U> replacement&amp; operator=(      replacement&lt;U>&amp;&amp; other) noexcept(<nc>see below</nc>);

    <c>// <n><xref id="replacement.observe"/>, observers:</n></c>
    explicit operator bool() const noexcept;
    const T* get() const noexcept;
          T* get() noexcept;
    const T&amp; operator*() const;
          T&amp; operator*();
    const T* operator->() const;
          T* operator->();

    <c>// <n><xref id="replacement.modifiers"/>, modifiers:</n></c>
    void swap(replacement&amp; other) noexcept(<nc>see below</nc>);
  };

  <c>// <n><xref id="replacement.special"/>, specialized algorithms:</n></c>
  template &lt;class T> void swap(replacement&lt;T>&amp; left,
                               replacement&lt;T>&amp; right) noexcept(<nc>see below</nc>);
}
      </codeblock>

      <p>The class template <c>replacement</c> offers types whose object is able either to contain a value or not to contain a value.
         This class template is used to define <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>).</p>
      <p><c>T</c> shall not be a reference type and shall satisfy the <c>Destructible</c> requirements.</p>

      <section id="replacement.cons">
        <name><c>replacement</c> construct/copy/destroy</name>

        <code-item>
          <code>
replacement() noexcept;
replacement(replacement_ignore_t) noexcept;
          </code>
          <postcondition><c>*this</c> shall not contain a value.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class U> explicit replacement(U&amp;&amp; t) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_constructible&lt;T, U&amp;&amp;>::value</c> shall be <c>true</c>.</requires>
          <postcondition><c>*this</c> shall contain a value constructed from <c>std::forward&lt;U>(t)</c>.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;T, U&amp;&amp;>::value</c>.
                  This overload shall not participate in overload resolution if <c>std::decay_t&lt;U></c> is the same type as either of <c>replacement_ignore_t</c> or <c>replacement&lt;V></c> for a certain type <c>V</c>.</remark>
        </code-item>

        <code-item>
          <code>
replacement(const replacement&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>T</c> shall be <c>CopyConstructible</c>.</requires>
          <postcondition>If <c>other</c> contains a value, <c>*this</c> shall contain a value constructed from <c>*other</c>.
                         Otherwise, <c>*this</c> shall not contain a value.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;T>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
replacement(replacement&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>T</c> shall be <c>MoveConstructible</c>.</requires>
          <postcondition>If <c>other</c> contains a value, <c>*this</c> shall contain a value constructed from <c>std::move(*other)</c>.
                         Otherwise, <c>*this</c> shall not contain a value.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class U> replacement(const replacement&lt;U>&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_constructible&lt;T, const U&amp;>::value</c> shall be <c>true</c>.</requires>
          <postcondition>If <c>other</c> contains a value, <c>*this</c> shall contain a value constructed from <c>*other</c>.
                         Otherwise, <c>*this</c> shall not contain a value.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;T, const U&amp;>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class U> replacement(replacement&lt;U>&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_constructible&lt;T, U&amp;&amp;>::value</c> shall be <c>true</c>.</requires>
          <postcondition>If <c>other</c> contains a value, <c>*this</c> shall contain a value constructed from <c>std::move(*other)</c>.
                         Otherwise, <c>*this</c> shall not contain a value.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;T, U&amp;&amp;>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
replacement&amp; operator=(replacement_ignore_t) noexcept;
          </code>
          <postcondition><c>*this</c> shall not contain a value.</postcondition>
        </code-item>

        <code-item>
          <code>
template &lt;class U> replacement&amp; operator=(U&amp;&amp; t) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_constructible&lt;T, U&amp;&amp;>::value &amp;&amp; std::is_assignable&lt;T, U&amp;&amp;>::value</c> shall be <c>true</c>.</requires>
          <postcondition><c>*this</c> shall contain a value constructed or assigned from <c>std::forward&lt;U>(t)</c>.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;T>::value</c>.
                  This overload shall not participate in overload resolution if <c>std::decay_t&lt;U></c> is the same type as either of <c>replacement_ignore_t</c> or <c>replacement&lt;V></c> for a certain type <c>V</c>.</remark>
        </code-item>

        <code-item>
          <code>
replacement&amp; operator=(const replacement&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>T</c> shall be <c>CopyConstructible</c> and <c>CopyAssignable</c>.</requires>
          <postcondition>If <c>other</c> contains a value, <c>*this</c> shall contain a value constructed or assigned from <c>*other</c>.
                         Otherwise, <c>*this</c> shall not contain a value.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;T>::value &amp;&amp; std::is_nothrow_copy_assignable&lt;T>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
replacement&amp; operator=(replacement&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>T</c> shall be <c>MoveConstructible</c> and <c>MoveAssignable</c>.</requires>
          <postcondition>If <c>other</c> contains a value, <c>*this</c> shall contain a value constructed or assigned from <c>std::move(*other)</c>.
                         Otherwise, <c>*this</c> shall not contain a value.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value &amp;&amp; std::is_nothrow_move_assignable&lt;T>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class U> replacement&amp; operator=(const replacement&lt;U>&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_constructible&lt;T, const U&amp;>::value &amp;&amp; std::is_assignable&lt;T, const U&amp;>::value</c> shall be <c>true</c>.</requires>
          <postcondition>If <c>other</c> contains a value, <c>*this</c> shall contain a value constructed or assigned from <c>std::move(*other)</c>.
                         Otherwise, <c>*this</c> shall not contain a value.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;T, const U&amp;>::value &amp;&amp; std::is_nothrow_assignable&lt;T, const U&amp;>::value</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class U> replacement&amp; operator=(replacement&lt;U>&amp;&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>std::is_constructible&lt;T, U&amp;&amp;>::value &amp;&amp; std::is_assignable&lt;T, U&amp;&amp;>::value</c> shall be <c>true</c>.</requires>
          <postcondition>If <c>other</c> contains a value, <c>*this</c> shall contain a value constructed or assigned from <c>std::move(*other)</c>.
                         Otherwise, <c>*this</c> shall not contain a value.</postcondition>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_constructible&lt;T, U&amp;&amp;>::value &amp;&amp; std::is_nothrow_assignable&lt;T, U&amp;&amp;>::value</c>.</remark>
        </code-item>
      </section>

      <section id="replacement.observe">
        <name><c>replacement</c> observers</name>

        <code-item>
          <code>
explicit operator bool() const noexcept;
          </code>
          <returns><c>true</c> if <c>*this</c> contains a value, <c>false</c> otherwise.</returns>
        </code-item>

        <code-item>
          <code>
const T* get() const noexcept;
      T* get() noexcept;
          </code>
          <returns>A pointer that points the contained value of <c>*this</c>. If none is contained, <c>nullptr</c>.</returns>
        </code-item>

        <code-item>
          <code>
const T&amp; operator*() const;
      T&amp; operator*();
          </code>
          <requires><c>get() == nullptr</c> shall be <c>false</c>.</requires>
          <returns><c>*get()</c>.</returns>
        </code-item>

        <code-item>
          <code>
const T* operator->() const;
      T* operator->();
          </code>
          <requires><c>get() == nullptr</c> shall be <c>false</c>.</requires>
          <returns><c>get()</c>.</returns>
        </code-item>
      </section>

      <section id="replacement.modifiers">
        <name><c>replacement</c> modifiers</name>

        <code-item>
          <code>
void swap(replacement&amp; other) noexcept(<nc>see below</nc>);
          </code>
          <requires><c>T</c> shall be <c>MmoveConstructible</c>.
                    If both of <c>*this</c> and <c>other</c> contain values, they shall be swappable with each other.</requires>
          <effects>Exchanges the contained values of <c>*this</c> and <c>other</c>.</effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to the value of <c>noexcept(swap(std::declval&lt;T&amp;>(), std::declval&lt;T&amp;>())) &amp;&amp; std::is_nothrow_move_constructible&lt;T>::value</c> evaluated in a context where <c>std::swap</c> participates in the overload resolution.</remark>
        </code-item>
      </section>

      <section id="replacement.special">
        <name><c>replacement</c> specialized algorithms</name>

        <code-item>
          <code>
template &lt;class T> void swap(replacement&lt;T>&amp; left,
                             replacement&lt;T>&amp; right) noexcept(<nc>see below</nc>);
          </code>
          <effects>Equivalent to: <c>left.swap(right);</c></effects>
          <remark>The expression inside <c>noexcept</c> is equivalent to <c>noexcept(left.swap(right))</c>.</remark>
        </code-item>
      </section>
    </section>

    <section id="scanner.builtin.skipping_handlers">
      <name>Default skipping handler classes</name>

      <section id="fail_if_skipped">
        <name>Struct <c>fail_if_skipped</c></name>

        <codeblock>
namespace commata {
  struct fail_if_skipped {
    template &lt;class T> [[noreturn]] replacement&lt;T> operator()(T*) const;
  };
}
        </codeblock>

        <p>The struct <c>fail_if_skipped</c> is a type that meets the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>) for any target types.
           An object of it makes the parsing process fail when the corresponding field is not found in a record.</p>

        <code-item>
          <code>
template &lt;class T> [[noreturn]] replacement&lt;T> operator()(T*) const;
          </code>
          <effects>Throws an object of <c>field_not_found</c> (<xref id="field_not_found"/>).</effects>
        </code-item>
      </section>

      <section id="replace_if_skipped">
        <name>Class template <c>replace_if_skipped</c></name>

        <codeblock>
namespace commata {
  template &lt;class T> class replace_if_skipped {
  public:
    <c>// <n><xref id="replace_if_skipped.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class... Args> explicit replace_if_skipped(Args&amp;&amp;... args) noexcept(<nc>see below</nc>);
    explicit replace_if_skipped(replacement_fail_t) noexcept;
    explicit replace_if_skipped(replacement_ignore_t) noexcept;
    replace_if_skipped(const replace_if_skipped&amp;  other) noexcept(<nc>see below</nc>);
    replace_if_skipped(      replace_if_skipped&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~replace_if_skipped();
    replace_if_skipped&amp; operator=(const replace_if_skipped&amp;  other) noexcept(<nc>see below</nc>);
    replace_if_skipped&amp; operator=(      replace_if_skipped&amp;&amp; other) noexcept(<nc>see below</nc>);

    <c>// <n><xref id="replace_if_skipped.inv"/>, invocation:</n></c>
    replacement&lt;T> operator()() const;

    <c>// <n><xref id="replace_if_skipped.modifiers"/>, modifiers:</n></c>
    void swap(replace_if_skipped&amp; other) noexcept(<nc>see below</nc>);
  };

  <c>// <n><xref id="replace_if_skipped.special"/>, specialized algorithms:</n></c>
  template &lt;class T> void swap(replace_if_skipped&lt;T>&amp; left,
                               replace_if_skipped&lt;T>&amp; right) noexcept(<nc>see below</nc>);
}
        </codeblock>

        <p>The class template <c>replace_if_skipped</c> offers types that meet the <c>SkippingHandler</c> requirements (<xref id="skipping_handler.requirements"/>) whose target type is the template parameter <c>T</c>.
           An object of them supplements the corresponding field that is not found in a record with a fixed value.</p>
        <p><c>T</c> shall be <c>CopyConstructible</c> and <c>Destructible</c>.</p>
        <p>An object of an instance of <c>replace_if_skipped</c> has a <n>replacement action</n>.
           A replacement action can be configured to be either of the three types illustrated in <xref id="table.replace_if_skipped.replacement_actions"/>.</p>

        <table id="table.replace_if_skipped.replacement_actions">
          <caption>Types of replacement actions</caption>
          <col width="1"/><col width="2"/><col width="27"/>

          <tr>
            <th>#</th>
            <th>Type</th>
            <th>Effects</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>copy</c></td>
            <td>Copy constructs an object of <c>T</c> from an object installed into this replacement action and put it to the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td>(2)</td>
            <td><c>ignore</c></td>
            <td>Silently ignores the conversion error without doing anything on the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>

          <tr>
            <td>(3)</td>
            <td><c>fail</c></td>
            <td>Throws an exception without doing anything on the <c>FieldTranslatorSink</c> object (<xref id="field_translator_sink.requirements"/>).</td>
          </tr>
        </table>

        <section id="replace_if_skipped.cons">
          <name><c>replace_if_skipped</c> construct/copy/destroy</name>

          <code-item>
            <code>
template &lt;class... Args> explicit replace_if_skipped(Args&amp;&amp;... args) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures the replacement action to be <c>copy</c> with an object of <c>T</c> constructed from <c>std::forward&lt;Args>(args)...</c>.</effects>
            <remark>Let <c>DF</c> be <c>std::decay_t&lt;F></c> where <c>F</c> is the first type of <c>Args</c>.
                    This overload shall not participate in overload resolution if <c>sizeof...(Args)</c> is equal to <c>1</c> and
                    any one of <c>std::is_base_of&lt;replace_if_skipped&lt;T>, DF>::value</c>,
                    <c>std::is_base_of&lt;replacement_fail_t, DF>::value</c> or
                    <c>std::is_base_of&lt;replacement_ignore_t, DF>::value</c> is <c>true</c>.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value &amp;&amp; std::is_nothrow_constructible&lt;T, Args&amp;&amp;...>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
explicit replace_if_skipped(replacement_fail_t) noexcept;
            </code>
            <effects>Configures the replacement action to be <c>fail</c>.</effects>
          </code-item>

          <code-item>
            <code>
explicit replace_if_skipped(replacement_ignore_t) noexcept;
            </code>
            <effects>Configures the replacement action to be <c>ignore</c>.</effects>
          </code-item>

          <code-item>
            <code>
replace_if_skipped(const replace_if_skipped&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures the replacement action to be the same as <c>other</c>'s.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;T>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_skipped(replace_if_skipped&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures the replacement action to be what <c>other</c> had as its replacement action before the call.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_skipped&amp; operator=(const replace_if_skipped&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>T</c> shall be <c>CopyAssignable</c>.</requires>
            <effects>Configures the replacement action to be the same as <c>other</c>'s.</effects>
            <returns><c>*this</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;T>::value &amp;&amp; std::is_nothrow_copy_assignable&lt;T>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_skipped&amp; operator=(replace_if_skipped&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>T</c> shall be <c>MoveAssignable</c>.</requires>
            <effects>Configures the replacement action to be what <c>other</c> had as its replacement action before the call.</effects>
            <returns><c>*this</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value &amp;&amp; std::is_nothrow_move_assignable&lt;T>::value</c>.</remark>
          </code-item>
        </section>

        <section id="replace_if_skipped.inv">
          <name><c>replace_if_skipped</c> invocation</name>

          <code-item>
            <code>
replacement&lt;T> operator()() const;
            </code>
            <effects>Does as illustrated in <xref id="table.replace_if_skipped.skipped"/> in reference to the replacement action of <c>*this</c>.</effects>

            <table id="table.replace_if_skipped.skipped">
              <caption>Effects of calling of <c>operator()</c></caption>
              <col width="13"/><col width="5"/><col width="18"/>

              <tr>
                <th>#</th>
                <th>Type of the action</th>
                <th>Effects</th>
              </tr>

              <tr>
                <td>(1)</td>
                <td><c>copy</c></td>
                <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into the action.</td>
              </tr>

              <tr>
                <td>(2)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
              </tr>

              <tr>
                <td>(3)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>field_not_found</c> (<xref id="field_not_found"/>).</td>
              </tr>
            </table>

          </code-item>
        </section>

        <section id="replace_if_skipped.modifiers">
          <name><c>replace_if_skipped</c> modifiers</name>

          <code-item>
            <code>
void swap(replace_if_skipped&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires>If both of the replacement action of <c>*this</c> and <c>other</c> are of the type <c>copy</c>, two lvalues of the object of type <c>T</c> installed with the replacement action shall be swappable with each onther.</requires>
            <effects>Exchanges the replacement actions of <c>*this</c> and <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to the value of <c>std::is_nothrow_move_constructible&lt;T>::value &amp;&amp; noexcept(swap(std::declval&lt;T&amp;>(), std::declval&lt;T&amp;>()))</c> evaluated in a context where <c>std::swap</c> participates in the overload resolution.</remark>
          </code-item>
        </section>

        <section id="replace_if_skipped.special">
          <name><c>replace_if_skipped</c> specialized algorithms</name>

          <code-item>
            <code>
template &lt;class T> void swap(replace_if_skipped&lt;T>&amp; left,
                             replace_if_skipped&lt;T>&amp; right) noexcept(<nc>see below</nc>);
            </code>
            <effects>Equivalent to: <c>left.swap(right);</c></effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>noexcept(left.swap(right))</c>.</remark>
          </code-item>
        </section>
      </section>
    </section>

    <section id="scanner.builtin.conversion_error_handlers">
      <name>Default conversion error handler classes</name>

      <section id="scanner.builtin.conversion_error_handlers.general">
        <name>General</name>

        <p>This subclause describes struct <c>fail_if_conversion_failed</c> (<xref id="fail_if_conversion_failed"/>) and class template <c>replace_if_conversion_failed</c> (<xref id="replace_if_conversion_failed"/>),
           which gives the default conversion error handler (<xref id="conversion_error_handler.requirements"/>) types of Commata.</p>
        <p>When the implementations of these throw an exception whose type is <c>text_error</c> or one of its derived classes, the message retrieved with a call to <c>what</c> member function on the exception object may be an NTMBS converted from an wide character string with <c>std::wcrtomb</c> or <c>std::wcsrtombs</c>, that is, with C's global locale.</p>
      </section>

      <section id="fail_if_conversion_failed">
        <name>Struct <c>fail_if_conversion_failed</c></name>

        <codeblock>
namespace commata {
  struct fail_if_conversion_failed {
    template &lt;class T, class Ch>
      [[noreturn]] replacement&lt;T> invalid_format(const Ch*, const Ch*, T* = nullptr) const;
    template &lt;class T, class Ch>
      [[noreturn]] replacement&lt;T> out_of_range(const Ch*, const Ch*, int, T* = nullptr) const;
    template &lt;class T> [[noreturn]] replacement&lt;T> empty(T* = nullptr) const;
  };
}
        </codeblock>

        <p>The struct <c>fail_if_conversion_failed</c> is a type that meets the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>) for any target types.
           An object of it makes the parsing process fail on any conversion errors.</p>

        <code-item>
          <code>
template &lt;class T, class Ch>
  [[noreturn]] replacement&lt;T> invalid_format(const Ch*, const Ch*, T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>field_invalid_format</c> (<xref id="field_invalid_format"/>).</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class T, class Ch>
  [[noreturn]] replacement&lt;T> out_of_range(const Ch*, const Ch*, int, T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>field_out_of_range</c> (<xref id="field_out_of_range"/>).</effects>
        </code-item>

        <code-item>
          <code>
template &lt;class T> [[noreturn]] replacement&lt;T> empty(T* = nullptr) const;
          </code>
          <effects>Throws an object of <c>field_empty</c> (<xref id="field_empty"/>).</effects>
        </code-item>
      </section>

      <section id="replace_if_conversion_failed">
        <name>Class template <c>replace_if_conversion_failed</c></name>

        <codeblock>
namespace commata {
  template &lt;class T> class replace_if_conversion_failed {
    <c>// <n><xref id="replace_if_conversion_failed.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class Empty = T, class InvalidFormat = T,
              class AboveUpperLimit = T>
      explicit
        replace_if_conversion_failed(Empty&amp;&amp;           on_empty             = Empty(),
                                     InvalidFormat&amp;&amp;   on_invalid_format    = InvalidFormat(),
                                     AboveUpperLimit&amp;&amp; on_above_upper_limit = AboveUpperLimit())
          noexcept(<nc>see below</nc>);
    template &lt;class Empty, class InvalidFormat, class AboveUpperLimit, class BelowLowerLimit>
      replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                                   InvalidFormat&amp;&amp;   on_invalid_format,
                                   AboveUpperLimit&amp;&amp; on_above_upper_limit,
                                   BelowLowerLimit&amp;&amp; on_below_lower_limit) noexcept(<nc>see below</nc>);
    template &lt;class Empty, class InvalidFormat, class AboveUpperLimit, class BelowLowerLimit,
              class Underflow>
      replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                                   InvalidFormat&amp;&amp;   on_invalid_format,
                                   AboveUpperLimit&amp;&amp; on_above_upper_limit,
                                   BelowLowerLimit&amp;&amp; on_below_lower_limit,
                                   Underflow&amp;&amp;       on_underflow) noexcept(<nc>see below</nc>);
    replace_if_conversion_failed(const replace_if_conversion_failed&amp;  other) noexcept(<nc>see below</nc>);
    replace_if_conversion_failed(      replace_if_conversion_failed&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~replace_if_conversion_failed();
    replace_if_conversion_failed&amp; operator=(const replace_if_conversion_failed&amp;  other)
      noexcept(<nc>see below</nc>);
    replace_if_conversion_failed&amp; operator=(      replace_if_conversion_failed&amp;&amp; other)
      noexcept(<nc>see below</nc>);

    <c>// <n><xref id="replace_if_conversion_failed.handler"/>, members to meet the ConversionErrorHandler requirements (<xref id="conversion_error_handler.requirements"/>):</n></c>
    template &lt;class Ch> replacement&lt;T> invalid_format(const Ch*, const Ch*) const;
    template &lt;class Ch> replacement&lt;T> out_of_range(const Ch*, const Ch*, int sign) const;
                        replacement&lt;T> empty() const;

    <c>// <n><xref id="replace_if_conversion_failed.modifiers"/>, modifiers:</n></c>
    void swap(replace_if_conversion_failed&amp; other) noexcept(<nc>see below</nc>);
  };

  <c>// <n><xref id="replace_if_conversion_failed.special"/>, specialized algorithms:</n></c>
  template &lt;class T> void swap(replace_if_conversion_failed&lt;T>&amp; left,
                               replace_if_conversion_failed&lt;T>&amp; right) noexcept(<nc>see below</nc>);
}
        </codeblock>

        <p>The class template <c>replace_if_conversion_failed</c> offers types that meet the <c>ConversionErrorHandler</c> requirements (<xref id="conversion_error_handler.requirements"/>) whose target type is the template parameter <c>T</c>.
           On a conversion error, an object of them can make the parsing process fail or offer a substitution of the field value, depending on the category of the error.</p>
        <p><c>T</c> shall be <c>CopyConstructible</c> and <c>Destructible</c>.</p>
        <p>An object of an instance of <c>replace_if_conversion_failed</c> has five replacement actions similarly to an object of <c>replace_if_skipped</c> (<xref id="replace_if_skipped"/>): <c>action_on_empty</c>, <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c>, and <c>action_on_underflow</c>.
           Each of these replacement actions can be configured to be either of the three types illustrated in <xref id="table.replace_if_skipped.replacement_actions"/> independently on one object of <c>replace_if_conversion_failed</c>.</p>

        <section id="replace_if_conversion_failed.cons">
          <name><c>replace_if_conversion_failed</c> construct/copy/destroy</name>

          <code-item>
            <code>
template &lt;class Empty = T, class InvalidFormat = T, class AboveUpperLimit = T>
  explicit
    replace_if_conversion_failed(Empty&amp;&amp;           on_empty             = Empty(),
                                 InvalidFormat&amp;&amp;   on_invalid_format    = InvalidFormat(),
                                 AboveUpperLimit&amp;&amp; on_above_upper_limit = AboveUpperLimit())
      noexcept(<nc>see below</nc>);
            </code>
            <effects>If <c>std::is_base_of&lt;replace_fail_t, std::decay_t&lt;Empty>>::value</c> is not <c>false</c>, configures <c>action_on_empty</c> to be <c>fail</c>.
                     Otherwise, if <c>std::is_base_of&lt;replace_ignore_t, std::decay_t&lt;Empty>>::value</c> is not <c>false</c>, configures it to be <c>ignore</c>.
                     Otherwise, configures it to be <c>copy</c> with an object of <c>T</c> constructed from <c>std::forward&lt;Empty>(on_empty)</c>.
                     Does the same with <c>action_on_invalid_format</c> and <c>action_on_above_upper_limit</c>.
                     Configures <c>action_on_below_lower_limit</c> and <c>action_on_underflow</c> to be <c>copy</c> with a value-initialized object of <c>T</c>.</effects>
            <remark>This overload shall not participate in overload resolution unless <c>std::is_base_of&lt;replace_if_conversion_failed&lt;T>, std::decay_t&lt;Empty>>::value</c> is <c>false</c>.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_default_constructible&lt;T>::value &amp;&amp; std::is_nothrow_move_constructible&lt;T>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Empty, class InvalidFormat, class AboveUpperLimit, class BelowLowerLimit>
  replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                               InvalidFormat&amp;&amp;   on_invalid_format,
                               AboveUpperLimit&amp;&amp; on_above_upper_limit,
                               BelowLowerLimit&amp;&amp; on_below_lower_limit) noexcept(<nc>see below</nc>);
            </code>
            <effects>If <c>std::is_base_of&lt;replace_fail_t, std::decay_t&lt;Empty>>::value</c> is not <c>false</c>, configures <c>action_on_empty</c> to be <c>fail</c>.
                     Otherwise, if <c>std::is_base_of&lt;replace_ignore_t, std::decay_t&lt;Empty>>::value</c> is not <c>false</c>, configures it to be <c>ignore</c>.
                     Otherwise, configures it to be <c>copy</c> with an object of <c>T</c> constructed from <c>std::forward&lt;Empty>(on_empty)</c>.
                     Does the same with <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c> and <c>action_on_below_lower_limit</c>.
                     Configures <c>action_on_underflow</c> to be <c>copy</c> with a value-initialized object of <c>T</c>.</effects>
            <remark>If <c>T</c> is an unsigned integer type, instantiating this overload shall make the program ill-formed.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_default_constructible&lt;T>::value &amp;&amp; std::is_nothrow_move_constructible&lt;T>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class Empty, class InvalidFormat, class AboveUpperLimit, class BelowLowerLimit,
          class Underflow>
  replace_if_conversion_failed(Empty&amp;&amp;           on_empty,
                               InvalidFormat&amp;&amp;   on_invalid_format,
                               AboveUpperLimit&amp;&amp; on_above_upper_limit,
                               BelowLowerLimit&amp;&amp; on_below_lower_limit,
                               Underflow&amp;&amp;       on_underflow) noexcept(<nc>see below</nc>);
            </code>
            <effects>If <c>std::is_base_of&lt;replace_fail_t, std::decay_t&lt;Empty>>::value</c> is not <c>false</c>, configures <c>action_on_empty</c> to be <c>fail</c>.
                     Otherwise, if <c>std::is_base_of&lt;replace_ignore_t, std::decay_t&lt;Empty>>::value</c> is not <c>false</c>, configures it to be <c>ignore</c>.
                     Otherwise, configures it to be <c>copy</c> with an object of <c>T</c> constructed from <c>std::forward&lt;Empty>(on_empty)</c>.
                     Does the same with <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c> and <c>action_on_underflow</c>.</effects>
            <remark>If <c>T</c> is an integer type, instantiating this overload shall make the program ill-formed.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_conversion_failed(const replace_if_conversion_failed&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures all the replacement actions to be the same as <c>other</c>'s.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;T>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_conversion_failed(replace_if_conversion_failed&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Configures all the replacement actions to be what <c>other</c> had as its replacement actions before the call.</effects>
            <remark>If an exception is thrown, <c>other</c> may be left in a valid but unspecified state.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_conversion_failed&amp; operator=(const replace_if_conversion_failed&amp; other)
  noexcept(<nc>see below</nc>);
            </code>
            <requires><c>T</c> shall be <c>CopyAssignable</c>.</requires>
            <effects>Configures all the replacement actions to be the same as <c>other</c>'s.</effects>
            <returns><c>*this</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;T>::value &amp;&amp; std::is_nothrow_copy_assignable&lt;T>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
replace_if_conversion_failed&amp; operator=(replace_if_conversion_failed&amp;&amp; other)
  noexcept(<nc>see below</nc>);
            </code>
            <requires><c>T</c> shall be <c>MoveAssignable</c>.</requires>
            <effects>Configures all the replacement actions to be what <c>other</c> had as its replacement actions before the call.</effects>
            <returns><c>*this</c>.</returns>
            <remark>If an exception is thrown, <c>*this</c> and <c>other</c> may be left in a valid but unspecified state.
                    The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;T>::value &amp;&amp; std::is_nothrow_move_assignable&lt;T>::value</c>.</remark>
          </code-item>
        </section>

        <section id="replace_if_conversion_failed.handler">
          <name><c>replace_if_conversion_failed</c> members to meet the <c>ConversionErrorHandler</c> requirements</name>

          <code-item>
            <code>
template &lt;class Ch> replacement&lt;T> invalid_format(const Ch*, const Ch*) const;
            </code>
            <effects>Does as illustrated in <xref id="table.replace_if_conversion_failed.invalid_format"/> in reference to the <c>action_on_invalid_format</c> of <c>*this</c>.</effects>

            <table id="table.replace_if_conversion_failed.invalid_format">
              <caption>Effects of calling of <c>invalid_format</c></caption>
              <col width="5"/><col width="8"/><col width="5"/><col width="18"/>

              <tr>
                <th>#</th>
                <th>Referenced action</th>
                <th>Type of the action</th>
                <th>Effects</th>
              </tr>

              <tr>
                <td>(1)</td>
                <td rowspan="3"><c>action_on_invalid_format</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(2)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
              </tr>

              <tr>
                <td>(3)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>field_invalid_format</c> (<xref id="field_invalid_format"/>).</td>
              </tr>
            </table>
          </code-item>

          <code-item>
            <code>
template &lt;class Ch> replacement&lt;T> out_of_range(const Ch*, const Ch*, int sign) const;
            </code>
            <effects>Does as illustrated in <xref id="table.replace_if_conversion_failed.out_of_range"/> in reference to <c>sign</c> and the <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c> and <c>action_on_underflow</c> of <c>*this</c>.</effects>

            <table id="table.replace_if_conversion_failed.out_of_range">
              <caption>Effects of calling of <c>out_of_range</c></caption>
              <col width="2"/><col width="3"/><col width="8"/><col width="5"/><col width="18"/>

              <tr>
                <th>#</th>
                <th><c>sign</c></th>
                <th>Referenced action</th>
                <th>Type of the action</th>
                <th>Effects</th>
              </tr>

              <tr>
                <td>(1)</td>
                <td rowspan="3">positive</td>
                <td rowspan="3"><c>action_on_above_upper_limit</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(2)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
              </tr>

              <tr>
                <td>(3)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>field_out_of_range</c> (<xref id="field_out_of_range"/>).</td>
              </tr>

              <tr>
                <td>(4)</td>
                <td rowspan="3">negative</td>
                <td rowspan="3"><c>action_on_below_lower_limit</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(5)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
              </tr>

              <tr>
                <td>(6)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>field_out_of_range</c> (<xref id="field_out_of_range"/>).</td>
              </tr>

              <tr>
                <td>(7)</td>
                <td rowspan="3"><c>0</c></td>
                <td rowspan="3"><c>action_on_underflow</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(8)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
              </tr>

              <tr>
                <td>(9)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>field_out_of_range</c> (<xref id="field_out_of_range"/>).</td>
              </tr>
            </table>
          </code-item>

          <code-item>
            <code>
replacement&lt;T> empty() const;
            </code>
            <effects>Does as illustrated in <xref id="table.replace_if_conversion_failed.empty"/> in reference to the <c>action_on_empty</c> of <c>*this</c>.</effects>

            <table id="table.replace_if_conversion_failed.empty">
              <caption>Effects of a call to <c>empty</c></caption>
              <col width="5"/><col width="8"/><col width="5"/><col width="18"/>

              <tr>
                <th>#</th>
                <th>Referenced action</th>
                <th>Type of the action</th>
                <th>Effects</th>
              </tr>

              <tr>
                <td>(1)</td>
                <td rowspan="3"><c>action_on_empty</c></td>
                <td><c>copy</c></td>
                <td>Returns <c>replacement&lt;T>(t)</c> where <c>t</c> is an object of <c>T</c> installed into this action.</td>
              </tr>

              <tr>
                <td>(2)</td>
                <td><c>ignore</c></td>
                <td>Returns <c>replacement&lt;T>(replacement_ignore)</c>.</td>
              </tr>

              <tr>
                <td>(3)</td>
                <td><c>fail</c></td>
                <td>Throws an object of <c>field_empty</c> (<xref id="field_empty"/>).</td>
              </tr>
            </table>
          </code-item>
        </section>

        <section id="replace_if_conversion_failed.modifiers">
          <name><c>replace_if_conversion_failed</c> modifiers</name>

          <code-item>
            <code>
void swap(replace_if_conversion_failed&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires>For each of at most five replacement actions (<c>action_on_empty</c>, <c>action_on_invalid_format</c>, <c>action_on_above_upper_limit</c>, <c>action_on_below_lower_limit</c>, and <c>action_on_underflow</c>),
                      if both of the replacement action of <c>*this</c> and <c>other</c> are of the type <c>copy</c>, two lvalues of the object of type <c>T</c> installed with the replacement action shall be swappable with each onther.</requires>
            <effects>Exchanges all the replacement actions between <c>*this</c> and <c>other</c>.</effects>
            <remark>If an exception is thrown, <c>*this</c> and <c>other</c> may be left in a valid but unspecified state.
                    The expression inside <c>noexcept</c> is equivalent to the value of <c>std::is_nothrow_move_constructible&lt;T>::value &amp;&amp; noexcept(swap(std::declval&lt;T&amp;>(), std::declval&lt;T&amp;>()))</c> evaluated in a context where <c>std::swap</c> participates in the overload resolution.</remark>
          </code-item>
        </section>

        <section id="replace_if_conversion_failed.special">
          <name><c>replace_if_conversion_failed</c> specialized algorithms</name>

          <code-item>
            <code>
template &lt;class T> void swap(replace_if_conversion_failed&lt;T>&amp; left,
                             replace_if_conversion_failed&lt;T>&amp; right) noexcept(<nc>see below</nc>);
            </code>
            <effects>Equivalent to: <c>left.swap(right);</c></effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>noexcept(left.swap(right))</c>.</remark>
          </code-item>
        </section>
      </section>
    </section>

    <section id="default_body_field_scanner_classes">
      <name>Default body field scanner classes</name>

      <p>This subclause describes the body field scanner classes (<xref id="field_scanner.requirements"/>) built-in to Commata.</p>
      <p>In this subclause, terms on the possible target types of these built-in body field scanner classes are used as follows:</p>
      <ul>
        <li>A type <c>T</c> is a <n>default translatable arithmeric type</n> if <c>T</c> is the same type as either of <c>char</c>, <c>signed char</c>, <c>unsigned char</c>, <c>short</c>, <c>unsigned short</c>, <c>int</c>, <c>unsigned</c>, <c>long</c>, <c>unsigned long</c>, <c>long long</c>, <c>unsigned long long</c>, <c>float</c>, <c>double</c>, or <c>long double</c>.</li>
        <li>A type <c>T</c> is a <n>default translatable string type</n> if <c>T</c> is the same type as <c>std::basic_string&lt;Ch, Tr, Allocator></c> for a certain combination of <c>Ch</c>, <c>Tr</c> and <c>Allocator</c>.</li>
        <li>A type <c>T</c> is a <n>default translatable type</n> if <c>T</c> is a default translatable arithmeric type or a default translatable string type.</li>
      </ul>

      <section id="arithmetic_field_translator">
        <name>Class template <c>arithmetic_field_translator</c></name>

        <codeblock>
namespace commata {
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class arithmetic_field_translator {
  public:
    <c>// <n><xref id="arithmetic_field_translator.cons"/>, construct/copy/destroy:</n></c>
    explicit arithmetic_field_translator(
             Sink sink, SkippingHandler handle_skipping = SkippingHandler(),
             ConversionErrorHandler handle_conversion_error = ConversionErrorHandler());
    arithmetic_field_translator(const arithmetic_field_translator&amp;  other) noexcept(<nc>see below</nc>);
    arithmetic_field_translator(      arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~arithmetic_field_translator();

    <c>// <n><xref id="arithmetic_field_translator.handler_access"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler() noexcept;
    const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
          ConversionErrorHandler&amp; get_conversion_error_handler() noexcept;

    <c>// <n><xref id="arithmetic_field_translator.scanner"/>, members to meet the BodyFieldScanner requirements (<xref id="field_scanner.requirements"/>):</n></c>
    template &lt;class Ch> void field_value(const Ch* begin, const Ch* end);
    void field_skipped();
  };
}
        </codeblock>

        <p>The <c>arithmetic_field_translator</c> class template provides a simple implementation for arithmetic types that meets the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>) whose target type is the template parameter <c>T</c>.</p>
        <p><c>T</c> is the target type (<xref id="scanner.builtin_body_field_scanners.general"/>) and shall be a default translatable arithmeric type.
           <c>Sink</c> shall be a <c>FieldTranslatorSink</c> type for the type <c>T</c> (<xref id="field_translator_sink.requirements"/>).
           The template parameter <c>SkippingHandler</c> shall be a <c>SkippingHandler</c> type for the type <c>T</c> (<xref id="skipping_handler.requirements"/>).
           The template parameter <c>ConversionErrorHandler</c> shall be a <c>ConversionErrorHandler</c> type for the type <c>T</c> (<xref id="conversion_error_handler.requirements"/>).</p>

        <section id="arithmetic_field_translator.cons">
          <name><c>arithmetic_field_translator</c> construct/copy/destroy</name>
          <code-item>
            <code>
explicit arithmetic_field_translator(
         Sink sink, SkippingHandler handle_skipping = SkippingHandler(),
         ConversionErrorHandler handle_conversion_error = ConversionErrorHandler());
          </code>
          <effects>Initializes an object of <c>arithmetic_field_translator</c> that holds copies of <c>sink</c>, <c>handle_skipping</c> and <c>handle_conversion_error</c>
                   as the field translator sink object, the skipping handler object and the conversion error handler object respectively.</effects>
          </code-item>

          <code-item>
            <code>
arithmetic_field_translator(const arithmetic_field_translator&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>Sink</c>, <c>SkippingHandler</c> and <c>ConversionErrorHandler</c> shall be <c>CopyConstructible</c>.</requires>
            <effects>Initializes an object of <c>arithmetic_field_translator</c> that holds a field translator sink object, a skipping handler object and a conversion error handler object initialized with lvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;Sink>::value &amp;&amp; std::is_nothrow_copy_constructible&lt;SkippingHandler>::value &amp;&amp; std::is_nothrow_copy_constructible&lt;ConversionErrorHandler>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
arithmetic_field_translator(arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Initializes an object of <c>arithmetic_field_translator</c> that holds a field translator sink object, a skipping handler object and a conversion error handler object initialized with xvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;Sink>::value &amp;&amp; std::is_nothrow_move_constructible&lt;SkippingHandler>::value &amp;&amp; std::is_nothrow_move_constructible&lt;ConversionErrorHandler>::value</c>.
                    When this constructor exits via an exception, <c>other</c> will be placed in a valid but unspecified state.</remark>
          </code-item>
        </section>

        <section id="arithmetic_field_translator.handler_access">
          <name><c>arithmetic_field_translator</c> handler access</name>
          <code-item>
            <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler() noexcept;
            </code>
            <returns>A reference of the skipping handler held by <c>*this</c>.</returns>
          </code-item>

          <code-item>
            <code>
const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
      ConversionErrorHandler&amp; get_conversion_error_handler() noexcept;
            </code>
            <returns>A reference of the conversion error handler held by <c>*this</c>.</returns>
          </code-item>
        </section>

        <section id="arithmetic_field_translator.scanner">
          <name><c>arithmetic_field_translator</c> members to meet the <c>BodyFieldScanner</c> requirements</name>
          <code-item>
            <code>
template &lt;class Ch> void field_value(const Ch* begin, const Ch* end);
            </code>
            <requires><c>Ch</c> shall be <c>char</c> or <c>wchar_t</c>.</requires>
            <effects><p>First calls a parsing function indicated in <xref id="table.arithmetic_field_translator.parsing_functions"/> for <c>T</c> and <c>Ch</c> to get an arithmetic value <c>v</c> of the range [<c>begin</c>, <c>end</c>).
                        Then does an action indicated in <xref id="table.arithmetic_field_translator.branching"/> depending on the consequence of the call of the parsing function and <c>errno</c>.
                        In <xref id="table.arithmetic_field_translator.branching"/>,</p>
                     <ul>
                       <li><c>ceh</c> is the conversion error handler,</li>
                       <li><c>n</c> is a null pointer of type <c>T*</c>,</li>
                       <li><c>V</c> denotes <c>decltype(v)</c>,</li>
                       <li><c>SV</c> denotes <c>std::make_signed&lt;V>::type</c>,</li>
                       <li><c>x</c> denotes <c>std::numeric_limits&lt;T>::max()</c>, and</li>
                       <li>the domain of <c>T</c> denotes
                         <ul>
                           <li>The range [<c>-x</c>, <c>x</c>] in <c>SV</c> mapped by a conversion to <c>V</c> if <c>T</c> is an unsigned integer type,</li>
                           <li>[<c>std::numeric_limits&lt;T>::min()</c>, <c>x</c>] otherwise.</li>
                         </ul>
                       </li>
                     </ul>
            </effects>

            <table id="table.arithmetic_field_translator.parsing_functions">
              <caption>The parsing functions used by <c>arithmetic_field_translator</c></caption>
              <col width="6"/><col width="2"/><col width="2"/>

              <tr>
                <th><c>T</c></th>
                <th><c>Ch</c> is <c>char</c></th>
                <th><c>Ch</c> is <c>wchar_t</c></th>
              </tr>

              <tr>
                <td><c>char</c> (only if signed), <c>signed char</c>, <c>short</c>, <c>int</c>, or <c>long</c></td>
                <td><c>std::strtol</c></td>
                <td><c>std::wcstol</c></td>
              </tr>

              <tr>
                <td><c>char</c> (only if unsigned), <c>unsigned char</c>, <c>unsigned short</c>, <c>unsigned</c>, or <c>unsigned long</c></td>
                <td><c>std::strtoul</c></td>
                <td><c>std::wcstoul</c></td>
              </tr>

              <tr>
                <td><c>long long</c></td>
                <td><c>std::strtoll</c></td>
                <td><c>std::wcstoll</c></td>
              </tr>

              <tr>
                <td><c>unsigned long long</c></td>
                <td><c>std::strtoull</c></td>
                <td><c>std::wcstoull</c></td>
              </tr>

              <tr>
                <td><c>float</c> or <c>double</c></td>
                <td><c>std::strtod</c></td>
                <td><c>std::wcstod</c></td>
              </tr>

              <tr>
                <td><c>long double</c></td>
                <td><c>std::strtold</c></td>
                <td><c>std::wcstold</c></td>
              </tr>
            </table>

            <table id="table.arithmetic_field_translator.branching">
              <caption>The actions done by an <c>arithmetic_field_translator</c> in response to the consequence of calling the parsing function</caption>
              <col width="1"/><col width="1"/><col width="1"/><col width="1"/><col width="4"/>

              <tr>
                <th>The call consumed all characters in the range</th>
                <th>The range contains at least one character</th>
                <th><c>errno != ERANGE</c></th>
                <th><c>v</c> is in the domain of <c>T</c></th>
                <th>Action</th>
              </tr>

              <tr>
                <td rowspan="4">Yes</td>
                <td rowspan="3">Yes</td>
                <td rowspan="2">Yes</td>
                <td>Yes</td>
                <td>Lets <c>w</c> be <c>static_cast&lt;T>(static_cast&lt;SV>(v) + x + 1)</c> if <c>T</c> is an unsigned integer type, <c>V</c> has a greater size than <c>T</c>, and <c>static_cast&lt;SV>(v)</c> is a negative value; <c>static_cast&lt;T>(v)</c> otherwise.
                    Then puts <c>w</c> into the field translator sink.</td>
              </tr>

              <tr>
                <td>No</td>
                <td rowspan="2">Lets <c>g</c> be a positive value of <c>int</c> if <c>T</c> is an unsigned integer type or the field value should be translated into a value above any values in the domain of <c>T</c>, a negative value of <c>int</c> if the field value should be translated into a value below any values in the domain of <c>T</c>, a zero value of <c>int</c> otherwise.
                    Then evaluates <c>ceh.out_of_range(begin, end, g)</c> or <c>ceh.out_of_range(begin, end, g, n)</c> and lets <c>r</c> be the return value.
                    Then puts <c>*r</c> into the field translator sink if <c>r.get() == nullptr</c> is <c>false</c>.</td>
              </tr>

              <tr>
                <td>No</td>
                <td>&#8211;</td>
              </tr>

              <tr>
                <td>No</td>
                <td>&#8211;</td>
                <td>&#8211;</td>
                <td>Evaluates <c>ceh.empty()</c> or <c>ceh.empty(n)</c> and lets <c>r</c> be the return value.
                    Then puts <c>*r</c> into the field translator sink if <c>r.get() == nullptr</c> is <c>false</c>.</td>
              </tr>

              <tr>
                <td>No</td>
                <td>&#8211;</td>
                <td>&#8211;</td>
                <td>&#8211;</td>
                <td>Evaluates <c>ceh.invalid_format(begin, end)</c> or <c>ceh.invalid_format(begin, end, n)</c> and lets <c>r</c> be the return value.
                    Then puts <c>*r</c> into the field translator sink if <c>r.get() == nullptr</c> is <c>false</c>.</td>
              </tr>
            </table>
          </code-item>

          <code-item>
            <code>
void field_skipped();
            </code>
            <effects>Evaluates <c>get_skipping_handler()()</c> and puts the result into the field translator sink.</effects>
          </code-item>
        </section>
      </section>

      <section id="locale_based_arithmetic_field_translator">
        <name>Class template <c>locale_based_arithmetic_field_translator</c></name>

        <codeblock>
namespace commata {
  template &lt;class T, class Sink, class SkippingHandler = fail_if_skipped,
            class ConversionErrorHandler = fail_if_conversion_failed>
    class locale_based_arithmetic_field_translator {
  public:
    <c>// <n><xref id="locale_based_arithmetic_field_translator.cons"/>, construct/copy/destroy:</n></c>
    explicit locale_based_arithmetic_field_translator(
             Sink sink, const std::locale&amp; loc,
             SkippingHandler handle_skipping = SkippingHandler(),
             ConversionErrorHandler handle_conversion_error = ConversionErrorHandler());
    locale_based_arithmetic_field_translator(
      const locale_based_arithmetic_field_translator&amp;  other) noexcept(<nc>see below</nc>);
    locale_based_arithmetic_field_translator(
            locale_based_arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~locale_based_arithmetic_field_translator();

    <c>// <n><xref id="locale_based_arithmetic_field_translator.handler_access"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler() noexcept;
    const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
          ConversionErrorHandler&amp; get_conversion_error_handler() noexcept;

    <c>// <n><xref id="locale_based_arithmetic_field_translator.scanner"/>, members to meet the BodyFieldScanner requirements (<xref id="field_scanner.requirements"/>):</n></c>
    template &lt;class Ch> void field_value(Ch* begin, Ch* end);
    void field_skipped();
  };
}
        </codeblock>

        <p>The <c>locale_based_arithmetic_field_translator</c> class template provides an implementation for arithmetic types that meets the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>) whose target type is the template parameter <c>T</c> in addition to the <c>arithmetic_field_translator</c> class template (<xref id="arithmetic_field_translator"/>).
          The difference is that an object of <c>locale_based_arithmetic_field_translator</c> can correctly handle the decimal radix separator character and the digit group separator character that differ from those of the C-language locale.</p>
        <p><c>T</c> is the target type (<xref id="scanner.builtin_body_field_scanners.general"/>) and shall be a default translatable arithmeric type.
          <c>Sink</c> shall be a <c>FieldTranslatorSink</c> type for the type <c>T</c> (<xref id="field_translator_sink.requirements"/>).
          The template parameter <c>SkippingHandler</c> shall be a <c>SkippingHandler</c> type for the type <c>T</c> (<xref id="skipping_handler.requirements"/>).
          The template parameter <c>ConversionErrorHandler</c> shall be a <c>ConversionErrorHandler</c> type for the type <c>T</c> (<xref id="conversion_error_handler.requirements"/>).</p>

        <section id="locale_based_arithmetic_field_translator.cons">
          <name><c>locale_based_arithmetic_field_translator</c> construct/copy/destroy</name>
          <code-item>
            <code>
explicit locale_based_arithmetic_field_translator(
         Sink sink, const std::locale&amp; loc,
         SkippingHandler handle_skipping = SkippingHandler(),
         ConversionErrorHandler handle_conversion_error = ConversionErrorHandler());
            </code>
            <effects>Initializes an object of <c>locale_based_arithmetic_field_translator</c> that holds copies of <c>sink</c>, <c>loc</c>, <c>handle_skipping</c> and <c>handle_conversion_error</c>
                    as the field translator sink object, the locale object, the skipping handler object and the conversion error handler object respectively.</effects>
          </code-item>

          <code-item>
            <code>
locale_based_arithmetic_field_translator(
  const locale_based_arithmetic_field_translator&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>Sink</c>, <c>SkippingHandler</c> and <c>ConversionErrorHandler</c> shall be <c>CopyConstructible</c>.</requires>
            <effects>Initializes an object of <c>locale_based_arithmetic_field_translator</c> that holds a field translator sink object, a locale object, a skipping handler object and a conversion error handler object initialized with lvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;Sink>::value &amp;&amp; std::is_nothrow_copy_constructible&lt;SkippingHandler>::value &amp;&amp; std::is_nothrow_copy_constructible&lt;ConversionErrorHandler>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
locale_based_arithmetic_field_translator(
  locale_based_arithmetic_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Initializes an object of <c>locale_based_arithmetic_field_translator</c> that holds a field translator sink object, a locale object, a skipping handler object and a conversion error handler object initialized with xvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;Sink>::value &amp;&amp; std::is_nothrow_move_constructible&lt;SkippingHandler>::value &amp;&amp; std::is_nothrow_move_constructible&lt;ConversionErrorHandler>::value</c>.
                    When this constructor exits via an exception, <c>other</c> will be placed in a valid but unspecified state.</remark>
          </code-item>
        </section>

        <section id="locale_based_arithmetic_field_translator.handler_access">
          <name><c>locale_based_arithmetic_field_translator</c> handler access</name>
          <code-item>
            <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler() noexcept;
            </code>
            <returns>A reference of the skipping handler held by <c>*this</c>.</returns>
          </code-item>

          <code-item>
            <code>
const ConversionErrorHandler&amp; get_conversion_error_handler() const noexcept;
      ConversionErrorHandler&amp; get_conversion_error_handler() noexcept;
            </code>
            <returns>A reference of the conversion error handler held by <c>*this</c>.</returns>
          </code-item>
        </section>

        <section id="locale_based_arithmetic_field_translator.scanner">
          <name><c>locale_based_arithmetic_field_translator</c> members to meet the <c>BodyFieldScanner</c> requirements</name>
          <code-item>
            <code>
template &lt;class Ch> void field_value(Ch* begin, Ch* end);
            </code>
            <requires><c>Ch</c> shall be <c>char</c> or <c>wchar_t</c>.</requires>
            <effects>Let <c>npf</c> be <c>std::use_facet&lt;std::numpunct&lt;Ch>>(loc)</c> where <c>loc</c> is the specified locale.
                     First, if <c>npf.grouping().empty()</c> is <c>false</c>, removes all occurrences of <c>npf.thousands_sep()</c> in the range [<c>begin</c>, <c>end</c>) in place.
                     Second, replaces the first occurrence of <c>npf.decimal_point()</c> in the resulted range with <c>*std::localeconv()->decimal_point</c> conditionally widen with <c>std::btowc</c> to get a value of the type <c>Ch</c> in place.
                     Then calls a parsing function with the resulted range and puts a value into the field translator sink as if a <c>arithmetic_field_translator</c> (<xref id="arithmetic_field_translator"/>) object does.</effects>
          </code-item>

          <code-item>
            <code>
void field_skipped();
            </code>
            <effects>Evaluates <c>get_skipping_handler()()</c> and puts the result into the field translator sink.</effects>
          </code-item>
        </section>
      </section>

      <section id="string_field_translator">
        <name>Class template <c>string_field_translator</c></name>

        <codeblock>
namespace commata {
  template &lt;class Sink, class Ch, class Tr = std::char_traits&lt;Ch>,
            class Allocator = std::allocator&lt;Ch>,
            class SkippingHandler = fail_if_skipped>
    class string_field_translator {
  public:
    using allocator_type = Allocator;

    <c>// <n><xref id="string_field_translator.cons"/>, construct/copy/destroy:</n></c>
    explicit string_field_translator(Sink sink,
                                     SkippingHandler handle_skipping = SkippingHandler());
    string_field_translator(std::allocator_arg_t, const Allocator&amp; alloc, Sink sink,
                            SkippingHandler handle_skipping = SkippingHandler());
    string_field_translator(const string_field_translator&amp;  other) noexcept(<nc>see below</nc>);
    string_field_translator(      string_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
   ~string_field_translator();

    <c>// <n><xref id="string_field_translator.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="string_field_translator.handler_access"/>, handler access:</n></c>
    const SkippingHandler&amp; get_skipping_handler() const noexcept;
          SkippingHandler&amp; get_skipping_handler() noexcept;

    <c>// <n><xref id="string_field_translator.scanner"/>, members to meet the BodyFieldScanner requirements (<xref id="field_scanner.requirements"/>):</n></c>
    void field_value(const Ch* begin, const Ch* end);
    void field_value(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; value);
    void field_skipped();
  };
}
        </codeblock>

        <p>The <c>string_field_translator</c> class template provides a simple implementation for the standard string type that meets the <c>BodyFieldScanner</c> requirements (<xref id="field_scanner.requirements"/>) whose target type is <c>std::basic_string&lt;Ch, Tr, Allocator></c>.
          Its target type (<xref id="scanner.builtin_body_field_scanners.general"/>) is <c>std::basic_string&lt;Ch, Tr, Allocator></c>.</p>
        <p><c>Sink</c> shall be a <c>FieldTranslatorSink</c> type for <c>std::basic_string&lt;Ch, Tr, Allocator></c> (<xref id="field_translator_sink.requirements"/>).
          The template parameter <c>SkippingHandler</c> shall be a <c>SkippingHandler</c> type for the type <c>std::basic_string&lt;Ch, Tr, Allocator></c> (<xref id="skipping_handler.requirements"/>).</p>

        <section id="string_field_translator.cons">
          <name><c>string_field_translator</c> construct/copy/destroy</name>
          <code-item>
            <code>
explicit string_field_translator(Sink sink,
                                 SkippingHandler handle_skipping = SkippingHandler());
            </code>
            <requires><c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
            <effects>Initializes an object of <c>string_field_translator</c> that holds a default constructed <c>Allocator</c> object as its allocator, and copies of <c>sink</c> and <c>handle_skipping</c>
                    as the field translator sink object and the skipping handler object respectively.</effects>
          </code-item>

          <code-item>
            <code>
string_field_translator(std::allocator_arg_t, const Allocator&amp; alloc, Sink sink,
                        SkippingHandler handle_skipping = SkippingHandler());
            </code>
            <effects>Initializes an object of <c>string_field_translator</c> that holds copies of <c>alloc</c>, <c>sink</c> and <c>handle_skipping</c>
                    as the allocator object, the field translator sink object and the skipping handler object respectively.</effects>
          </code-item>

          <code-item>
            <code>
string_field_translator(const string_field_translator&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <requires><c>Sink</c> and <c>SkippingHandler</c> shall be <c>CopyConstructible</c>.</requires>
            <effects>Initializes an object of <c>string_field_translator</c> that holds a field translator sink object, a skipping handler object and an allocator object initialized with lvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_copy_constructible&lt;Sink>::value &amp;&amp; std::is_nothrow_copy_constructible&lt;SkippingHandler>::value</c>.</remark>
          </code-item>

          <code-item>
            <code>
string_field_translator(string_field_translator&amp;&amp; other) noexcept(<nc>see below</nc>);
            </code>
            <effects>Initializes an object of <c>string_field_translator</c> that holds an allocator object, a field translator sink object, and a skipping handler object initialized with xvalues of the corresponding objects of <c>other</c>.</effects>
            <remark>The expression inside <c>noexcept</c> is equivalent to <c>std::is_nothrow_move_constructible&lt;Sink>::value &amp;&amp; std::is_nothrow_move_constructible&lt;SkippingHandler>::value</c>.
                    When this constructor exits via an exception, <c>other</c> will be placed in a valid but unspecified state.</remark>
          </code-item>
        </section>

        <section id="string_field_translator.allocator">
          <name><c>string_field_translator</c> allocator access</name>
          <code-item>
            <code>
allocator_type get_allocator() const noexcept;
            </code>
            <returns>A copy of the allocator object used to construct the string.</returns>
          </code-item>
        </section>

        <section id="string_field_translator.handler_access">
          <name><c>string_field_translator</c> handler access</name>
          <code-item>
            <code>
const SkippingHandler&amp; get_skipping_handler() const noexcept;
      SkippingHandler&amp; get_skipping_handler() noexcept;
            </code>
            <returns>A reference of the skipping handler held by <c>*this</c>.</returns>
          </code-item>
        </section>

        <section id="string_field_translator.scanner">
          <name><c>string_field_translator</c> members to meet the <c>BodyFieldScanner</c> requirements</name>
          <code-item>
            <code>
void field_value(const Ch* begin, const Ch* end);
            </code>
            <effects>Puts <c>std::basic_string&lt;Ch, Tr, Allocator>(begin, end, get_allocator())</c> into the field translator sink.</effects>
          </code-item>

          <code-item>
            <code>
void field_value(std::basic_string&lt;Ch, Tr, Allocator>&amp;&amp; value);
            </code>
            <effects>If <c>value.get_allocator() == get_allocator()</c>, puts <c>std::move(value)</c> into the field translator sink. Otherwise, calls <c>field_value(value.c_str(), value.c_str() + value.size())</c>.</effects>
          </code-item>

          <code-item>
            <code>
void field_skipped();
            </code>
            <effects>Evaluates <c>get_skipping_handler()()</c> and puts the result into the field translator sink.</effects>
          </code-item>
        </section>
      </section>

      <section id="make_field_translator">
        <name>Creation of default field scanners</name>

        <p>In this subclause, a type <c>S</c> is <n>deemed to be an acceptable sink</n> of type <c>T</c> if:</p>
        <ul>
          <li><c>std::iterator_traits&lt;S>::iterator_category</c> is a type equal to <c>std::output_iterator_tag</c>, <c>std::forward_iterator_tag</c>, or their derived type; or</li>
          <li><c>s(t)</c> is a valid expression where <c>s</c> is an lvalue of <c>S</c> and <c>t</c> is an rvalue of <c>T</c>.</li>
        </ul>

        <p>In addition, an expression <c><n>INSERTER</n>(s)</c> for an lvalue <c>s</c> of a cv-unqualified type <c>S</c> is defined as follows:</p>
         <ul>
           <li>if <c>s.push_back(std::declval&lt;S::value_type>())</c> is well-formed when treated as an unevaluated operand., <c>std::back_inserter(s)</c>,</li>
           <li>otherwise, if <c>s.insert(s.end(), std::declval&lt;S::value_type>())</c> is well-formed when treated as an unevaluated operand, <c>std::inserter(s, s.end())</c>,</li>
           <li>otherwise, the program is ill-formed.</li>
         </ul>

        <code-item>
          <code>
template &lt;class T, class Sink, class... Appendices>
  <nc>see below</nc> make_field_translator(Sink sink, Appendices&amp;&amp;... appendices);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return <n>R</n>(std::move(sink), std::forward&lt;Appendices>(appendices)...);</code>
                   <p>where <c><n>R</n></c> is a type decided as follows:</p>
                   <ul>
                     <li>if <c>T</c> is a default translatable string type, <c>string_field_translator&lt;Sink, Ch, Tr, Allocator, Appendices...></c>,</li>
                     <li>otherwise, if the reference-removed type of the first type of <c>Appendices</c> is possibly cv-qualified <c>std::locale</c> or its derived type,
                         <c>locale_based_arithmetic_field_translator&lt;T, Sink, TailOfAppendices...></c> where <c>TailOfAppendices...</c> represents the types of <c>Appendices...</c> without its first type,</li>
                     <li>otherwise, <c>arithmetic_field_translator&lt;T, Sink, Appendices...></c>.</li>
                   </ul>
          </effects>
          <remark>This overload shall not participate in overload resolution unless <c>T</c> is a default translatable type and <c>Sink</c> is deemed to be an acceptable sink of <c>T</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class T, class Allocator, class Sink, class... Appendices>
  <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                  Sink sink, Appendices&amp;&amp;... appendices);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return string_field_translator&lt;Sink, typename T::value_type, typename T::traits_type,
                               Allocator, Appendices...>(
         std::allocator_arg, alloc, std::move(sink), std::forward&lt;Appendices>(appendices)...);</code>
          </effects>
          <remark>This overload shall not participate in overload resolution unless <c>T</c> is a default translatable string type and <c>Sink</c> is deemed to be an acceptable sink of <c>T</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Container, class... Appendices>
  <nc>see below</nc> make_field_translator(Container&amp; values, Appendices&amp;&amp;... appendices);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return make_field_translator&lt;typename Container::value_type>(
         <n>INSERTER</n>(values), std::forward&lt;Appendices>(appendices)...);</code>
          </effects>
          <remark>This overload shall not participate in overload resolution unless <c>Container::value_type</c> is a default translatable type and <c><n>INSERTER</n>(values)</c> is a valid expression.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class Allocator, class Container, class... Appendices>
  <nc>see below</nc> make_field_translator(std::allocator_arg_t, const Allocator&amp; alloc,
                                  Container&amp; values, Appendices&amp;&amp;... appendices);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return make_field_translator&lt;typename Container::value_type>(
         std::allocator_arg, alloc,
         <n>INSERTER</n>(values), std::forward&lt;Appendices>(appendices)...);</code>
          </effects>
          <remark>This overload shall not participate in overload resolution unless <c>Container::value_type</c> is a default translatable string type and <c><n>INSERTER</n>(values)</c> is a valid expression.</remark>
        </code-item>
      </section>
    </section>
  </section>

  <section id="pull">
    <name>Pull parsing</name>

    <section id="table_source.general">
      <name>General</name>

      <p>Commata offers some tools to perform <n>pull parsing</n>, in which the users can immediately access the results of parsing text tables
         with the control of the execution flow of parsing held by the users themselves and with the knowledge of where in the text table they are processing.</p>
      <p>The pull parsing facilities of Commata need objects that can create the table parsers for their &#x2018;pull-parsing&#x2019; table handlers.
         The types of these objects are abstracted into the <c>TableSource</c> requirements (<xref id="table_source.requirements"/>).</p>

      <section id="table_source.requirements">
        <name><c>TableSource</c> requirements</name>

        <p>A type <c>T</c> meets the <c>TableSource</c> requirements for a cv-unqualified char-like type <c>Ch</c> if:</p>
        <ul>
          <li>it satisfies the requirements of <c>MoveConstructible</c> and <c>Destructible</c>, and</li>
          <li>each object of <c>T</c> has (possibly a reference to) a <n>wrapped character input</n> object, and the expressions shown in <xref id="table.table_source.requirements"/> are valid and have the indicated semantics.</li>
        </ul>

        <p>In <xref id="table.table_source.requirements"/>, <c>ct</c> is an lvalue of <c>const T</c> and <c>rt</c> is an rvalue of <c>T</c>.
          <c>H</c> is a type that meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>Ch</c>.
          <c>h</c> is an expression whose type meets the <c>TableHandler</c> requirements (<xref id="table_handler.requirements"/>) for <c>Ch</c>.</p>

        <table id="table.table_source.requirements">
          <caption><c>TableSource</c> requirements</caption>
          <col width="1"/><col width="4"/><col width="9"/><col width="14"/>

          <tr>
            <th>#</th>
            <th>Expression</th>
            <th>Return type</th>
            <th>Remark</th>
          </tr>

          <tr>
            <td>(1)</td>
            <td><c>T::char_type</c></td>
            <td></td>
            <td>Shall be an identical type to <c>Ch</c>.</td>
          </tr>

          <tr>
            <td>(2)</td>
            <td><c>T::parser_type&lt;H></c></td>
            <td></td>
            <td>Shall be a type that meets the <c>TableParser</c> requirements (<xref id="table_parser.requirements"/>) for <c>Ch</c>.</td>
          </tr>

          <tr>
            <td>(3)</td>
            <td><c>ct(h)</c></td>
            <td rowspan="2"><c>T::parser_type&lt;std::decay_t&lt;decltype(h)>></c></td>
            <td rowspan="2">Creates a table parser object <c>p</c> that has its tied character input object which is copy constructed (on (3)) or move constructed (on (4)) from the wrapped character input object of <c>*this</c> and
                its tied table handler object which is constructed with <c>std::move(h)</c> (if <c>h</c> is an rvalue) or with from <c>h</c> (otherwise).
                Then returns <c>p</c>.</td>
          </tr>

          <tr>
            <td>(4)</td>
            <td><c>rt(h)</c></td>
          </tr>
        </table>
      </section>
    </section>

    <section id="table_pull_hpp">
      <name>Header <c>"commama/table_pull.hpp"</c> synopsis</name>

      <codeblock>
#include &lt;iterator>
#include &lt;memory>
#include &lt;ostream>
#include &lt;stdexcept>
#include &lt;string>
#include &lt;type_traits>

namespace commata {

  enum class primitive_table_pull_state : <nc>unspecified</nc> {
    before_parse        = <nc>unspecified</nc>,
    eof                 = <nc>unspecified</nc>,
    start_buffer        = <nc>unspecified</nc>,
    end_buffer          = <nc>unspecified</nc>,
    start_record        = <nc>unspecified</nc>,
    end_record          = <nc>unspecified</nc>,
    empty_physical_line = <nc>unspecified</nc>,
    update              = <nc>unspecified</nc>,
    finalize            = <nc>unspecified</nc>
  };

  <c>// <n><xref id="primitive_table_pull_handle"/>, primitive_table_pull_handle:</n></c>
  enum primitive_table_pull_handle : <nc>see below</nc>;

  <c>// <n><xref id="primitive_table_pull"/>, primitive_table_pull:</n></c>
  template &lt;class TableSource,
            class Allocator = std::allocator&lt;typename TableSource::char_type>,
            std::underlying_type_t&lt;primitive_table_pull_handle> Handle =
              primitive_table_pull_handle_all>
    class primitive_table_pull;

  enum class table_pull_state : <nc>unspecified</nc> {
    before_parse = <nc>unspecified</nc>,
    eof          = <nc>unspecified</nc>,
    field        = <nc>unspecified</nc>,
    record_end   = <nc>unspecified</nc>
  };

  <c>// <n><xref id="table_pull"/>, table_pull:</n></c>
  template &lt;class TableSource,
            class Allocator = std::allocator&lt;typename TableSource::char_type>>
    class table_pull;

  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator==(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator==(const table_pull&lt;TableSource, Allocator>&amp;   v,
                    const Other&amp;                                o) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator==(const Other&amp;                                o,
                    const table_pull&lt;TableSource, Allocator>&amp;   v) noexcept(<nc>see below</nc>);
  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator!=(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator!=(const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator!=(const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);
  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator&lt; (const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator&lt; (const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator&lt; (const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);
  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator> (const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator> (const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator> (const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);
  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator&lt;=(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator&lt;=(const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator&lt;=(const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);
  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator>=(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator>=(const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator>=(const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);

  template &lt;class TableSource, class Allocator>
    std::basic_ostream&lt;typename TableSource::char_type, typename TableSource::traits_type>&amp;
      operator&lt;&lt;(std::basic_ostream&lt;typename TableSource::char_type,
                                    typename TableSource::traits_type>&amp; os,
                 const table_pull&lt;TableSource, Allocator>&amp; o);

  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>
      operator+(const table_pull&lt;TableSource, Allocator>&amp; left,
                const std::basic_string&lt;typename TableSource::char_type,
                                        typename TableSource::traits_type, OtherAllocator>&amp; right);
  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>
      operator+(const table_pull&lt;TableSource, Allocator>&amp; left,
                std::basic_string&lt;typename TableSource::char_type,
                                  typename TableSource::traits_type, OtherAllocator>&amp;&amp; right);
  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>
      operator+(const std::basic_string&lt;typename TableSource::char_type,
                                        typename TableSource::traits_type, OtherAllocator>&amp; left,
                const table_pull&lt;TableSource, Allocator>&amp; right);
  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>
      operator+(std::basic_string&lt;typename TableSource::char_type,
                                  typename TableSource::traits_type, OtherAllocator>&amp;&amp; left,
                const table_pull&lt;TableSource, Allocator>&amp; right);
  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>&amp;
      operator+=(std::basic_string&lt;typename TableSource::char_type,
                                   typename TableSource::traits_type, OtherAllocator>&amp; left,
                 const table_pull&lt;TableSource, Allocator>&amp; right);
  template &lt;class TableSource, class Allocator,
            class OtherAllocator = std::allocator&lt;typename TableSource::char_type>>
    std::basic_string&lt;typename TableSource::char_type,
                      std::char_traits&lt;typename TableSource::char_type>,
                      OtherAllocator>
      to_string(const table_pull&lt;TableSource, Allocator>&amp; o,
                const OtherAllocator&amp; alloc = Allocator());

  template &lt;class TableSource, class... Appendices>
    table_pull&lt;std::decay_t&lt;TableSource>>
      make_table_pull(TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
  template &lt;class TableSource, class Allocator, class... Appendices>
    table_pull&lt;std::decay_t&lt;TableSource>, Allocator>
      make_table_pull(std::allocator_arg_t, const Allocator&amp; alloc,
                      TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
}
      </codeblock>
    </section>

    <section id="primitive_table_pull_handle">
      <name>Type <c>primitive_table_pull_handle</c></name>

      <codeblock>
namespace commata {
  enum primitive_table_pull_handle : <nc>see below</nc> {
    primitive_table_pull_handle_start_buffer        = <nc>unspecified</nc>,
    primitive_table_pull_handle_end_buffer          = <nc>unspecified</nc>,
    primitive_table_pull_handle_empty_physical_line = <nc>unspecified</nc>,
    primitive_table_pull_handle_start_record        = <nc>unspecified</nc>,
    primitive_table_pull_handle_end_record          = <nc>unspecified</nc>,
    primitive_table_pull_handle_update              = <nc>unspecified</nc>,
    primitive_table_pull_handle_finalize            = <nc>unspecified</nc>,
    primitive_table_pull_handle_all                 = -1   <c>// all one bit</c>
  };
}
      </codeblock>

      <p>The enumarated type <c>primitive_table_pull_handle</c> defines several integral values with single one bit and with all one bit, which is used to configure the <c>primitive_table_pull</c> objects (<xref id="primitive_table_pull"/>).
         Its underlying type is an unsigned integer type.</p>
    </section>

    <section id="primitive_table_pull">
      <name>Class template <c>primitive_table_pull</c></name>

      <codeblock>
namespace commata {
  template &lt;class TableSource,
            class Allocator = std::allocator&lt;typename TableSource::char_type>,
            std::underlying_type_t&lt;primitive_table_pull_handle> Handle =
              primitive_table_pull_handle_all>
    class primitive_table_pull {
  public:
    using char_type      = typename TableSource::char_type;
    using allocator_type = Allocator;
    using size_type      = std::size_t;

    <c>// <n><xref id="primitive_table_pull.physical_position_available"/>, physical position availability:</n></c>
    static constexpr bool physical_position_available = <nc>see below</nc>;
    static constexpr std::size_t npos = -1;

    <c>// <n><xref id="primitive_table_pull.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class TableSourceR>
      explicit primitive_table_pull(TableSourceR&amp;&amp; in,
                                    std::size_t buffer_size = 0);
    template &lt;class TableSourceR>
      primitive_table_pull(std::allocator_arg_t, const Allocator&amp; alloc, TableSourceR&amp;&amp; in,
                           std::size_t buffer_size = 0);
    primitive_table_pull(primitive_table_pull&amp;&amp; other) noexcept;
   ~primitive_table_pull();

    <c>// <n><xref id="primitive_table_pull.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="primitive_table_pull.tweaks"/>, tweaks:</n></c>
    bool is_discarding_data() const noexcept;
    primitive_table_pull&amp; set_discarding_data(bool b = true) noexcept;

    <c>// <n><xref id="primitive_table_pull.inv"/>, invocation:</n></c>
    primitive_table_pull&amp; operator()();

    <c>// <n><xref id="primitive_table_pull.state"/>, state:</n></c>
    primitive_table_pull_state state() const noexcept;
    explicit operator bool() const noexcept;
    std::pair&lt;std::size_t, std::size_t> get_physical_position() const noexcept(<nc>see below</nc>);
    char_type*       operator[](size_type i);
    const char_type* operator[](size_type i) const;
    size_type data_size() const noexcept;
    size_type max_data_size() const noexcept;
  };
}
      </codeblock>

      <p>The class template <c>primitive_table_pull</c> describes the low-level pull parser objects for text tables (<xref id="definitions.text_table"/>).</p>
      <p>The template parameter <c>TableSource</c> shall meet the <c>TableSource</c> requirements (<xref id="table_source.requirements"/>) for a char-like type.
         The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements for the type <c>TableSource::char_type</c>.</p>
      <p>An object of an instantiation of it holds two objects:</p>
      <ul>
        <li>a table parser object (<xref id="table_parser.requirements"/>), whose tied table handler object recognizes each invocation on its member functions
            <c>start_buffer</c>, <c>end_buffer</c>, <c>start_record</c>, <c>end_record</c>, <c>empty_physical_line</c>, <c>update</c> and <c>finalize</c> as a <n>parsing event</n>
            and enqueues it into the event queue below, and</li>
        <li>an <n>event queue</n>, which is a queue of the parsing events, and which is enqueued on the back by the tied table handler object of the table parser object and dequeued by the user on the front.</li>
      </ul>
      <p>The user of this class template can configure the table handler object to ignore some parsing event with the template parameter <c>Handle</c>.
         If <c>(Handle &amp; primitive_table_pull_handle_start_buffer) == 0</c> is <c>true</c>, it shall not recognize any invocation of <c>start_buffer</c> as a parsing event and shall not enqueue anything with the invocation.
         All other enumerators but <c>primitive_table_pull_handle_all</c> shall work similarly.
         <c>primitive_table_pull_handle_all</c> has a representation of all one bits and is intended to be used to express &#x2018;ignore none&#x2019;.</p>

      <section id="primitive_table_pull.physical_position_available">
        <name><c>primitive_table_pull</c> physical position availability</name>
        <code-item>
          <code>
static constexpr bool physical_position_available = <nc>see below</nc>;
          </code>
          <remark>The expression in the right of <c>=</c> in the initializer shall be <c>true</c>
                  if the internal parser implements the optional operation <c>get_physical_position</c> (<xref id="table_parser.requirements"/>);
                  <c>false</c> otherwise.</remark>
        </code-item>
      </section>

      <section id="primitive_table_pull.cons">
        <name><c>primitive_table_pull</c> construct/copy/destroy</name>
        <code-item>
          <code>
template &lt;class TableSourceR>
  explicit primitive_table_pull(TableSourceR&amp;&amp; in,
                                std::size_t buffer_size = 0);
          </code>
          <requires><c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <effects>First default constructs an <c>Allocator</c> object <c>a</c>.
                   Creates the event queue that does dynamic memory allocation with <c>a</c>.
                   Creates a table handler object <c>h</c> configured to enqueue events into the event queue above and to use <c>a</c> to allocate buffers and refers <c>buffer_size</c> as a hint of the size (that is, the number of characters) of allocate buffers.
                   Then constructs the table parser object with <c>std::forward&lt;TableSourceR>(in)(std::move(h))</c>.</effects>
          <postcondition><c>is_discarding_data()</c> shall return <c>false</c>.</postcondition>
          <remark><c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.
                  This overload shall not participate in overload resolution unless <c>std::remove_const_t&lt;std::remove_reference_t&lt;TableSourceR>></c> is the same type as <c>TableSource</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class TableSourceR>
  primitive_table_pull(std::allocator_arg_t, const Allocator&amp; alloc, TableSourceR&amp;&amp; in,
                       std::size_t buffer_size = 0);
          </code>
          <requires><c>std::remove_const_t&lt;std::remove_reference_t&lt;TableSourceR>></c> is the same type as <c>TableSource</c>.</requires>
          <effects>First constructs an <c>Allocator</c> object <c>a</c> with <c>alloc</c>.
                   Creates the event queue that does dynamic memory allocation with <c>a</c>.
                   Creates a table handler object <c>h</c> configured to enqueue events into the event queue above and to use <c>a</c> to allocate buffers and refers <c>buffer_size</c> as a hint of the size (that is, the number of characters) of allocate buffers.
                   Then constructs the table parser object with <c>std::forward&lt;TableSourceR>(in)(std::move(h))</c>.</effects>
          <postcondition><c>is_discarding_data()</c> shall return <c>false</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
primitive_table_pull(primitive_table_pull&amp;&amp; other) noexcept;
          </code>
          <effects>Initializes an object of <c>primitive_table_pull</c> that takes over all the internal state of <c>other</c>.</effects>
        </code-item>
      </section>

      <section id="primitive_table_pull.allocator">
        <name><c>primitive_table_pull</c> allocator access</name>

        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object used by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="primitive_table_pull.tweaks">
        <name><c>primitive_table_pull</c> tweaks</name>

        <code-item>
          <code>
bool is_discarding_data() const noexcept;
          </code>
          <returns>Whether <c>*this</c> collects data of events and makes them accessible with <c>operator[]</c> (<c>false</c>) or not (otherwise).</returns>
        </code-item>

        <code-item>
          <code>
primitive_table_pull&amp; set_discarding_data(bool b = true) noexcept;
          </code>
          <effects>Sets whether <c>*this</c> collects data of events and makes them accessible with <c>operator[]</c> (if <c>b</c> is <c>false</c>) or not (otherwise).</effects>
          <returns><c>*this</c>.</returns>
          <note>Setting this to <c>true</c> purely reduces the functionality of <c>*this</c>, but might improve performance.</note>
        </code-item>
      </section>

      <section id="primitive_table_pull.inv">
        <name><c>primitive_table_pull</c> invocation</name>

        <code-item>
          <code>
primitive_table_pull&amp; operator()();
          </code>
          <effects>If <c>state() == primitive_table_pull_state::eof</c> is <c>true</c>, return without doing anything.
                   Otherwise, first dequeues an event from the event queue on the front if the queue is not empty.
                   Then iteratively calls <c>p()</c> to enqueue parsing events into the event queue on the back while the event queue is empty
                   where <c>p</c> is the table parser held by <c>*this</c>.</effects>
          <returns><c>*this</c>.</returns>
          <throws><c>parse_error</c> (<xref id="parse_error"/>) or any exception thrown by the table parser and the allocator.</throws>
          <remark>If an exception is thrown, <c>*this</c> would be placed to a valid but unspecified state.</remark>
        </code-item>
      </section>

      <section id="primitive_table_pull.state">
        <name><c>primitive_table_pull</c> state</name>

        <code-item>
          <code>
primitive_table_pull_state state() const noexcept;
          </code>
          <returns>A value of <c>primitive_table_pull_state</c> that tells the current status of <c>*this</c> as shown in <xref id="table.primitive_table_pull.state"/>.
                   In <xref id="table.primitive_table_pull.state"/>, <c>h</c> denotes the table handler object held by <c>*this</c>.
                   &#x2018;Maximum data size&#x2019; column shows the return value of <c>data_size()</c> if the current event was queued while <c>is_discarding_data()</c> was <c>false</c>.</returns>

          <table id="table.primitive_table_pull.state">
            <caption>The meanings of the values <c>state()</c> returns</caption>
            <col width="5"/><col width="19"/><col width="95"/><col width="12"/>

            <tr>
              <th>#</th>
              <th>Value</th>
              <th>The current status of <c>*this</c></th>
              <th>Maximum data size</th>
            </tr>

            <tr>
              <td><c>(1)</c></td>
              <td><c>before_parse</c></td>
              <td><c>operator()</c> has never been called yet.</td>
              <td>0</td>
            </tr>

            <tr>
              <td><c>(2)</c></td>
              <td><c>eof</c></td>
              <td>The table parser has already consumed all content of its tied table source.</td>
              <td>0</td>
            </tr>

            <tr>
              <td><c>(3)</c></td>
              <td><c>start_buffer</c></td>
              <td>The front of the event queue is the invocation of <c>start_buffer</c> on <c>h</c>.
                  The arguments of the invocation are available as <c>(*this)[0]</c> and <c>(*this)[1]</c> in order
                  if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
              <td>2</td>
            </tr>

            <tr>
              <td><c>(4)</c></td>
              <td><c>end_buffer</c></td>
              <td>The front of the event queue is the invocation of <c>end_buffer</c> on <c>h</c>.
                  The argument of the invocation is available as <c>(*this)[0]</c>
                  if and only if the event was queued while <c>is_discarding_data()</c> is <c>false</c>.
                  All pointers that have been returned by <c>operator[]</c> will be invalidated with the next call of <c>operator()</c>.</td>
              <td>1</td>
            </tr>

            <tr>
              <td><c>(5)</c></td>
              <td><c>empty_physical_line</c></td>
              <td>The front of the event queue is the invocation of <c>empty_physical_line</c> on <c>h</c>.
                  The argument of the invocation is available as <c>(*this)[0]</c>
                  if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
              <td>1</td>
            </tr>

            <tr>
              <td><c>(6)</c></td>
              <td><c>start_record</c></td>
              <td>The front of the event queue is the invocation of <c>start_record</c> on <c>h</c>.
                  The argument of the invocation is available as <c>(*this)[0]</c>
                  if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
              <td>1</td>
            </tr>

            <tr>
              <td><c>(7)</c></td>
              <td><c>end_record</c></td>
              <td>The front of the event queue is the invocation of <c>end_record</c> on <c>h</c>.
                  The argument of the invocation is available as <c>(*this)[0]</c>
                  if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
              <td>1</td>
            </tr>

            <tr>
              <td><c>(8)</c></td>
              <td><c>update</c></td>
              <td>The front of the event queue is the invocation of <c>update</c> on <c>h</c>.
                  The arguments of the invocation are available as <c>(*this)[0]</c> and <c>(*this)[1]</c> in order
                  if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
              <td>2</td>
            </tr>

            <tr>
              <td><c>(9)</c></td>
              <td><c>finalize</c></td>
              <td>The front of the event queue is the invocation of <c>finalize</c> on <c>h</c>.
                  The arguments of the invocation are available as <c>(*this)[0]</c> and <c>(*this)[1]</c> in order
                  if and only if the event was queued while <c>is_discarding_data()</c> was <c>false</c>.</td>
              <td>2</td>
            </tr>
          </table>
        </code-item>

        <code-item>
          <code>
explicit operator bool() const noexcept;
          </code>
          <returns><c>state() != primitive_table_pull_state::eof</c>.</returns>
        </code-item>

        <code-item>
          <code>
std::pair&lt;std::size_t, std::size_t> get_physical_position() const noexcept(<nc>see below</nc>);
          </code>
          <returns>If <c>physical_position_available</c> is <c>true</c>, <c>p.get_physical_position()</c> where <c>p</c> is the internal table parser object.
                   Otherwise, <c>std::make_pair(npos, npos)</c>.</returns>
          <throws>Nothing.</throws>
          <remark>The expression inside <c>noexcept</c> is <c>true</c> if <c>physical_position_available</c> is <c>false</c>.
                  Otherwise, it is equivalent to <c>noexcept(p.get_physical_position()))</c> where <c>p</c> is the internal table parser object.</remark>
        </code-item>

        <code-item>
          <code>
char_type*       operator[](size_type i);
const char_type* operator[](size_type i) const;
          </code>
          <requires><c>i</c> shall be smaller than <c>data_size()</c>.</requires>
          <returns>The <c>i</c>-th (zero-based) argument value of the front of the event queue.</returns>
        </code-item>

        <code-item>
          <code>
size_type data_size() const noexcept;
          </code>
          <returns>An integer value smaller by one than the maximum value that can be passed to <c>operator[]</c>.</returns>
        </code-item>

        <code-item>
          <code>
size_type max_data_size() const noexcept;
          </code>
          <returns>The largest possible number that the member function <c>data_size</c> returns.</returns>
        </code-item>
      </section>
    </section>

    <section id="table_pull">
      <name>Class template <c>table_pull</c></name>

      <codeblock>
namespace commata {
  template &lt;class TableSource,
            class Allocator = std::allocator&lt;typename TableSource::char_type>>
    class table_pull {
  public:
    using char_type      = typename TableSource::char_type;
    using traits_type    = typename TableSource::traits_type;
    using allocator_type = Allocator;

    using value_type      = const char_type;
    using reference       = value_type&amp;;
    using const_reference = reference;
    using pointer         = value_type*;
    using const_pointer   = pointer;
    using size_type       = std::size_t;
    using difference_type = std::ptrdiff_t;
    using iterator        = value_type*;
    using const_iterator  = iterator;
    using reverse_iterator       = std::reverse_iterator&lt;iterator>;
    using const_reverse_iterator = std::reverse_iterator&lt;const_iterator>;

    <c>// <n><xref id="table_pull.physical_position_available"/>, physical position availability:</n></c>
    static constexpr bool physical_position_available = <nc>see below</nc>;
    static constexpr std::size_t npos = -1;

    <c>// <n><xref id="table_pull.cons"/>, construct/copy/destroy:</n></c>
    template &lt;class TableSourceR>
      explicit table_pull(TableSourceR&amp;&amp; in, std::size_t buffer_size = 0);
    template &lt;class TableSourceR>
      table_pull(std::allocator_arg_t, const Allocator&amp; alloc, TableSourceR&amp;&amp; in,
                 std::size_t buffer_size = 0);
    table_pull(table_pull&amp;&amp; other) noexcept;
   ~table_pull();

    <c>// <n><xref id="table_pull.allocator"/>, allocator access:</n></c>
    allocator_type get_allocator() const noexcept;

    <c>// <n><xref id="table_pull.tweaks"/>, tweaks:</n></c>
    bool is_empty_physical_line_aware() const noexcept;
    table_pull&amp; set_empty_physical_line_aware(bool b = true) noexcept;

    <c>// <n><xref id="table_pull.inv"/>, invocation:</n></c>
    table_pull&amp; operator()(std::size_t n = 0);
    table_pull&amp; skip_record(std::size_t n = 0);

    <c>// <n><xref id="table_pull.state"/>, state:</n></c>
    table_pull_state state() const noexcept;
    explicit operator bool() const noexcept;
    std::pair&lt;std::size_t, std::size_t> get_physical_position() const noexcept(<nc>see below</nc>);
    std::pair&lt;std::size_t, std::size_t> get_position() const noexcept;
    const_iterator begin()  const noexcept;
    const_iterator cbegin() const noexcept;
    const_iterator end()  const noexcept;
    const_iterator cend() const noexcept;
    const_reverse_iterator rbegin()  const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    const_reverse_iterator rend()  const noexcept;
    const_reverse_iterator crend() const noexcept;
    const_reference operator[](size_type pos) const;
    const_reference at(size_type pos) const;
    const_reference front() const;
    const_reference back() const;
    const_pointer c_str() const noexcept;
    const_pointer data()  const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    bool empty() const noexcept;

    template &lt;class OtherTr = std::char_traits&lt;char_type>,
      class OtherAllocator = std::allocator&lt;char_type>>
        explicit operator std::basic_string&lt;char_type, OtherTr, OtherAllocator>() const;
  };

  <c>// <n><xref id="table_pull.comparison"/>, table_pull comparison functions:</n></c>
  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator==(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator==(const table_pull&lt;TableSource, Allocator>&amp;   v,
                    const Other&amp;                                o) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator==(const Other&amp;                                o,
                    const table_pull&lt;TableSource, Allocator>&amp;   v) noexcept(<nc>see below</nc>);

  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator!=(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator!=(const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator!=(const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);

  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator&lt; (const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator&lt; (const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator&lt; (const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);

  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator> (const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator> (const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator> (const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);

  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator&lt;=(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator&lt;=(const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator&lt;=(const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);

  template &lt;class TableSourceL, class TableSourceR,
            class AllocatorL, class AllocatorR>
    bool operator>=(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                    const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
  template &lt;class TableSource, class Allocator, class Other>
    bool operator>=(const table_pull&lt;TableSource, Allocator>&amp;   l,
                    const Other&amp;                                r) noexcept(<nc>see below</nc>);
  template &lt;class TableSource, class Allocator, class Other>
    bool operator>=(const Other&amp;                                l,
                    const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);

  <c>// <n><xref id="table_pull.io"/>, <c>table_pull</c> inserters:</n></c>
  template &lt;class TableSource, class Allocator>
    std::basic_ostream&lt;typename TableSource::char_type, typename TableSource::traits_type>&amp;
      operator&lt;&lt;(std::basic_ostream&lt;typename TableSource::char_type,
                                    typename TableSource::traits_type>&amp; os,
                 const table_pull&lt;TableSource, Allocator>&amp; o);

  <c>// <n><xref id="table_pull.conversion"/>, table_pull conversion:</n></c>
  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>
      operator+(const table_pull&lt;TableSource, Allocator>&amp; left,
                const std::basic_string&lt;typename TableSource::char_type,
                                        typename TableSource::traits_type, OtherAllocator>&amp; right);
  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>
      operator+(const table_pull&lt;TableSource, Allocator>&amp; left,
                std::basic_string&lt;typename TableSource::char_type,
                                  typename TableSource::traits_type, OtherAllocator>&amp;&amp; right);
  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>
      operator+(const std::basic_string&lt;typename TableSource::char_type,
                                        typename TableSource::traits_type, OtherAllocator>&amp; left,
                const table_pull&lt;TableSource, Allocator>&amp; right);
  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>
      operator+(std::basic_string&lt;typename TableSource::char_type,
                                  typename TableSource::traits_type, OtherAllocator>&amp;&amp; left,
                const table_pull&lt;TableSource, Allocator>&amp; right);

  template &lt;class TableSource, class Allocator, class OtherAllocator>
    std::basic_string&lt;typename TableSource::char_type,
                      typename TableSource::traits_type, OtherAllocator>&amp;
      operator+=(std::basic_string&lt;typename TableSource::char_type,
                                   typename TableSource::traits_type, OtherAllocator>&amp; left,
                 const table_pull&lt;TableSource, Allocator>&amp; right);

  template &lt;class TableSource, class Allocator,
            class OtherAllocator = std::allocator&lt;typename TableSource::char_type>>
    std::basic_string&lt;typename TableSource::char_type,
                      std::char_traits&lt;typename TableSource::char_type>,
                      OtherAllocator>
      to_string(const table_pull&lt;TableSource, Allocator>&amp; o,
                const OtherAllocator&amp; alloc = Allocator());

  <c>// <n><xref id="table_pull.creation"/>, table_pull creation functions:</n></c>
  template &lt;class TableSource, class... Appendices>
    table_pull&lt;std::decay_t&lt;TableSource>>
      make_table_pull(TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
  template &lt;class TableSource, class Allocator, class... Appendices>
    table_pull&lt;std::decay_t&lt;TableSource>, Allocator>
      make_table_pull(std::allocator_arg_t, const Allocator&amp; alloc,
                      TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
}
      </codeblock>

      <p><c>table_pull</c> is another class template that describes pull parser objects for text tables (<xref id="definitions.text_table"/>) than <c>primitive_table_pull</c> (<xref id="primitive_table_pull"/>).
         It offers higher-level parsing functionality.</p>
      <p>The template parameter <c>TableSource</c> shall meet the <c>TableSource</c> requirements (<xref id="table_source.requirements"/>) for a char-like type.
         The template parameter <c>Allocator</c> shall meet the <c>Allocator</c> requirements for the type <c>TableSource::char_type</c>.</p>
      <p>An object of an instantiation of it performs field-wisely or record-wisely step-by-step parsing of a text table.
         Its user can retrieve the field values through its <n>current string values</n>, which are null-terminated sequences of <c>TableSource::char_type</c>.</p>

      <section id="table_pull.physical_position_available">
        <name><c>table_pull</c> physical position availability</name>
        <code-item>
          <code>
static constexpr bool physical_position_available = <nc>see below</nc>;
          </code>
          <remark>The expression in the right of <c>=</c> in the initializer shall be <c>true</c>
                  if the internal parser implements the optional operation <c>get_physical_position</c> (<xref id="table_parser.requirements"/>);
                  <c>false</c> otherwise.</remark>
        </code-item>
      </section>

      <section id="table_pull.cons">
        <name><c>table_pull</c> construct/copy/destroy</name>
        <code-item>
          <code>
template &lt;class TableSourceR>
  explicit table_pull(TableSourceR&amp;&amp; in, std::size_t buffer_size = 0);
          </code>
          <requires><c>Allocator</c> shall be <c>DefaultConstructible</c>.</requires>
          <effects>Initializes an object of <c>table_pull</c> with a default constructed <c>Allocator</c> object as its allocator object and with a table parser (<xref id="table_parser.requirements"/>) object created by invoking <c>operator()</c> on <c>std::forward&lt;TableSourceR>(in)</c>.
                   <c>buffer_size</c> serves as a hint to allocate buffers.
                   <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.</effects>
          <postcondition><c>is_empty_line_aware()</c> shall return <c>false</c>.</postcondition>
          <remark>This overload shall not participate in overload resolution unless <c>std::remove_const_t&lt;std::remove_reference_t&lt;TableSourceR>></c> is the same type as <c>TableSource</c>.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class TableSourceR>
  table_pull(std::allocator_arg_t, const Allocator&amp; alloc, TableSourceR&amp;&amp; in,
             std::size_t buffer_size = 0);
          </code>
          <requires><c>std::remove_const_t&lt;std::remove_reference_t&lt;TableSourceR>></c> is the same type as <c>TableSource</c>.</requires>
          <effects>Initializes an object of <c>table_pull</c> with an allocator object constructed from <c>alloc</c> and with a table parser (<xref id="table_parser.requirements"/>) object created by invoking <c>operator()</c> on <c>std::forward&lt;TableSourceR>(in)</c>.
                   <c>buffer_size</c> serves as a hint to allocate buffers.
                   <c>buffer_size</c> can be equal to zero, which means &#x2018;no hint&#x2019;.</effects>
          <postcondition><c>is_empty_line_aware()</c> shall return <c>false</c>.</postcondition>
        </code-item>

        <code-item>
          <code>
table_pull(table_pull&amp;&amp; other) noexcept;
          </code>
          <effects>Initializes an object of <c>table_pull</c> that takes over all the internal state of <c>other</c>.</effects>
        </code-item>
      </section>

      <section id="table_pull.allocator">
        <name><c>table_pull</c> allocator access</name>

        <code-item>
          <code>
allocator_type get_allocator() const noexcept;
          </code>
          <returns>A copy of the allocator object used by <c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="table_pull.tweaks">
        <name><c>table_pull</c> tweaks</name>

        <code-item>
          <code>
bool is_empty_physical_line_aware() const noexcept;
          </code>
          <returns>Whether <c>*this</c> treats empty physical lines as records with no fields (<c>true</c>) or ignore empty physical lines (<c>false</c>).</returns>
        </code-item>

        <code-item>
          <code>
table_pull&amp; set_empty_physical_line_aware(bool b = true) noexcept;
          </code>
          <effects>Sets whether <c>*this</c> treats empty physical lines as records with no fields (if <c>b</c> is not <c>false</c>) or ignore empty physical lines (otherwise).</effects>
          <returns><c>*this</c>.</returns>
        </code-item>
      </section>

      <section id="table_pull.inv">
        <name><c>table_pull</c> invocation</name>

        <code-item>
          <code>
table_pull&amp; operator()(std::size_t n = 0);
          </code>
          <effects>If <c>state() == table_pull_state::eof</c> is <c>true</c>, returns without doing anything.
                   Otherwise, reads the text table until next <c>n + 1</c> fields are read, an end of a record is found, or the table source is fully consumed.</effects>
          <returns><c>*this</c>.</returns>
          <throws><c>parse_error</c> (<xref id="parse_error"/>) or any exception thrown by the internal table parser and the allocator.</throws>
          <postcondition><c>(state() == table_pull_state::eof) || (state() == table_pull_state::field) || (state() == table_pull_state::record_end)</c> shall be <c>true</c>.</postcondition>
          <remark>Invalidates all pointers that have been returned by <c>begin</c>, <c>cbegin</c>, <c>end</c> and <c>cend</c>.
                  When exits via an exception, <c>*this</c> will be placed a valid but unspecified state.</remark>
        </code-item>

        <code-item>
          <code>
table_pull&amp; skip_records(std::size_t n = 0);
          </code>
          <effects>If <c>state() == table_pull_state::eof</c> is <c>true</c>, returns without doing anything.
                   Otherwise, reads the text table until <c>n + 1</c> ends of records are found or the table source is fully consumed.</effects>
          <returns><c>*this</c>.</returns>
          <throws><c>parse_error</c> (<xref id="parse_error"/>) or any exception thrown by the internal table parser and the allocator.</throws>
          <postcondition><c>(state() == table_pull_state::eof) || (state() == table_pull_state::record_end)</c> shall be <c>true</c>.</postcondition>
          <remark>Invalidates all pointers that have been returned by <c>begin</c>, <c>cbegin</c>, <c>end</c> and <c>cend</c>.
                  When exits via an exception, <c>*this</c> will be placed a valid but unspecified state.</remark>
        </code-item>
      </section>

      <section id="table_pull.state">
        <name><c>table_pull</c> state</name>

        <code-item>
          <code>
table_pull_state state() const noexcept;
          </code>
          <returns>A value of <c>table_pull_state</c> that tells the current status of <c>*this</c> as shown in <xref id="table.table_pull.state"/>.</returns>

          <table id="table.table_pull.state">
            <caption>The meanings of the values <c>state()</c> returns</caption>
            <col width="5"/><col width="19"/><col width="92"/><col width="15"/>

            <tr>
              <th>#</th>
              <th>Value</th>
              <th>The current status of <c>*this</c></th>
              <th>The current string value</th>
            </tr>

            <tr>
              <td><c>(1)</c></td>
              <td><c>before_parse</c></td>
              <td>Neither <c>operator()</c> nor <c>skip_records</c> has never been called yet.</td>
              <td>An empty string</td>
            </tr>

            <tr>
              <td><c>(2)</c></td>
              <td><c>eof</c></td>
              <td><c>*this</c> has already consumed all content of the table source.</td>
              <td>An empty string</td>
            </tr>

            <tr>
              <td><c>(3)</c></td>
              <td><c>field</c></td>
              <td><c>*this</c> has reached a field with the latest call of <c>operator()</c>.</td>
              <td>The field value</td>
            </tr>

            <tr>
              <td><c>(4)</c></td>
              <td><c>record_end</c></td>
              <td><c>*this</c> has reached an end of the a record with the latest call of <c>operator()</c> or <c>skip_record</c>.</td>
              <td>An empty string</td>
            </tr>
          </table>
        </code-item>

        <code-item>
          <code>
explicit operator bool() const noexcept;
          </code>
          <returns><c>state() != table_pull_state::eof</c>.</returns>
        </code-item>

        <code-item>
          <code>
std::pair&lt;std::size_t, std::size_t> get_physical_position() const noexcept(<nc>see below</nc>);
          </code>
          <returns>If <c>physical_position_available</c> is <c>true</c>, <c>p.get_physical_position()</c> where <c>p</c> is the internal table parser object.
                   Otherwise, <c>std::make_pair(npos, npos)</c>.</returns>
          <throws>Nothing.</throws>
          <remark>The expression inside <c>noexcept</c> is <c>true</c> if <c>physical_position_available</c> is <c>false</c>.
                  Otherwise, it is equivalent to <c>noexcept(p.get_physical_position()))</c> where <c>p</c> is the internal table parser object.</remark>
        </code-item>

        <code-item>
          <code>
std::pair&lt;std::size_t, std::size_t> get_position() const noexcept;
          </code>
          <returns>A pair of integers that may point the logical position of the <c>*this</c> in the text table, whose meanings depends on the return value of <c>state</c> as in <xref id="table.table_pull.get_position"/>.
                   In <xref id="table.table_pull.get_position"/>, <c>r</c> denotes the return value.</returns>

          <table id="table.table_pull.get_position">
            <caption>The meanings of the values <c>get_position()</c> returns</caption>
            <col width="1"/><col width="3"/><col width="8"/><col width="12"/>

            <tr>
              <th>#</th>
              <th>state()</th>
              <th><c>r.first</c></th>
              <th><c>r.second</c></th>
            </tr>

            <tr>
              <td><c>(1)</c></td>
              <td><c>before_parse</c></td>
              <td>Unspecified</td>
              <td>Unspecified</td>
            </tr>

            <tr>
              <td><c>(2)</c></td>
              <td><c>eof</c></td>
              <td>The number of records successfully read</td>
              <td>The number of fields successfully read after the last record successfully read</td>
            </tr>

            <tr>
              <td><c>(3)</c></td>
              <td><c>field</c></td>
              <td>The zero-based index of the record</td>
              <td>The zero-based index of the field in the record</td>
            </tr>

            <tr>
              <td><c>(4)</c></td>
              <td><c>record_end</c></td>
              <td>The zero-based index of the record</td>
              <td>The number of the fields contained in the record</td>
            </tr>
          </table>
        </code-item>

        <code-item>
          <code>
const_iterator begin()  const noexcept;
const_iterator cbegin() const noexcept;
          </code>
          <returns>A pointer that points the first element of a null-terminated sequence of the current string value.</returns>
        </code-item>

        <code-item>
          <code>
const_iterator end()  const noexcept;
const_iterator cend() const noexcept;
          </code>
          <returns>A pointer that points the terminating zero character element of a null-terminated sequence of the current string value.</returns>
        </code-item>

        <code-item>
          <code>
const_reverse_iterator rbegin()  const noexcept;
const_reverse_iterator crbegin() const noexcept;
          </code>
          <returns><c>reverse_iterator(cend())</c>.</returns>
        </code-item>

        <code-item>
          <code>
const_reverse_iterator rend()  const noexcept;
const_reverse_iterator crend() const noexcept;
          </code>
          <returns><c>reverse_iterator(cbegin())</c>.</returns>
        </code-item>


        <code-item>
          <code>
const_reference operator[](size_type pos) const;
          </code>
          <requires><c>pos &lt;= size()</c>.</requires>
          <returns><c>*(cbegin() + pos)</c>.</returns>
        </code-item>

        <code-item>
          <code>
const_reference at(size_type pos) const;
          </code>
          <returns><c>*(cbegin() + pos)</c>.</returns>
          <throws><c>std::out_of_range</c> if <c>pos >= size()</c>.</throws>
        </code-item>

        <code-item>
          <code>
const_reference front() const;
          </code>
          <requires><c>!empty()</c>.</requires>
          <returns><c>*cbegin()</c>.</returns>
        </code-item>

        <code-item>
          <code>
const_reference back() const;
          </code>
          <requires><c>!empty()</c>.</requires>
          <returns><c>*(cend() - 1)</c>.</returns>
        </code-item>

        <code-item>
          <code>
const_pointer c_str() const noexcept;
const_pointer data()  const noexcept;
          </code>
          <returns><c>cbegin()</c>.</returns>
        </code-item>

        <code-item>
          <code>
size_type size() const noexcept;
          </code>
          <returns><c>cend() - cbegin()</c>.</returns>
        </code-item>

        <code-item>
          <code>
size_type max_size() const noexcept;
          </code>
          <returns>The largest possible number that the member function <c>size</c> returns.</returns>
        </code-item>

        <code-item>
          <code>
bool empty() const noexcept;
          </code>
          <returns><c>size() == 0</c>.</returns>
        </code-item>

        <code-item>
          <code>
template &lt;class OtherTr = std::char_traits&lt;char_type>,
  class OtherAllocator = std::allocator&lt;char_type>>
    explicit operator std::basic_string&lt;char_type, OtherTr, OtherAllocator>() const;
          </code>
          <returns><c>std::basic_string&lt;char_type, OtherTr, OtherAllocator>(cbegin(), cend())</c>.</returns>
        </code-item>
      </section>

      <section id="table_pull.comparison">
        <name><c>table_pull</c> comparison functions</name>

        <p>Function templates described in this subclause that take template parameters <c>TableSourceL</c> and <c>TableSourceR</c> shall not participate in overload resolution unless <c>TableSourceL::char_type</c> and <c>TableSourceL::traits_type</c> are the same types as <c>TableSourceR::char_type</c> and <c>TableSourceR::traits_type</c> respectively.</p>
        <p>Function templates described in this subclause that take template parameters <c>TableSource</c> and <c>Other</c> shall not participate in overload resolution unless <c>std::is_convertible&lt;Other, typename TableSource::char_type*>::value</c> is not <c>false</c> or <c>Other</c> is the same type as <c>std::basic_string&lt;typename TableSource::char_type, typename TableSource::traits_type, Allocator></c> for a certain type <c>Allocator</c>.</p>

        <section id="table_pull.comparison.eq">
          <name><c>operator==</c></name>
          <code-item>
            <code>
template &lt;class TableSourceL, class TableSourceR,
          class AllocatorL, class AllocatorR>
  bool operator==(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                  const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
            </code>
            <returns><c>l.size() == r.size() &amp;&amp; TableSourceL::traits_type::compare(l.data(), r.data(), l.size()) == 0</c>.</returns>
          </code-item>

          <code-item>
            <code>
template &lt;class TableSource, class Allocator, class Other>
  bool operator==(const table_pull&lt;TableSource, Allocator>&amp;   v,
                  const Other&amp;                                o) noexcept(<nc>see below</nc>);
template &lt;class TableSource, class Allocator, class Other>
  bool operator==(const Other&amp;                                o,
                  const table_pull&lt;TableSource, Allocator>&amp;   v) noexcept(<nc>see below</nc>);
            </code>
            <returns>If <c>std::is_convertible&lt;Other, const typename TableSource::char_type*>::value</c> is <c>false</c>, <c>v.size() == o.size() &amp;&amp; Tr::compare(v.data(), o.data(), v.size()) == 0</c>.
                     Otherwise, <c>v.size() == TableSource::traits_type::length(o) &amp;&amp; TableSource::traits_type::compare(v.data(), o, v.size()) == 0</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> are <c>true</c> if <c>std::is_convertible&lt;Other, const typename TableSource::char_type*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="table_pull.comparison.ne">
          <name><c>operator!=</c></name>
          <code-item>
            <code>
template &lt;class TableSourceL, class TableSourceR,
          class AllocatorL, class AllocatorR>
  bool operator!=(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                  const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
template &lt;class TableSource, class Allocator, class Other>
  bool operator!=(const table_pull&lt;TableSource, Allocator>&amp;   v,
                  const Other&amp;                                o) noexcept(<nc>see below</nc>);
template &lt;class TableSource, class Allocator, class Other>
  bool operator!=(const Other&amp;                                o,
                  const table_pull&lt;TableSource, Allocator>&amp;   v) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>left != right</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> are <c>true</c> if <c>std::is_convertible&lt;Other, const typename TableSource::char_type*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="table_pull.comparison.lt">
          <name><c>operator&lt;</c></name>
          <code-item>
            <code>
template &lt;class TableSourceL, class TableSourceR,
          class AllocatorL, class AllocatorR>
  bool operator&lt; (const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                  const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
            </code>
            <returns><c>c &lt; 0 || (c == 0 &amp;&amp; l.size() &lt; r.size())</c> where <c>c</c> is the return value of <c>TableSourceL::traits_type::compare(l.data(), r.data(), rlen)</c> and <c>rlen</c> is the smaller of <c>l.size()</c> and <c>r.size()</c>.</returns>
          </code-item>

          <code-item>
            <code>
template &lt;class TableSource, class Allocator, class Other>
  bool operator&lt; (const table_pull&lt;TableSource, Allocator>&amp;   v,
                  const Other&amp;                                o) noexcept(<nc>see below</nc>);
            </code>
            <returns>If <c>std::is_convertible&lt;Other, typename TableSource::char_type*>::value</c> is <c>false</c>,
                     <c>c &lt; 0 || (c == 0 &amp;&amp; v.size() &lt; o.size()</c> where <c>c</c> is the return value of <c>TableSource::traits_type::compare(v.data(), o.data(), rlen)</c> and <c>rlen</c> is the smaller of <c>v.size()</c> and <c>o.size()</c>.
                     Otherwise, <c>c &lt; 0 || (c == 0 &amp;&amp; v.size() &lt; TableSource::traits_type::length(o)</c> where <c>c</c> is the return value of <c>TableSource::traits_type::compare(v.data(), o, rlen)</c> and <c>rlen</c> is the smaller of <c>v.size()</c> and <c>Tr::length(o)</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is <c>true</c> if <c>std::is_convertible&lt;Other, const typename TableSource::char_type*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>

          <code-item>
            <code>
template &lt;class TableSource, class Allocator, class Other>
  bool operator&lt; (const Other&amp;                                o,
                  const table_pull&lt;TableSource, Allocator>&amp;   v) noexcept(<nc>see below</nc>);
            </code>
            <returns>If <c>std::is_convertible&lt;Other, typename TableSource::char_type*>::value</c> is <c>false</c>,
                     <c>c &lt; 0 || (c == 0 &amp;&amp; o.size() &lt; v.size()</c> where <c>c</c> is the return value of <c>TableSource::traits_type::compare(o.data(), v.data(), rlen)</c> and <c>rlen</c> is the smaller of <c>o.size()</c> and <c>v.size()</c>.
                     Otherwise, <c>c &lt; 0 || (c == 0 &amp;&amp; TableSource::traits_type::length(o) &lt; v.size()</c> where <c>c</c> is the return value of <c>TableSource::traits_type::compare(o, v.data(), rlen)</c> and <c>rlen</c> is the smaller of <c>Tr::length(o)</c> and <c>v.size()</c>.</returns>
            <remark>The expression inside <c>noexcept</c> is <c>true</c> if <c>std::is_convertible&lt;Other, const typename TableSource::char_type*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="table_pull.comparison.gt">
          <name><c>operator></c></name>
          <code-item>
            <code>
template &lt;class TableSourceL, class TableSourceR,
          class AllocatorL, class AllocatorR>
  bool operator> (const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                  const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
template &lt;class TableSource, class Allocator, class Other>
  bool operator> (const table_pull&lt;TableSource, Allocator>&amp;   l,
                  const Other&amp;                                r) noexcept(<nc>see below</nc>);
template &lt;class TableSource, class Allocator, class Other>
  bool operator> (const Other&amp;                                l,
                  const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>r &lt; l</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> if <c>std::is_convertible&lt;Other, const typename TableSource::char_type*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="table_pull.comparison.le">
          <name><c>operator&lt;=</c></name>
          <code-item>
            <code>
template &lt;class TableSourceL, class TableSourceR,
          class AllocatorL, class AllocatorR>
  bool operator&lt;=(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                  const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
template &lt;class TableSource, class Allocator, class Other>
  bool operator&lt;=(const table_pull&lt;TableSource, Allocator>&amp;   l,
                  const Other&amp;                                r) noexcept(<nc>see below</nc>);
template &lt;class TableSource, class Allocator, class Other>
  bool operator&lt;=(const Other&amp;                                l,
                  const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>!(r &lt; l)</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> if <c>std::is_convertible&lt;Other, const typename TableSource::char_type*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>

        <section id="table_pull.comparison.ge">
          <name><c>operator>=</c></name>
          <code-item>
            <code>
template &lt;class TableSourceL, class TableSourceR,
          class AllocatorL, class AllocatorR>
  bool operator>=(const table_pull&lt;TableSourceL, AllocatorL>&amp; l,
                  const table_pull&lt;TableSourceR, AllocatorR>&amp; r) noexcept;
template &lt;class TableSource, class Allocator, class Other>
  bool operator>=(const table_pull&lt;TableSource, Allocator>&amp;   l,
                  const Other&amp;                                r) noexcept(<nc>see below</nc>);
template &lt;class TableSource, class Allocator, class Other>
  bool operator>=(const Other&amp;                                l,
                  const table_pull&lt;TableSource, Allocator>&amp;   r) noexcept(<nc>see below</nc>);
            </code>
            <returns><c>!(l &lt; r)</c>.</returns>
            <remark>The expressions inside <c>noexcept</c> of the second and the third overloads are <c>true</c> if <c>std::is_convertible&lt;Other, const typename TableSource::char_type*>::value</c> is <c>false</c> and neither <c>o.size()</c> nor <c>o.data()</c> is potentially-throwing.</remark>
          </code-item>
        </section>
      </section>

      <section id="table_pull.io">
        <name><c>table_pull</c> inserters</name>
        <code-item>
          <code>
template &lt;class TableSource, class Allocator>
  std::basic_ostream&lt;typename TableSource::char_type, typename TableSource::traits_type>&amp;
    operator&lt;&lt;(std::basic_ostream&lt;typename TableSource::char_type,
                                  typename TableSource::traits_type>&amp; os,
                const table_pull&lt;TableSource, Allocator>&amp; o);
          </code>
          <effects>Behaves as a formatted output function of <c>os</c>.
                   Forms a character sequence <c>seq</c>, initially consisting of the elements defined by the range [<c>o.cbegin()</c>, <c>o.cend()</c>).
                   Determines padding for <c>seq</c>. Then inserts <c>seq</c> as if by calling <c>os.rdbuf()->sputn(seq, n)</c>, where <c>n</c> is the larger of <c>os.width()</c> and the size of <c>seq</c>; then calls <c>os.width(0)</c>.</effects>
          <returns><c>os</c>.</returns>
        </code-item>
      </section>

      <section id="table_pull.conversion">
        <name><c>table_pull</c> conversion</name>

        <code-item>
          <code>
template &lt;class TableSource, class Allocator, class OtherAllocator>
  std::basic_string&lt;typename TableSource::char_type,
                    typename TableSource::traits_type, OtherAllocator>
    operator+(const table_pull&lt;TableSource, Allocator>&amp; left,
              const std::basic_string&lt;typename TableSource::char_type,
                                      typename TableSource::traits_type, OtherAllocator>&amp; right);
template &lt;class TableSource, class Allocator, class OtherAllocator>
  std::basic_string&lt;typename TableSource::char_type,
                    typename TableSource::traits_type, OtherAllocator>
    operator+(const table_pull&lt;TableSource, Allocator>&amp; left,
              std::basic_string&lt;typename TableSource::char_type,
                                typename TableSource::traits_type, OtherAllocator>&amp;&amp; right);
template &lt;class TableSource, class Allocator, class OtherAllocator>
  std::basic_string&lt;typename TableSource::char_type,
                    typename TableSource::traits_type, OtherAllocator>
    operator+(const std::basic_string&lt;typename TableSource::char_type,
                                      typename TableSource::traits_type, OtherAllocator>&amp; left,
              const table_pull&lt;TableSource, Allocator>&amp; right);
template &lt;class TableSource, class Allocator, class OtherAllocator>
  std::basic_string&lt;typename TableSource::char_type,
                    typename TableSource::traits_type, OtherAllocator>
    operator+(std::basic_string&lt;typename TableSource::char_type,
                                typename TableSource::traits_type, OtherAllocator>&amp;&amp; left,
              const table_pull&lt;TableSource, Allocator>&amp; right);
          </code>
          <returns>A string object whose content is [<c>l.cbegin()</c>, <c>l.cend()</c>) and [<c>r.cbegin()</c>, <c>r.cend()</c>) concatenated
                    where <c>l</c> and <c>r</c> are the values of <c>left</c> and <c>right</c> before the call respectively.</returns>
          <remark>If an exception is thrown by an instance of these function templates, the invocation shall have no effect.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class TableSource, class Allocator, class OtherAllocator>
  std::basic_string&lt;typename TableSource::char_type,
                    typename TableSource::traits_type, OtherAllocator>&amp;
    operator+=(std::basic_string&lt;typename TableSource::char_type,
                                 typename TableSource::traits_type, OtherAllocator>&amp; left,
               const table_pull&lt;TableSource, Allocator>&amp; right);
          </code>
          <effects>Equivalent to call <c>left.append(right.cbegin(), right.cend())</c>.</effects>
          <returns><c>left</c>.</returns>
          <remark>If an exception is thrown by an instance of these function templates, the invocation shall have no effect.</remark>
        </code-item>

        <code-item>
          <code>
template &lt;class TableSource, class Allocator,
          class OtherAllocator = std::allocator&lt;typename TableSource::char_type>>
  std::basic_string&lt;typename TableSource::char_type,
                    std::char_traits&lt;typename TableSource::char_type>,
                    OtherAllocator>
    to_string(const table_pull&lt;TableSource, Allocator>&amp; o,
              const OtherAllocator&amp; alloc = Allocator());
          </code>
          <returns><c>std::basic_string&lt;typename TableSource::char_type, std::char_traits&lt;typename TableSource::char_type>, OtherAllocator>(o.cbegin(), o.cend(), alloc)</c>.</returns>
        </code-item>
      </section>

      <section id="table_pull.creation">
        <name><c>table_pull</c> creation functions</name>
        <code-item>
          <code>
template &lt;class TableSource, class... Appendices>
  table_pull&lt;std::decay_t&lt;TableSource>>
    make_table_pull(TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return table_pull&lt;std::decay_t&lt;TableSource>>(std::forward&lt;TableSource>(in),
                                             std::forward&lt;Appendices>(appendices)...);</code></effects>
        </code-item>

        <code-item>
          <code>
template &lt;class TableSource, class Allocator, class... Appendices>
  table_pull&lt;std::decay_t&lt;TableSource>, Allocator>
    make_table_pull(std::allocator_arg_t, const Allocator&amp; alloc,
                    TableSource&amp;&amp; in, Appendices&amp;&amp;... appendices);
          </code>
          <effects><p>Equivalent to:</p>
                   <code>return table_pull&lt;std::decay_t&lt;TableSource>, Allocator>(std::allocator_arg, alloc,
                                                        std::forward&lt;TableSource>(in),
                                                        std::forward&lt;Appendices>(appendices)...);</code></effects>
        </code-item>
      </section>
    </section>
  </section>
</section>

</document>
